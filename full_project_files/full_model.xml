<project name="mta_realtime_final" pubsub="auto" threads="8" heartbeat-interval="1">
  <metadata>
    <meta id="layout">{"cq1":{
"outputRecords_station":{"x":870,"y":3410},
"outputRecords_station_gate":{"x":870,"y":3530},
"outputRecords_track":{"x":1120,"y":3410},
"outputRecords_track_gate":{"x":1120,"y":3530},
"outputRecords_train":{"x":1370,"y":3410},
"outputRecords_train_gate":{"x":1370,"y":3530},
"compute_station_trainInStation":{"x":616,"y":1130},
"compute_station_nextStation":{"x":679,"y":1130},
"compute_station_nextTrack":{"x":826,"y":1130},
"compute_track_enrouteTrain1":{"x":889,"y":1130},
"compute_track_enrouteTrain2":{"x":1015,"y":1130},
"compute_station_prevStation":{"x":1099,"y":1130},
"compute_station_prevTrack":{"x":1246,"y":1130},
"compute_station_lastDepartedTrainTime":{"x":1341,"y":1130},
"compute_track_lastEnrouteTrainEnd":{"x":1404,"y":1130},
"compute_station_lastDepartedTrain":{"x":1488,"y":1130},
"compute_track_lastEnrouteTrain":{"x":1582,"y":1130},
"gateUnion_train_trainLatitude":{"x":952,"y":1250},
"gateUnion_train_trainLongitude":{"x":952,"y":1250},
"gate_train_trainLatitude":{"x":921,"y":1370},
"gate_train_trainLongitude":{"x":984,"y":1370},
"compute_station_numTrainsAtNextStation":{"x":648,"y":1490},
"compute_station_nextStationTrain1":{"x":711,"y":1490},
"compute_station_nextTrackTrain2":{"x":742,"y":1490},
"compute_station_nextStationTrain2":{"x":774,"y":1490},
"compute_station_numTrainsEnrouteFromThis":{"x":805,"y":1490},
"compute_station_nextTrackTrain1":{"x":858,"y":1490},
"compute_train_trainLatitude":{"x":921,"y":1490},
"compute_train_trainLongitude":{"x":984,"y":1490},
"compute_station_prevStationTrain2":{"x":1036,"y":1490},
"compute_station_prevStationTrain1":{"x":1068,"y":1490},
"compute_station_numTrainsAtPrevStation":{"x":1162,"y":1490},
"compute_station_prevTrackTrain2":{"x":1194,"y":1490},
"compute_station_prevTrackTrain1":{"x":1246,"y":1490},
"compute_station_numTrainsEnrouteToThis":{"x":1309,"y":1490},
"compute_station_lastDepartedTrainArrivalTime":{"x":1456,"y":1490},
"compute_station_lastDepartedTrainStatus":{"x":1519,"y":1490},
"compute_track_lastEnrouteTrainStart":{"x":1551,"y":1490},
"compute_track_lastEnrouteTrainStatus":{"x":1614,"y":1490},
"gateUnion_station_expectedNextTrain2ID":{"x":1131,"y":1610},
"gateUnion_station_expectedNextTrain1ID":{"x":1162,"y":1610},
"gateUnion_station_waitTime":{"x":1435,"y":1610},
"gateUnion_track_travelTime":{"x":1519,"y":1610},
"gate_station_expectedNextTrain2ID":{"x":1131,"y":1730},
"gate_station_expectedNextTrain1ID":{"x":1162,"y":1730},
"gate_station_waitTime":{"x":1435,"y":1730},
"gate_track_travelTime":{"x":1519,"y":1730},
"compute_station_expectedNextTrain2ID":{"x":1131,"y":1850},
"compute_station_expectedNextTrain1ID":{"x":1162,"y":1850},
"compute_station_waitTime":{"x":1435,"y":1850},
"compute_track_travelTime":{"x":1519,"y":1850},
"compute_station_waitTimeRollingAvg":{"x":1435,"y":1970},
"compute_track_travelTimeRollingAvg":{"x":1519,"y":1970},
"gateUnion_station_prevTrackTravelTime":{"x":1372,"y":2090},
"gate_station_prevTrackTravelTime":{"x":1372,"y":2210},
"compute_station_prevTrackTravelTime":{"x":1372,"y":2330},
"gateUnion_station_expectedNextTrain1Time":{"x":1278,"y":2450},
"gate_station_expectedNextTrain1Time":{"x":1278,"y":2570},
"compute_station_expectedNextTrain1Time":{"x":1278,"y":2690},
"gateUnion_station_expectedNextTrain2Time":{"x":1225,"y":2810},
"gate_station_expectedNextTrain2Time":{"x":1225,"y":2930},
"compute_station_expectedNextTrain2Time":{"x":1225,"y":3050},
"gateUnion_endEnrichment":{"x":1120,"y":3170},
"enrichDataModelEnd":{"x":1120,"y":3290},
"readAssetTypeDefinitions":{"x":25,"y":50},
"defineAssetTypes":{"x":25,"y":175},
"readAttributeDefinitions":{"x":235,"y":50},
"defineAttributes":{"x":235,"y":175},
"readHierarchyDefinitions":{"x":445,"y":50},
"defineHierarchies":{"x":445,"y":175},
"initialAssetUpdates":{"x":25,"y":425},
"initialAssetUpdatesForUnion":{"x":25,"y":550},
"ongoingAssetUpdates":{"x":235,"y":425},
"ongoingAssetUpdatesForUnion":{"x":235,"y":550},
"historicalAssetUpdates":{"x":445,"y":550},
"unionAssetUpdates":{"x":235,"y":675},
"updateAssets":{"x":235,"y":800},
"initialHierarchyUpdates":{"x":25,"y":1050},
"initialHierarchyUpdatesForUnion":{"x":25,"y":1175},
"ongoingHierarchyUpdates":{"x":235,"y":1050},
"ongoingHierarchyUpdatesForUnion":{"x":235,"y":1175},
"historicalHierarchyUpdates":{"x":445,"y":1175},
"unionHierarchyUpdates":{"x":235,"y":1300},
"updateHierarchies":{"x":235,"y":1425},
"staticAttributesDataSource":{"x":770,"y":290},
"historicalDataSource":{"x":1005,"y":50},
"historicalDataSourceSplitter":{"x":1005,"y":170},
"historicalData":{"x":1005,"y":290},
"realtimeTriggerRaw":{"x":1475,"y":170},
"realtimeTrigger":{"x":1475,"y":290},
"unionDataSources":{"x":1120,"y":410},
"unionDataFilter":{"x":1120,"y":530},
"updateCurrentValue":{"x":1120,"y":650},
"updateHistory":{"x":1120,"y":770},
"consolidateCurrentValue":{"x":1120,"y":890},
"enrichDataModelStart":{"x":1120,"y":1010},
"updateReadTimestampHistory":{"x":1355,"y":1010},
"outputRecords_heartBeat":{"x":1120,"y":3470},
"outputRecords_union":{"x":1120,"y":3650},
"outputRecords_gate":{"x":1120,"y":3770},
"outputCompletion":{"x":1120,"y":3890},
"updateReadTimestamp":{"x":1120,"y":4010}
,"scoredRecordsUnion_station":{"x":2300,"y":50}
,"scoredRecords_station":{"x":2300,"y":410}
,"scoredRecordsUnion_track":{"x":3535,"y":50}
,"scoredRecords_track":{"x":3535,"y":410}
,"scoredRecordsUnion_train":{"x":4770,"y":50}
,"scoredRecords_train":{"x":4770,"y":410}
    }}</meta>
  </metadata>
  <properties>
    <property name="ICCUSERID"><![CDATA[hazhan]]></property>
    <property name="ESP_PROJECT_HOME"><![CDATA[/export/sas-viya/homes/@ICCUSERID@/Common_Data/ICC-Deployments/MTA/programs/@ICCUSERID@/Phase-5---Deployment/13_deployFinalProject/mta_realtime_final/0.1/home]]></property>
    <property name="ESP_PROJECT_OUTPUT"><![CDATA[/export/sas-viya/homes/@ICCUSERID@/Common_Data/ICC-Deployments/MTA/data/@ICCUSERID@/output/final]]></property>
    <property name="historyInterval"><![CDATA[30]]></property>
    <property name="outputInterval"><![CDATA[30]]></property>
    <property name="logLevel"><![CDATA[info]]></property>
    <property name="performanceMonitoring"><![CDATA[true]]></property>
    <property name="secondsNeededToMaintainState"><![CDATA[630]]></property>
  </properties>
  <mas-modules>
    <mas-module module="defineAssetTypesModule" language="ds2" func-names="runDefineAssetTypes">
      <code><![CDATA[ds2_options sas;
 
        package defineAssetTypesPackage / overwrite = yes;
 
          declare double rc0 rc rc1 rc1s rc2 rc2s rcsleep cnt cnt2 rcALL;
          declare integer numAssetTypes foundAssetType gateCnt numOutputAssetTypes isInitThread;
          declare integer numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method initializeGates (bigint gt, bigint nr);
 
            declare integer i;
 
            /*** Initialize shared vectors to track the status for this gate ***/
            do i=1 to nr;
              if checkIfVectorExists('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)))=0 then do;
                createVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),1);
                rc  = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
                putVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
                deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
              end;
            end;
 
          end;
 
          method init();
 
            declare integer i;
 
            /*** Create the hash table ***/
            rc1 = st.hashTblCreate(0);
            if rc1=0 then do;
 
              loggerString = 'NOTE: Created shared hash table';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            end;
 
            /*** Initialize a shared vector statusAB to hold whether the A or B current value is updated ***/
            if checkIfVectorExists('statusAB')=0 then do;
              createVector('statusAB',1);
              rc = st.setString('statusAB',0,'A');
              putVector('statusAB');
              deleteVector('statusAB');
            end;
 
            /*** Initialize a shared vector outputInProgress to hold whether output is in progress for an individual trigger ***/
            if checkIfVectorExists('outputInProgress')=0 then do;
              createVector('outputInProgress',1);
              rc = st.setString('outputInProgress',0,'false');
              putVector('outputInProgress');
              deleteVector('outputInProgress');
            end;
 
            /*** Initialize a shared vector devMeasHistoryList to hold which devMeas need to receive history processing at history interval ***/
            if checkIfVectorExists('devMeasHistoryList')=0 then do;
              createVector('devMeasHistoryList',1001);
              rc = st.setInt('devMeasHistoryList',0,0);
              putVector('devMeasHistoryList');
              deleteVector('devMeasHistoryList');
            end;
 
            /*** Initialize a shared vector rawRecordCount to hold the raw record count  ***/
            if checkIfVectorExists('rawRecordCount')=0 then do;
              createVector('rawRecordCount',1);
              rc = st.setLong('rawRecordCount',0,0);
              putVector('rawRecordCount');
              deleteVector('rawRecordCount');
            end;
 
            /*** Initialize a shared vector printRawQueueCount to hold the raw queue count  ***/
            if checkIfVectorExists('printRawQueueCount')=0 then do;
              createVector('printRawQueueCount',1);
              rc = st.setLong('printRawQueueCount',0,0);
              putVector('printRawQueueCount');
              deleteVector('printRawQueueCount');
            end;
 
            /*** Initialize a shared vector printTriggerQueueCount to hold the raw queue count  ***/
            if checkIfVectorExists('printTriggerQueueCount')=0 then do;
              createVector('printTriggerQueueCount',1);
              rc = st.setLong('printTriggerQueueCount',0,0);
              putVector('printTriggerQueueCount');
              deleteVector('printTriggerQueueCount');
            end;
 
            /*** Initialize a shared vector expectedNextTimestamp to hold the next  ***/
            if checkIfVectorExists('expectedNextTimestamp')=0 then do;
              createVector('expectedNextTimestamp',1);
              rc = st.setLong('expectedNextTimestamp',0,0);
              putVector('expectedNextTimestamp');
              deleteVector('expectedNextTimestamp');
            end;
 
            /*** Initialize a shared vector assetTypeList to hold the list of asset types  ***/
            if checkIfVectorExists('assetTypeList')=0 then do;
              createVector('assetTypeList',101);
              rc = st.setInt('assetTypeList',0,0);
              putVector('assetTypeList');
              deleteVector('assetTypeList');
            end;
 
            /*** Initialize a shared vector outputAssetTypeList to hold the list of asset types that will be output ***/
            if checkIfVectorExists('outputAssetTypeList')=0 then do;
              createVector('outputAssetTypeList',101);
              rc = st.setInt('outputAssetTypeList',0,0);
              putVector('outputAssetTypeList');
              deleteVector('outputAssetTypeList');
            end;
 
            if checkIfVectorExists('outputAssetTypeListTHIS')=0 then do;
              createVector('outputAssetTypeListTHIS',101);
              rc = st.setInt('outputAssetTypeListTHIS',0,0);
              putVector('outputAssetTypeListTHIS');
              deleteVector('outputAssetTypeListTHIS');
            end;
 
            /*** Initialize a shared vector outputRecordsToABT to hold whether to output ***/
            /*** or whether preprocesing is occurring and no output is needed ***/
            if checkIfVectorExists('outputRecordsToABT')=0 then do;
              createVector('outputRecordsToABT',1);
              rc = st.setString('outputRecordsToABT',0,'N');
              putVector('outputRecordsToABT');
              deleteVector('outputRecordsToABT');
            end;
 
            /*** Initialize a shared vector hierarchyList to hold the next  ***/
            if checkIfVectorExists('hierarchyList')=0 then do;
              createVector('hierarchyList',100);
              rc = st.setInt('hierarchyList',0,0);
              putVector('hierarchyList');
              deleteVector('hierarchyList');
            end;
 
            /*** Initialize the number of requirements for the output gate - up to 100 asset types ***/
            do gateCnt=1 to 100;
              if checkIfVectorExists('outputGate_req'||strip(put(gateCnt,z4.)))=0 then do;
                createVector('outputGate_req'||strip(put(gateCnt,z4.)),1);
                rc  = st.setLong('outputGate_req'||strip(put(gateCnt,z4.)),0,0);
                putVector('outputGate_req'||strip(put(gateCnt,z4.)));
                deleteVector('outputGate_req'||strip(put(gateCnt,z4.)));
              end;
            end;
 
            /*** Initialize the number of requirements for the output gates for each asset type - up to MAXNUMASSETS assets per asset type ***/
            do gateCnt=1 to 10000;
              if checkIfVectorExists('outputGate_station_req'||strip(put(gateCnt,z5.)))=0 then do;
                createVector('outputGate_station_req'||strip(put(gateCnt,z5.)),1);
                rc  = st.setLong('outputGate_station_req'||strip(put(gateCnt,z5.)),0,0);
                putVector('outputGate_station_req'||strip(put(gateCnt,z5.)));
                deleteVector('outputGate_station_req'||strip(put(gateCnt,z5.)));
              end;
            end;
            /*** Initialize the number of requirements for the output gates for each asset type - up to MAXNUMASSETS assets per asset type ***/
            do gateCnt=1 to 10000;
              if checkIfVectorExists('outputGate_track_req'||strip(put(gateCnt,z5.)))=0 then do;
                createVector('outputGate_track_req'||strip(put(gateCnt,z5.)),1);
                rc  = st.setLong('outputGate_track_req'||strip(put(gateCnt,z5.)),0,0);
                putVector('outputGate_track_req'||strip(put(gateCnt,z5.)));
                deleteVector('outputGate_track_req'||strip(put(gateCnt,z5.)));
              end;
            end;
            /*** Initialize the number of requirements for the output gates for each asset type - up to MAXNUMASSETS assets per asset type ***/
            do gateCnt=1 to 10000;
              if checkIfVectorExists('outputGate_train_req'||strip(put(gateCnt,z5.)))=0 then do;
                createVector('outputGate_train_req'||strip(put(gateCnt,z5.)),1);
                rc  = st.setLong('outputGate_train_req'||strip(put(gateCnt,z5.)),0,0);
                putVector('outputGate_train_req'||strip(put(gateCnt,z5.)));
                deleteVector('outputGate_train_req'||strip(put(gateCnt,z5.)));
              end;
            end;
 
/*** Initialize the number of requirements for each gate ***/
initializeGates(1, 2);
initializeGates(2, 3);
initializeGates(3, 4);
initializeGates(4, 6);
initializeGates(5, 2);
initializeGates(6, 3);
initializeGates(7, 3);
initializeGates(8, 2);
initializeGates(9, 2);
initializeGates(10, 15);
 
            /*** Initialize a shared vector to hold the number of raw records waiting, next, and last - max size is 100000 ***/
            if checkIfVectorExists('rawRecordQueue')=0 then do;
              createVector('rawRecordQueue',3);
              rc = st.setInt('rawRecordQueue',0,0);
              rc = st.setInt('rawRecordQueue',1,0);
              rc = st.setInt('rawRecordQueue',2,0);
              putVector('rawRecordQueue');
              deleteVector('rawRecordQueue');
            end;
 
            /*** Initialize a shared vector to hold the number of trigger records waiting, next, and last - max size is 1000 ***/
            if checkIfVectorExists('triggerRecordQueue')=0 then do;
              createVector('triggerRecordQueue',3);
              rc = st.setInt('triggerRecordQueue',0,0);
              rc = st.setInt('triggerRecordQueue',1,0);
              rc = st.setInt('triggerRecordQueue',2,0);
              putVector('triggerRecordQueue');
              deleteVector('triggerRecordQueue');
            end;
 
            /*** Initialize a shared vector to hold the number of connection update records waiting, next, and last - max size is 10000 ***/
            if checkIfVectorExists('connRecordQueue')=0 then do;
              createVector('connRecordQueue',1);
              rc = st.setLong('connRecordQueue',0,0);
              putVector('connRecordQueue');
              deleteVector('connRecordQueue');
            end;
 
            if checkIfVectorExists('connRecordQueueL')=0 then do;
              createVector('connRecordQueueL',1);
              rc = st.setLong('connRecordQueueL',0,0);
              putVector('connRecordQueueL');
              deleteVector('connRecordQueueL');
            end;
 
            /*** Initialize a shared vector to hold the number of asset update records waiting, next, and last - max size is 10000 ***/
            if checkIfVectorExists('assetRecordQueue')=0 then do;
              createVector('assetRecordQueue',1);
              rc = st.setLong('assetRecordQueue',0,0);
              putVector('assetRecordQueue');
              deleteVector('assetRecordQueue');
            end;
 
            if checkIfVectorExists('assetRecordQueueL')=0 then do;
              createVector('assetRecordQueueL',1);
              rc = st.setLong('assetRecordQueueL',0,0);
              putVector('assetRecordQueueL');
              deleteVector('assetRecordQueueL');
            end;
 
            if checkIfVectorExists('assetRecordQueueCV')=0 then do;
              createVector('assetRecordQueueCV',1);
              rc = st.setLong('assetRecordQueueCV',0,0);
              putVector('assetRecordQueueCV');
              deleteVector('assetRecordQueueCV');
            end;
 
            if checkIfVectorExists('assetRecordQueueCVL')=0 then do;
              createVector('assetRecordQueueCVL',1);
              rc = st.setLong('assetRecordQueueCVL',0,0);
              putVector('assetRecordQueueCVL');
              deleteVector('assetRecordQueueCVL');
            end;
 
            /*** Initialize a shared vector to hold the number of delete update records waiting, next, and last - max size is 10000 ***/
            if checkIfVectorExists('deleteRecordQueue')=0 then do;
              createVector('deleteRecordQueue',1);
              rc = st.setLong('deleteRecordQueue',0,0);
              putVector('deleteRecordQueue');
              deleteVector('deleteRecordQueue');
            end;
 
            if checkIfVectorExists('deleteRecordQueueL')=0 then do;
              createVector('deleteRecordQueueL',1);
              rc = st.setLong('deleteRecordQueueL',0,0);
              putVector('deleteRecordQueueL');
              deleteVector('deleteRecordQueueL');
            end;
 
            /*** Initialize a shared vector to hold whether the derived attributes and output tables need to have their symlinks renewed ***/
            if checkIfVectorExists('symUpdateNeeded')=0 then do;
              createVector('symUpdateNeeded',1);
              rc = st.setInt('symUpdateNeeded',0,1);
              putVector('symUpdateNeeded');
              deleteVector('symUpdateNeeded');
            end;
 
          end;
 
          method defineAssetType (char(75) dt, char(100) dl, char(1) ofr);
 
            /*** retrieve assetTypeList vector and check whether assetType is already in list ***/
            numAssetTypes=0;
            foundAssetType=0;
            getVector ('assetTypeList');
            numAssetTypes=st.getInt('assetTypeList',0);
            do cnt=1 to numAssetTypes;
              if strip(st.getString('assetTypeList',cnt))=strip(dt) then foundAssetType=1;
            end;
 
            numOutputAssetTypes=0;
            getVector ('outputAssetTypeList');
            numOutputAssetTypes=st.getInt('outputAssetTypeList',0);
 
            if foundAssetType=0 then do;
 
              /*** initiate assetType hash with info provided ***/
              createVector ('assetType|'||strip(dt),1);
              rc = st.setString('assetType|'||strip(dt),0,strip(dl));
              putVector ('assetType|'||strip(dt));
              deleteVector ('assetType|'||strip(dt));
 
              /*** initiate assetType|assetList hash for that asset type - allow up to 10000 ***/
              createVector ('assetType|'||strip(dt)||'|assetList',10001);
              rc = st.setInt('assetType|'||strip(dt)||'|assetList',0,0);
              putVector ('assetType|'||strip(dt)||'|assetList');
              deleteVector ('assetType|'||strip(dt)||'|assetList');
 
              /*** initiate assetType|outputAssetList hash for that asset type - allow up to 10000 ***/
              createVector ('assetType|'||strip(dt)||'|outputAssetList',10001);
              rc = st.setInt('assetType|'||strip(dt)||'|outputAssetList',0,0);
              putVector ('assetType|'||strip(dt)||'|outputAssetList');
              deleteVector ('assetType|'||strip(dt)||'|outputAssetList');
 
              /*** initiate the assetType|attributeList hash with no attributes - allow up to 100 ***/
              createVector ('assetType|'||strip(dt)||'|attributeList',1001);
              rc = st.setInt('assetType|'||strip(dt)||'|attributeList',0,0);
              putVector ('assetType|'||strip(dt)||'|attributeList');
              deleteVector ('assetType|'||strip(dt)||'|attributeList');
 
              /*** initiate the assetType|rawAttributeList hash with no attributes - allow up to 100 ***/
              createVector ('assetType|'||strip(dt)||'|rawAttributeList',1001);
              rc = st.setInt('assetType|'||strip(dt)||'|rawAttributeList',0,0);
              putVector ('assetType|'||strip(dt)||'|rawAttributeList');
              deleteVector ('assetType|'||strip(dt)||'|rawAttributeList');
 
              /*** add to the assetTypeList hash ***/
              numAssetTypes=numAssetTypes+1;
              rc = st.setInt('assetTypeList',0,numAssetTypes);
              rc = st.setString('assetTypeList',numAssetTypes,strip(dt));
              replaceVector ('assetTypeList');
 
              /*** add to the assetTypeList hash ***/
              if ofr='Y' then do;
 
                numOutputAssetTypes=numOutputAssetTypes+1;
                rc = st.setInt('outputAssetTypeList',0,numOutputAssetTypes);
                rc = st.setString('outputAssetTypeList',numOutputAssetTypes,strip(dt));
                replaceVector ('outputAssetTypeList');
 
              end;
 
              loggerString = 'NOTE: Defined assetType '||strip(dt);
              writeTo.log('i', loggerString);
 
            end;
            else do;
 
              loggerString = 'WARNING: assetType '||strip(dt)||' already exists.';;
              writeTo.log('i', loggerString);
 
            end;
 
            /*** delete the local assetTypeList vector ***/
            deleteVector ('assetTypeList');
            deleteVector ('outputAssetTypeList');
 
          end;
 
          method runDefineAssetTypes(
            char(75)  assetType,
            char(100) assetTypeLabel,
            char(1)   outputFileRequired
          );
 
            /*** replace special characters ***/
            assetType=tranwrd(assetType,'|','^$*1*$^');
 
            defineAssetType(assetType,assetTypeLabel,outputFileRequired);
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="defineAttributesModule" language="ds2" func-names="runDefineAttributes">
      <code><![CDATA[ds2_options sas;
 
        package defineAttributesPackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep cnt cnt2;
          declare integer numAssetTypes foundAssetType;
          declare integer numAttributes foundAttribute;
          declare integer numRawAttributes foundRawAttribute;
          declare integer numDevMeasHist;
          declare integer numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
          declare char(300) thisAssetID;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method defineAttribute(
                                 char(75)  ast,
                                 char(20)  att,
                                 char(100) ati,
                                 char(100) atl,
                                 char(20)  ty,
                                 integer   lg,
                                 char(20)  fm,
                                 integer   vw,
                                 double    amn,
                                 char(20)  amnlg,
                                 double    amx,
                                 char(20)  amxlg,
                                 integer   hme,
                                 integer   hmt,
                                 char(32)  sasat
                                );
 
            /*** retrieve assetTypeList vector and check whether assetType is already in list ***/
            numAssetTypes=0;
            foundAssetType=0;
            getVector ('assetTypeList');
 
            numAssetTypes=st.getInt('assetTypeList',0);
            foundAssetType=0;
            do cnt=1 to numAssetTypes;
              if strip(st.getString('assetTypeList',cnt))=strip(ast) then foundAssetType=1;
            end;
 
            deleteVector ('assetTypeList');
 
            /* add the attribute to the specified asset type */
            if foundAssetType=1 then do;
 
              /*** check if the attribute already exists ***/
              numAttributes=0;
              foundAttribute=0;
              getVector ('assetType|'||strip(ast)||'|attributeList');
 
              numAttributes=st.getInt('assetType|'||strip(ast)||'|attributeList',0);
              foundAttribute=0;
              do cnt=1 to numAttributes;
                if strip(st.getString('assetType|'||strip(ast)||'|attributeList',cnt))=strip(ati) then foundAttribute=1;
              end;
 
              if foundAttribute=0 then do;
 
                /*** add attributeInfo to the attributeInfo hash ***/
                createVector ('assetType|'||strip(ast)||'|attribute|'||strip(ati), 15);
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),0,strip(att));
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),1,strip(atl));
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),2,strip(ty));
                rc = st.setInt('assetType|'||strip(ast)||'|attribute|'||strip(ati),3,lg);
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),4,strip(fm));
                rc = st.setInt('assetType|'||strip(ast)||'|attribute|'||strip(ati),5,vw);
                rc = st.setDouble('assetType|'||strip(ast)||'|attribute|'||strip(ati),6,amn);
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),7,strip(amnlg));
                rc = st.setDouble('assetType|'||strip(ast)||'|attribute|'||strip(ati),8,amx);
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),9,strip(amxlg));
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),10,'');
                rc = st.setInt('assetType|'||strip(ast)||'|attribute|'||strip(ati),11,hme);
                rc = st.setInt('assetType|'||strip(ast)||'|attribute|'||strip(ati),12,hmt);
                rc = st.setString('assetType|'||strip(ast)||'|attribute|'||strip(ati),13,strip(sasat));
 
                putVector ('assetType|'||strip(ast)||'|attribute|'||strip(ati));
                deleteVector ('assetType|'||strip(ast)||'|attribute|'||strip(ati));
 
                /*** if the attribute will have history, add the assetType/attributeID to the updateHistoryList ***/
                if hmt gt 0 then do;
 
                  numDevMeasHist=0;
                  getVector ('devMeasHistoryList');
                  numDevMeasHist=st.getInt('devMeasHistoryList',0);
 
                  numDevMeasHist=numDevMeasHist+1;
                  rc = st.setInt('devMeasHistoryList',0,numDevMeasHist);
                  rc = st.setString('devMeasHistoryList',numDevMeasHist,strip(ast)||'|'||strip(ati));
                  replaceVector ('devMeasHistoryList');
                  deleteVector ('devMeasHistoryList');
 
                end;
 
                /*** add attribute to the attributeList hash ***/
                numAttributes=numAttributes+1;
                rc = st.setInt('assetType|'||strip(ast)||'|attributeList',0,numAttributes);
                rc = st.setString('assetType|'||strip(ast)||'|attributeList',numAttributes,strip(ati));
                replaceVector ('assetType|'||strip(ast)||'|attributeList');
 
                loggerString = 'NOTE: Defined attributeID '||strip(ati)||' for assetType '||strip(ast)||'.';
                writeTo.log('i', loggerString);
 
              end;
              else do;
 
                loggerString = 'WARNING: Attribute '||strip(ati)||' for assetType '||strip(ast)||' already exists.';
                writeTo.log('i', loggerString);
 
              end;
              deleteVector ('assetType|'||strip(ast)||'|attributeList');
 
              /*** check if the attribute already exists ***/
              if strip(att)='raw' then do;
 
                numRawAttributes=0;
                foundRawAttribute=0;
                getVector ('assetType|'||strip(ast)||'|rawAttributeList');
 
                numRawAttributes=st.getInt('assetType|'||strip(ast)||'|rawAttributeList',0);
                foundRawAttribute=0;
                do cnt=1 to numRawAttributes;
                  if strip(st.getString('assetType|'||strip(ast)||'|rawAttributeList',cnt))=strip(ati) then foundRawAttribute=1;
                end;
 
                if foundRawAttribute=0 then do;
 
                  /*** add attribute to the attributeList hash ***/
                  numRawAttributes=numRawAttributes+1;
                  rc = st.setInt('assetType|'||strip(ast)||'|rawAttributeList',0,numRawAttributes);
                  rc = st.setString('assetType|'||strip(ast)||'|rawAttributeList',numRawAttributes,strip(ati));
                  replaceVector ('assetType|'||strip(ast)||'|rawAttributeList');
 
                end;
                else do;
 
                  loggerString = 'WARNING: Raw attribute '||strip(ati)||' for assetType '||strip(ast)||' already exists.';
                  writeTo.log('i', loggerString);
 
                end;
                deleteVector ('assetType|'||strip(ast)||'|rawAttributeList');
 
              end;
 
            end;
            else do;
 
              loggerString = 'ERROR: Attribute '||strip(ati)||' was not added for assetType '||strip(ast)||'. assetType '||strip(ast)||' does not exist.';
              writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method runDefineAttributes(
            char(75)  assetType,
            char(20)  attributeType,
            char(100) attributeID,
            char(100) attributeLabel,
            char(32)  SASAttributeID,
            char(20)  dataType,
            integer   dataLength,
            char(20)  dataFormat,
            integer   retentionPeriod,
            double    acceptableMin,
            char(20)  acceptableMinLogic,
            double    acceptableMax,
            char(20)  acceptableMaxLogic,
            integer   historyMaxEvents,
            integer   historyMaxTime
          );
 
            /*** replace special characters ***/
            assetType=tranwrd(assetType,'|','^$*1*$^');
            attributeID=tranwrd(attributeID,'|','^$*1*$^');
 
            defineAttribute(assetType,attributeType,attributeID,attributeLabel,
                            dataType,dataLength,dataFormat,retentionPeriod,
                            acceptableMin,acceptableMinLogic,acceptableMax,acceptableMaxLogic,
                            historyMaxEvents,historyMaxTime,SASAttributeID);
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="defineHierarchiesModule" language="ds2" func-names="runDefineHierarchies">
      <code><![CDATA[ds2_options sas;
 
        package defineHierarchiesPackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep cnt cnt2;
          declare integer numHierarchies foundHierarchy;
          declare integer numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method defineHierarchy (char(25) hi);
 
            /*** retrieve hierarchyList vector and check whether hierarchyName is already in list ***/
            numHierarchies=0;
            foundHierarchy=0;
 
            getVector ('hierarchyList');
 
            numHierarchies=st.getInt('hierarchyList',0);
            foundHierarchy=0;
            do cnt=1 to numHierarchies;
              if strip(st.getString('hierarchyList',cnt))=strip(hi) then foundHierarchy=1;
            end;
 
            if foundHierarchy=0 then do;
 
              /*** add to the hierarchyList hash ***/
              numHierarchies=numHierarchies+1;
              rc = st.setInt('hierarchyList',0,numHierarchies);
              rc = st.setString('hierarchyList',numHierarchies,strip(hi));
              replaceVector ('hierarchyList');
 
              loggerString = 'NOTE: Defined hierarchy '||strip(hi);
              writeTo.log('i', loggerString);
 
            end;
 
            deleteVector ('hierarchyList');
 
          end;
 
          method runDefineHierarchies(
            char(25)  hierarchyName
          );
 
            /*** replace special characters ***/
            hierarchyName=tranwrd(hierarchyName,'|','^$*1*$^');
 
            defineHierarchy(hierarchyName);
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="updateAssetsModule" language="ds2" func-names="runUpdateAssets">
      <code><![CDATA[ds2_options sas;
 
        package updateAssetsPackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep;
          declare integer numAssetTypes foundAssetType;
          declare integer numAssets foundAsset numOutputAssets;
          declare integer numAttributes foundAttribute;
          declare integer numRawAttributes foundRawAttribute;
          declare integer numHierarchies numParents numChildren;
          declare integer cnt cnt2;
          declare char(75) thisAssetType;
          declare char(100) thisAttributeID;
          declare char(25) thisHierarchyName;
          declare char(20) attributeType dataType dataFormat acceptableMinLogic acceptableMaxLogic;
          declare char(100) attributeLabel;
          declare char(300) tempItem thisParentAssetID thisChildAssetID;
          declare integer   dataLength historyMaxEvents historyMaxTime retentionPeriod numHistory;
          declare double    acceptableMin acceptableMax;
          declare bigint    markTime;
          declare integer   numItems foundTHIS cntALL cntTHIS;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method addAsset (char(300) di, char(75) dt, char(300) dl, char(1) oar, char(1) addToAList);
 
            /*** retrieve assetTypeList vector and check whether assetType is already in list ***/
            numAssetTypes=0;
            foundAssetType=0;
 
            getVector ('assetTypeList');
 
            numAssetTypes=st.getInt('assetTypeList',0);
            foundAssetType=0;
            do cnt=1 to numAssetTypes;
              if strip(st.getString('assetTypeList',cnt))=strip(dt) then foundAssetType=1;
            end;
            deleteVector ('assetTypeList');
 
            if foundAssetType=1 then do;
 
              /*** retrieve assetList vector and check whether assetID is already in list ***/
              numAssets=0;
              foundAsset=0;
              getVector ('assetType|'||strip(dt)||'|assetList');
              numAssets=st.getInt('assetType|'||strip(dt)||'|assetList',0);
              foundAsset=0;
              do cnt=1 to numAssets;
                if strip(st.getString('assetType|'||strip(dt)||'|assetList',cnt))=strip(di) then foundAsset=1;
              end;
 
              numOutputAssets=0;
              getVector ('assetType|'||strip(dt)||'|outputAssetList');
              numOutputAssets=st.getInt('assetType|'||strip(dt)||'|outputAssetList',0);
 
              if numAssets = 10000 then do;
 
                loggerString = 'ERROR: assetID '||strip(di)||' could not be added - number of assets at max.';
                writeTo.log('i', loggerString);
 
              end;
              else if foundAsset=0 then do;
 
                loggerString = 'NOTE: Adding assetID '||strip(di)||' of assetType '||strip(dt)||' (initialization)';
                writeTo.log('i', loggerString);
 
                /*** retrieve the attributes hash ***/
                numAttributes=0;
                getVector ('assetType|'||strip(dt)||'|attributeList');
                numAttributes=st.getInt('assetType|'||strip(dt)||'|attributeList',0);
 
                /*** make a copy of the attribute list and attach to the asset for easier navigation ***/
                createVector ('asset|'||strip(di)||'|attributeList',1001);
                rc = st.setInt('asset|'||strip(di)||'|attributeList',0,numAttributes);
 
                /*** iterate through the attributeList hash and initiate the assetID|attributeID|currentValueA,currentValueB,history hashes ***/
                do cnt=1 to numAttributes;
 
                  /*** choose a attributeID to process ***/
                  thisAttributeID=st.getString('assetType|'||strip(dt)||'|attributeList',cnt);
                  rc = st.setString('asset|'||strip(di)||'|attributeList',cnt,strip(thisAttributeID));
 
                  /*** pull information about the attribute ***/
                  attributeType      = '';
                  attributeLabel     = '';
                  dataType           = '';
                  dataLength         = .;
                  dataFormat         = '';
                  retentionPeriod     = .;
                  acceptableMin      = .;
                  acceptableMinLogic = '';
                  acceptableMax      = .;
                  acceptableMaxLogic = '';
                  historyMaxEvents   = .;
                  historyMaxTime     = .;
                  numHistory         = 0;
 
                  getVector ('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID));
 
                  attributeType      = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),0);
                  attributeLabel     = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),1);
                  dataType           = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),2);
                  dataLength         = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),3);
                  dataFormat         = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),4);
                  retentionPeriod     = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),5);
                  acceptableMin      = st.getDouble('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),6);
                  acceptableMinLogic = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),7);
                  acceptableMax      = st.getDouble('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),8);
                  acceptableMaxLogic = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),9);
 
                  historyMaxEvents   = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),11);
                  historyMaxTime     = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),12);
 
                  numHistory = int( (historyMaxTime * 1.0) / (@historyInterval@ * 1.0) );
 
                  deleteVector ('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID));
 
                  /*** initiate currentValue ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',4);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,'');
                  end;
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
 
                  /*** initiate lastValue ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',4);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,'');
                  end;
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
 
                  /*** initiate currentValueStorageA ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',1,strip(''));
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',3,'');
                  end;
 
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA');
 
                  /*** initiate currentValueStorageB ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',1,strip(''));
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',3,'');
                  end;
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB');
 
                  /*** initiate the history vector ***/
                  if numHistory gt 0 then do;
                    createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',4+(numHistory*2));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',0,strip(dataType));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',1,'');
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',2,numHistory);
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',3,0);
 
                    putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history');
                    deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history');
                  end;
 
                  /*** initiate the events vector ***/
                  if historyMaxEvents gt 0 then do;
                    createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',4+(historyMaxEvents*2));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',0,strip(dataType));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',1,'');
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',2,historyMaxEvents);
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',3,0);
 
                    putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events');
                    deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events');
                  end;
 
                  loggerString = 'NOTE: ...added attributeID '||strip(thisAttributeID);
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                end;
 
                /*** now store the copy of the attribute list attached to the asset for easier navigation ***/
                putVector ('asset|'||strip(di)||'|attributeList');
                deleteVector ('asset|'||strip(di)||'|attributeList');
 
                /*** retrieve the attributes hash ***/
                numRawAttributes=0;
                getVector ('assetType|'||strip(dt)||'|rawAttributeList');
                numRawAttributes=st.getInt('assetType|'||strip(dt)||'|rawAttributeList',0);
 
                /*** make a copy of the attribute list and attach to the asset for easier navigation ***/
                createVector ('asset|'||strip(di)||'|rawAttributeList',1001);
                rc = st.setInt('asset|'||strip(di)||'|rawAttributeList',0,numRawAttributes);
 
                /*** iterate through the attributeList hash and initiate the assetID|attributeID|currentValueA,currentValueB,history hashes ***/
                do cnt=1 to numRawAttributes;
 
                  /*** choose a attributeID to process ***/
                  thisAttributeID=st.getString('assetType|'||strip(dt)||'|rawAttributeList',cnt);
                  rc = st.setString('asset|'||strip(di)||'|rawAttributeList',cnt,strip(thisAttributeID));
 
                end;
 
                /*** now store the copy of the raw attribute list attached to the asset for easier navigation ***/
                putVector ('asset|'||strip(di)||'|rawAttributeList');
                deleteVector ('asset|'||strip(di)||'|rawAttributeList');
 
                /*** retrieve the hierarchies hash ***/
                numHierarchies=0;
 
                getVector ('hierarchyList');
 
                numHierarchies=st.getInt('hierarchyList',0);
 
                /*** iterate through the hierarchies hash and initiate assetID|parents|hierarchyName,children|hierarchyName hashes with no parents-children ***/
                do cnt=1 to numHierarchies;
 
                  /*** choose a hierarchyName to process ***/
                  thisHierarchyName=st.getString('hierarchyList',cnt);
 
                  /*** initiate the parents hash ***/
                  createVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),maxNumberParentsChildrenPlus1.);
                  rc = st.setInt('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),0,0);
                  putVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
                  deleteVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
 
                  /*** initiate the children hash ***/
                  createVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),maxNumberParentsChildrenPlus1.);
                  rc = st.setInt('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),0,0);
                  putVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
                  deleteVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
 
                  loggerString = 'NOTE: ...added parent and children vectors for hierarchy '||strip(thisHierarchyName);
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                end;
                deleteVector ('hierarchyList');
 
                /*** initiate assetID hash with info provided ***/
                createVector ('asset|'||strip(di),2);
                rc = st.setString('asset|'||strip(di),0,strip(dt));
                rc = st.setString('asset|'||strip(di),1,strip(dl));
                putVector ('asset|'||strip(di));
                deleteVector ('asset|'||strip(di));
 
                if addToAList='Y' then do;
 
                  /*** add assetID to assetList hash ***/
                  numAssets=numAssets+1;
                  rc = st.setInt('assetType|'||strip(dt)||'|assetList',0,numAssets);
                  rc = st.setString('assetType|'||strip(dt)||'|assetList',numAssets,strip(di));
                  replaceVector ('assetType|'||strip(dt)||'|assetList');
 
                  /* this is only used for initial asset updates */
                  if oar='Y' then do;
 
                    numOutputAssets=numOutputAssets+1;
                    rc = st.setInt('assetType|'||strip(dt)||'|outputAssetList',0,numOutputAssets);
                    rc = st.setString('assetType|'||strip(dt)||'|outputAssetList',numOutputAssets,strip(di));
                    replaceVector ('assetType|'||strip(dt)||'|outputAssetList');
 
                  end;
 
                end;
 
                loggerString = 'NOTE: ...complete';
                if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
              end;
              else do;
 
                loggerString = 'WARNING: assetID '||strip(di)||' already exists.';
                writeTo.log('i', loggerString);
 
              end;
              deleteVector ('assetType|'||strip(dt)||'|assetList');
              deleteVector ('assetType|'||strip(dt)||'|outputAssetList');
 
            end;
            else do;
 
              loggerString = 'ERROR: assetID '||strip(di)||' was not added. assetType '||strip(dt)||' does not exist.';
              writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method getAssetRecordQueueDetail(in_out bigint _assetRecordQueueSize);
 
            _assetRecordQueueSize=0;
 
            getVector ('assetRecordQueue');
 
            _assetRecordQueueSize=st.getLong('assetRecordQueue',0);
 
            deleteVector ('assetRecordQueue');
 
          end;
 
          method updateAssetRecordQueueDetail(bigint _assetRecordQueueSize);
 
            getVector ('assetRecordQueue');
 
            rc = st.setLong('assetRecordQueue',0,_assetRecordQueueSize);
 
            replaceVector ('assetRecordQueue');
            deleteVector ('assetRecordQueue');
 
          end;
 
          method queueAssetUpdate(
            char(50)  _action,
            char(300) _assetID,
            char(75)  _assetType,
            char(300) _assetLabel,
            char(1)   _outputAssetRequired,
            bigint    _msr_timestamp
          );
 
            declare bigint _AssetRecordQueueSize;
 
            getAssetRecordQueueDetail(_AssetRecordQueueSize);
 
            _AssetRecordQueueSize = _AssetRecordQueueSize + 1;
 
            updateAssetRecordQueueDetail(_AssetRecordQueueSize);
 
            newLocation=mod(_AssetRecordQueueSize-1,10000);
 
            if checkIfVectorExists('assetRecordQueue'||strip(put(newLocation,z4.))) = 0 then do;
              createVector('assetRecordQueue'||strip(put(newLocation,z4.)),6);
              rc = st.setLong('assetRecordQueue'||strip(put(newLocation,z4.)),0,0);
              rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),1,'action');
              rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),2,'assetID');
              rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),3,'assetType');
              rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),4,'assetLabel');
              rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),5,'outputAssetRequired');
              putVector('assetRecordQueue'||strip(put(newLocation,z4.)));
              deleteVector('assetRecordQueue'||strip(put(newLocation,z4.)));
            end;
 
            getVector ('assetRecordQueue'||strip(put(newLocation,z4.)));
 
            rc = st.setLong('assetRecordQueue'||strip(put(newLocation,z4.)),0,_msr_timestamp);
            rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),1,strip(_action));
            rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),2,strip(_assetID));
            rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),3,strip(_assetType));
            rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),4,strip(_assetLabel));
            rc = st.setString('assetRecordQueue'||strip(put(newLocation,z4.)),5,strip(_outputAssetRequired));
 
            replaceVector ('assetRecordQueue'||strip(put(newLocation,z4.)));
            deleteVector ('assetRecordQueue'||strip(put(newLocation,z4.)));
 
            loggerString = 'NOTE: Added asset '||strip(_action)||' / '||strip(_assetID)||' / '||strip(_assetType)||' / '||strip(_assetLabel)||' / '||strip(_outputAssetRequired)||' / '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' to asset location assetRecordQueue'||strip(put(newLocation,z4.))||'.';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method getDeleteRecordQueueDetail(in_out bigint _deleteRecordQueueSize);
 
            _deleteRecordQueueSize=0;
 
            getVector ('deleteRecordQueue');
 
            _deleteRecordQueueSize=st.getLong('deleteRecordQueue',0);
 
            deleteVector ('deleteRecordQueue');
 
          end;
 
          method updateDeleteRecordQueueDetail(bigint _deleteRecordQueueSize);
 
            getVector ('deleteRecordQueue');
 
            rc = st.setLong('deleteRecordQueue',0,_deleteRecordQueueSize);
 
            replaceVector ('deleteRecordQueue');
            deleteVector ('deleteRecordQueue');
 
          end;
 
          method queueDeleteUpdate(
            char(50)  _action,
            char(300) _assetID,
            char(75)  _assetType,
            char(300) _assetLabel,
            char(1)   _outputAssetRequired,
            bigint    _msr_timestamp
          );
 
            declare bigint _DeleteRecordQueueSize;
 
            getDeleteRecordQueueDetail(_DeleteRecordQueueSize);
 
            _DeleteRecordQueueSize = _DeleteRecordQueueSize + 1;
 
            updateDeleteRecordQueueDetail(_DeleteRecordQueueSize);
 
            newLocation=mod(_DeleteRecordQueueSize-1,10000);
 
            if checkIfVectorExists('deleteRecordQueue'||strip(put(newLocation,z4.))) = 0 then do;
              createVector('deleteRecordQueue'||strip(put(newLocation,z4.)),6);
              rc = st.setLong('deleteRecordQueue'||strip(put(newLocation,z4.)),0,0);
              rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),1,'action');
              rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),2,'assetID');
              rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),3,'assetType');
              rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),4,'assetLabel');
              rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),5,'outputAssetRequired');
              putVector('deleteRecordQueue'||strip(put(newLocation,z4.)));
              deleteVector('deleteRecordQueue'||strip(put(newLocation,z4.)));
            end;
 
            getVector ('deleteRecordQueue'||strip(put(newLocation,z4.)));
 
            rc = st.setLong('deleteRecordQueue'||strip(put(newLocation,z4.)),0,_msr_timestamp);
            rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),1,strip(_action));
            rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),2,strip(_assetID));
            rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),3,strip(_assetType));
            rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),4,strip(_assetLabel));
            rc = st.setString('deleteRecordQueue'||strip(put(newLocation,z4.)),5,strip(_outputAssetRequired));
 
            replaceVector ('deleteRecordQueue'||strip(put(newLocation,z4.)));
            deleteVector ('deleteRecordQueue'||strip(put(newLocation,z4.)));
 
            loggerString = 'NOTE: Added asset '||strip(_action)||' / '||strip(_assetID)||' / '||strip(_assetType)||' / '||strip(_assetLabel)||' / '||strip(_outputAssetRequired)||' / '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' to delete asset location deleteRecordQueue'||strip(put(newLocation,z4.))||'.';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method runUpdateAssets(
            char(50)  action,
            char(300) assetID,
            char(75)  assetType,
            char(300) assetLabel,
            char(1)   outputAssetRequired,
            bigint    msr_timestamp
          );
 
            /*** replace special characters ***/
            assetID=tranwrd(assetID,'|','^$*1*$^');
            assetType=tranwrd(assetType,'|','^$*1*$^');
 
            if msr_timestamp=0 or (msr_timestamp/1000000.0)=dhms(mdy(1,1,1970),0,0,0) then markTime=0;
            else markTime = msr_timestamp;
 
            if (msr_timestamp=0 or (msr_timestamp/1000000.0)=dhms(mdy(1,1,1970),0,0,0) ) then do;
 
              if action='add' then do;
 
                addAsset(assetID,assetType,assetLabel,outputAssetRequired,'Y');
 
              end;
              else do;
 
                /* do nothing - deletes cannot occur during initialization */
 
              end;
 
            end;
            else do;
 
              if action='delete' then do;
                queueDeleteUpdate('delete',assetID,assetType,assetLabel,outputAssetRequired,markTime);
              end;
              else do;
                queueAssetUpdate(action,assetID,assetType,assetLabel,outputAssetRequired,markTime);
              end;
 
            end;
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="updateHierarchiesModule" language="ds2" func-names="runUpdateHierarchies">
      <code><![CDATA[ds2_options sas;
 
        package updateHierarchiesPackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep cnt cnt2;
          declare integer numHierarchies foundHierarchy;
          declare integer numAssetTypes numAssets;
          declare integer numParents foundParent numChildren foundChild;
          declare char(75) thisAssetType;
          declare char(300) thisAssetID;
          declare bigint    markTime;
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
          declare integer   numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method addConnection (char(25) hi, char(300) pdi, char(3) lnkdir, char(300) cdi);
 
            /*** retrieve hierarchyList vector and check whether hierarchyName is already in list ***/
            numHierarchies=0;
            foundHierarchy=0;
 
            getVector ('hierarchyList');
 
            numHierarchies=st.getInt('hierarchyList',0);
            foundHierarchy=0;
            do cnt=1 to numHierarchies;
              if strip(st.getString('hierarchyList',cnt))=strip(hi) then foundHierarchy=1;
            end;
            deleteVector ('hierarchyList');
 
            if foundHierarchy=1 then do;
 
              if checkIfVectorExists('asset|'||strip(pdi)) = 1 and
                 checkIfVectorExists('asset|'||strip(cdi)) = 1 then do;
 
                /*** add the parent to childs list and increment the counter ***/
                /*** add the child to parents list and increment the counter ***/
                numParents=0;
                foundParent=0;
                getVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
                numParents=st.getInt('asset|'||strip(cdi)||'|parents|'||strip(hi),0);
                foundParent=0;
                do cnt=1 to numParents;
                  if strip(st.getString('asset|'||strip(cdi)||'|parents|'||strip(hi),cnt))=strip(pdi) then foundParent=1;
                end;
 
                numChildren=0;
                foundChild=0;
                getVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
                numChildren=st.getInt('asset|'||strip(pdi)||'|children|'||strip(hi),0);
                foundChild=0;
                do cnt=1 to numChildren;
                  if strip(st.getString('asset|'||strip(pdi)||'|children|'||strip(hi),cnt))=strip(cdi) then foundChild=1;
                end;
 
                if foundParent=0 and lnkdir in ('<--','<->') then do;
 
                  numParents=numParents+1;
                  rc = st.setInt('asset|'||strip(cdi)||'|parents|'||strip(hi),0,numParents);
                  rc = st.setString('asset|'||strip(cdi)||'|parents|'||strip(hi),numParents,strip(pdi));
                  replaceVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
 
                end;
                deleteVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
 
                if foundParent=1 and lnkdir in ('-->') then do;
 
                  removeItem ('asset|'||strip(cdi)||'|parents|'||strip(hi),strip(pdi));
 
                end;
 
                if foundChild=0 and lnkdir in ('-->','<->') then do;
 
                  numChildren=numChildren+1;
                  rc = st.setInt('asset|'||strip(pdi)||'|children|'||strip(hi),0,numChildren);
                  rc = st.setString('asset|'||strip(pdi)||'|children|'||strip(hi),numChildren,strip(cdi));
                  replaceVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
 
                end;
                deleteVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
 
                if foundChild=1 and lnkdir in ('<--') then do;
 
                  removeItem ('asset|'||strip(pdi)||'|children|'||strip(hi),strip(cdi));
 
                end;
 
                loggerString = 'NOTE: Added/updated connection in hierarchy '||strip(hi)||' between parent '||strip(pdi)||' and child '||strip(cdi);
                writeTo.log('i', loggerString);
 
              end;
              else do;
 
                loggerString = 'ERROR: Connection was not added in hierarchy '||strip(hi)||' between parent '||strip(pdi)||' and child '||strip(cdi)||'. Parent or child does not exist.';
                writeTo.log('i', loggerString);
 
              end;
 
            end;
            else do;
 
              loggerString = 'ERROR: Connection was not added in hierarchy '||strip(hi)||' between parent '||strip(pdi)||' and child '||strip(cdi)||'. Hierarchy '||strip(hi)||' does not exist.';
              writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method getConnRecordQueueDetail(in_out bigint _connRecordQueueSize);
 
            _connRecordQueueSize=0;
 
            getVector ('connRecordQueue');
 
            _connRecordQueueSize=st.getLong('connRecordQueue',0);
 
            deleteVector ('connRecordQueue');
 
          end;
 
          method updateConnRecordQueueDetail(bigint _connRecordQueueSize);
 
            getVector ('connRecordQueue');
 
            rc = st.setLong('connRecordQueue',0,_connRecordQueueSize);
 
            replaceVector ('connRecordQueue');
            deleteVector ('connRecordQueue');
 
          end;
 
          method queueConnectionUpdate(
            char(50)  _action,
            char(25)  _hierarchyName,
            char(300) _parentAssetID,
            char(3)   _direction,
            char(300) _childAssetID,
            bigint    _msr_timestamp
          );
 
            declare bigint _ConnRecordQueueSize;
 
            getConnRecordQueueDetail(_ConnRecordQueueSize);
 
            _ConnRecordQueueSize = _ConnRecordQueueSize + 1;
 
            updateConnRecordQueueDetail(_ConnRecordQueueSize);
 
            newLocation=mod(_ConnRecordQueueSize-1,10000);
 
            if checkIfVectorExists('connRecordQueue'||strip(put(newLocation,z4.))) = 0 then do;
              createVector('connRecordQueue'||strip(put(newLocation,z4.)),6);
              rc = st.setLong('connRecordQueue'||strip(put(newLocation,z4.)),0,0);
              rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),1,'action');
              rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),2,'hierarchyName');
              rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),3,'parentAssetID');
              rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),4,'direction');
              rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),5,'childAssetID');
              putVector('connRecordQueue'||strip(put(newLocation,z4.)));
              deleteVector('connRecordQueue'||strip(put(newLocation,z4.)));
            end;
 
            getVector ('connRecordQueue'||strip(put(newLocation,z4.)));
 
            rc = st.setLong('connRecordQueue'||strip(put(newLocation,z4.)),0,_msr_timestamp);
            rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),1,strip(_action));
            rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),2,strip(_hierarchyName));
            rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),3,strip(_parentAssetID));
            rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),4,strip(_direction));
            rc = st.setString('connRecordQueue'||strip(put(newLocation,z4.)),5,strip(_childAssetID));
 
            replaceVector ('connRecordQueue'||strip(put(newLocation,z4.)));
            deleteVector ('connRecordQueue'||strip(put(newLocation,z4.)));
 
            loggerString = 'NOTE: Added connection '||strip(_action)||' / '||strip(_hierarchyName)||' / '||strip(_parentAssetID)||' / '||strip(_childAssetID)||' / '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' to conn queue location connRecordQueue'||strip(put(newLocation,z4.))||'.';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method runUpdateHierarchies(
            char(50)  action,
            char(25)  hierarchyName,
            char(300) parentAssetID,
            char(3)   direction,
            char(300) childAssetID,
            bigint    msr_timestamp
          );
 
            /*** replace special characters ***/
            hierarchyName=tranwrd(hierarchyName,'|','^$*1*$^');
            parentAssetID=tranwrd(parentAssetID,'|','^$*1*$^');
            childAssetID=tranwrd(childAssetID,'|','^$*1*$^');
 
            if msr_timestamp=0 or (msr_timestamp/1000000.0)=dhms(mdy(1,1,1970),0,0,0) then markTime=0;
            else markTime = msr_timestamp;
 
            if (msr_timestamp=0 or (msr_timestamp/1000000.0)=dhms(mdy(1,1,1970),0,0,0) ) and action='add' then do;
 
              addConnection(hierarchyName,parentAssetID,direction,childAssetID);
 
            end;
            else do;
 
              queueConnectionUpdate(action,hierarchyName,parentAssetID,direction,childAssetID,markTime);
 
            end;
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="updateCurrentValueModule" language="ds2" func-names="runUpdateCurrentValue">
      <code><![CDATA[ds2_options sas;
 
        package updateCurrentValuePackage / overwrite = yes;
 
          declare double    rc rc1 rc1s rc2 rc2s rcsleep;
          declare integer   cnt cnt2 cpycnt cpycnt2;
 
          declare char(10)  crossedTrigger outputInProgress;
          declare char(1)   statusAB inactiveStatusAB;
          declare integer   rawRecordQueueSize rawRecordQueueNext rawRecordQueueLast;
          declare integer   triggerRecordQueueSize triggerRecordQueueNext triggerRecordQueueLast;
          declare bigint    createTriggerFirst createTriggerSecond createTriggerLast expectedTrigger;
          declare bigint    thisTrigger nextTriggerInQueue;
          declare char(75)  thisAssetType assignAssetType;
          declare char(25)  thisHierarchyName;
          declare char(300) thisAssetID;
          declare char(100) thisAttributeID;
          declare integer   numAssetTypes numAssets numRawAttributes numAttributes numHierarchies;
          declare integer   numOutputAssetTypes numOutputAssets;
          declare integer   foundAssetType foundAsset;
 
          declare char(20)  attributeType dataType dataFormat acceptableMinLogic acceptableMaxLogic;
          declare char(100) attributeLabel;
          declare integer   dataLength historyMaxEvents historyMaxTime retentionPeriod numHistory;
          declare double    acceptableMin acceptableMax;
 
          declare integer   numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          declare package   masstate st();
          declare package   logger writeTo();
          declare char(200) loggerString;
 
          declare char(20)  runStage;
          declare bigint    runFirstTime localRawRecordCount;
 
          declare bigint    createTriggerSecondTemp1 createTriggerSecondTemp2 createTriggerSecondInterval;
 
          method init();
 
            runStage='historical';
            runFirstTime=0;
            localRawRecordCount=0;
 
            loggerString = 'NOTE: Starting in historical replay mode.';
            writeTo.log('i', loggerString);
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method getAssetRecordQueueDetailCV(in_out bigint _assetRecordQueueSize);
 
            _assetRecordQueueSize=0;
 
            getVector ('assetRecordQueueCV');
 
            _assetRecordQueueSize=st.getLong('assetRecordQueueCV',0);
 
            deleteVector ('assetRecordQueueCV');
 
          end;
 
          method updateAssetRecordQueueDetailCV(bigint _assetRecordQueueSize);
 
            getVector ('assetRecordQueueCV');
 
            rc = st.setLong('assetRecordQueueCV',0,_assetRecordQueueSize);
 
            replaceVector ('assetRecordQueueCV');
            deleteVector ('assetRecordQueueCV');
 
          end;
 
          method queueAssetUpdateCV(
            char(50)  _action,
            char(300) _assetID,
            char(75)  _assetType,
            char(300) _assetLabel,
            char(1)   _outputAssetRequired,
            bigint    _msr_timestamp
          );
 
            declare bigint _AssetRecordQueueSize;
 
            getAssetRecordQueueDetailCV(_AssetRecordQueueSize);
 
            _AssetRecordQueueSize = _AssetRecordQueueSize + 1;
 
            updateAssetRecordQueueDetailCV(_AssetRecordQueueSize);
 
            newLocation=mod(_AssetRecordQueueSize-1,10000);
 
            if checkIfVectorExists('assetRecordQueueCV'||strip(put(newLocation,z4.))) = 0 then do;
              createVector('assetRecordQueueCV'||strip(put(newLocation,z4.)),6);
              rc = st.setLong('assetRecordQueueCV'||strip(put(newLocation,z4.)),0,0);
              rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),1,'action');
              rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),2,'assetID');
              rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),3,'assetType');
              rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),4,'assetLabel');
              rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),5,'outputAssetRequired');
              putVector('assetRecordQueueCV'||strip(put(newLocation,z4.)));
              deleteVector('assetRecordQueueCV'||strip(put(newLocation,z4.)));
            end;
 
            getVector ('assetRecordQueueCV'||strip(put(newLocation,z4.)));
 
            rc = st.setLong('assetRecordQueueCV'||strip(put(newLocation,z4.)),0,_msr_timestamp);
            rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),1,strip(_action));
            rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),2,strip(_assetID));
            rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),3,strip(_assetType));
            rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),4,strip(_assetLabel));
            rc = st.setString('assetRecordQueueCV'||strip(put(newLocation,z4.)),5,strip(_outputAssetRequired));
 
            replaceVector ('assetRecordQueueCV'||strip(put(newLocation,z4.)));
            deleteVector ('assetRecordQueueCV'||strip(put(newLocation,z4.)));
 
            loggerString = 'NOTE: Added asset '||strip(_action)||' / '||strip(_assetID)||' / '||strip(_assetType)||' / '||strip(_assetLabel)||' / '||strip(_outputAssetRequired)||' / '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' to asset location assetRecordQueueCV'||strip(put(newLocation,z4.))||'.';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method addAsset (char(300) di, char(75) dt, char(300) dl, char(1) oar, char(1) addToAList);
 
            /*** retrieve assetTypeList vector and check whether assetType is already in list ***/
            numAssetTypes=0;
            foundAssetType=0;
 
            getVector ('assetTypeList');
 
            numAssetTypes=st.getInt('assetTypeList',0);
            foundAssetType=0;
            do cnt=1 to numAssetTypes;
              if strip(st.getString('assetTypeList',cnt))=strip(dt) then foundAssetType=1;
            end;
            deleteVector ('assetTypeList');
 
            if foundAssetType=1 then do;
 
              /*** retrieve assetList vector and check whether assetID is already in list ***/
              numAssets=0;
              foundAsset=0;
 
              getVector ('assetType|'||strip(dt)||'|assetList');
 
              numAssets=st.getInt('assetType|'||strip(dt)||'|assetList',0);
              foundAsset=0;
              do cnt=1 to numAssets;
                if strip(st.getString('assetType|'||strip(dt)||'|assetList',cnt))=strip(di) then foundAsset=1;
              end;
 
              numOutputAssets=0;
              getVector ('assetType|'||strip(dt)||'|outputAssetList');
              numOutputAssets=st.getInt('assetType|'||strip(dt)||'|outputAssetList',0);
 
              if numAssets = 10000 then do;
 
                loggerString = 'ERROR: assetID '||strip(di)||' could not be added - number of assets at max.';
                writeTo.log('i', loggerString);
 
              end;
              else if foundAsset=0 then do;
 
                loggerString = 'NOTE: Adding assetID '||strip(di)||' of assetType '||strip(dt)||' (current value)';
                writeTo.log('i', loggerString);
 
                /*** retrieve the attributes hash ***/
                numAttributes=0;
 
                getVector ('assetType|'||strip(dt)||'|attributeList');
 
                numAttributes=st.getInt('assetType|'||strip(dt)||'|attributeList',0);
 
                /*** make a copy of the attribute list and attach to the asset for easier navigation ***/
                createVector ('asset|'||strip(di)||'|attributeList',1001);
                rc = st.setInt('asset|'||strip(di)||'|attributeList',0,numAttributes);
 
                /*** iterate through the attributeList hash and initiate the assetID|attributeID|currentValueA,currentValueB,history hashes ***/
                do cnt=1 to numAttributes;
 
                  /*** choose a attributeID to process ***/
                  thisAttributeID=st.getString('assetType|'||strip(dt)||'|attributeList',cnt);
                  rc = st.setString('asset|'||strip(di)||'|attributeList',cnt,strip(thisAttributeID));
 
                  /*** pull information about the attribute ***/
                  attributeType      = '';
                  attributeLabel     = '';
                  dataType           = '';
                  dataLength         = .;
                  dataFormat         = '';
                  retentionPeriod     = .;
                  acceptableMin      = .;
                  acceptableMinLogic = '';
                  acceptableMax      = .;
                  acceptableMaxLogic = '';
                  historyMaxEvents   = .;
                  historyMaxTime     = .;
                  numHistory         = 0;
 
                  getVector ('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID));
 
                  attributeType      = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),0);
                  attributeLabel     = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),1);
                  dataType           = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),2);
                  dataLength         = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),3);
                  dataFormat         = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),4);
                  retentionPeriod     = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),5);
                  acceptableMin      = st.getDouble('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),6);
                  acceptableMinLogic = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),7);
                  acceptableMax      = st.getDouble('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),8);
                  acceptableMaxLogic = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),9);
 
                  historyMaxEvents   = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),11);
                  historyMaxTime     = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),12);
 
                  numHistory = int( (historyMaxTime * 1.0) / (@historyInterval@ * 1.0) );
 
                  deleteVector ('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID));
 
                  /*** initiate currentValue ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,'');
                  end;
 
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
 
                  /*** initiate lastValue ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,'');
                  end;
 
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
 
                  /*** initiate currentValueStorageA ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',3,'');
                  end;
 
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA');
 
                  /*** initiate currentValueStorageB ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',3,'');
                  end;
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB');
 
                  /*** initiate the history vector ***/
                  if numHistory gt 0 then do;
                    createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',4+(numHistory*2));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',0,strip(dataType));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',1,'');
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',2,numHistory);
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',3,0);
 
                    putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history');
                    deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history');
                  end;
 
                  /*** initiate the events vector ***/
                  if historyMaxEvents gt 0 then do;
                    createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',4+(historyMaxEvents*2));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',0,strip(dataType));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',1,'');
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',2,historyMaxEvents);
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',3,0);
 
                    putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events');
                    deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events');
                  end;
 
                  loggerString = 'NOTE: ...added attributeID '||strip(thisAttributeID);
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                end;
 
                /*** now store the copy of the attribute list attached to the asset for easier navigation ***/
                putVector ('asset|'||strip(di)||'|attributeList');
                deleteVector ('asset|'||strip(di)||'|attributeList');
 
                /*** retrieve the attributes hash ***/
                numRawAttributes=0;
 
                getVector ('assetType|'||strip(dt)||'|rawAttributeList');
 
                numRawAttributes=st.getInt('assetType|'||strip(dt)||'|rawAttributeList',0);
 
                /*** make a copy of the attribute list and attach to the asset for easier navigation ***/
                createVector ('asset|'||strip(di)||'|rawAttributeList',1001);
                rc = st.setInt('asset|'||strip(di)||'|rawAttributeList',0,numRawAttributes);
 
                /*** iterate through the attributeList hash and initiate the assetID|attributeID|currentValueA,currentValueB,history hashes ***/
                do cnt=1 to numRawAttributes;
 
                  /*** choose a attributeID to process ***/
                  thisAttributeID=st.getString('assetType|'||strip(dt)||'|rawAttributeList',cnt);
                  rc = st.setString('asset|'||strip(di)||'|rawAttributeList',cnt,strip(thisAttributeID));
 
                end;
 
                /*** now store the copy of the raw attribute list attached to the asset for easier navigation ***/
                putVector ('asset|'||strip(di)||'|rawAttributeList');
                deleteVector ('asset|'||strip(di)||'|rawAttributeList');
 
                /*** retrieve the hierarchies hash ***/
                numHierarchies=0;
 
                getVector ('hierarchyList');
 
                numHierarchies=st.getInt('hierarchyList',0);
 
                /*** iterate through the hierarchies hash and initiate assetID|parents|hierarchyName,children|hierarchyName hashes with no parents-children ***/
                do cnt=1 to numHierarchies;
 
                  /*** choose a hierarchyName to process ***/
                  thisHierarchyName=st.getString('hierarchyList',cnt);
 
                  /*** initiate the parents hash ***/
                  createVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),maxNumberParentsChildrenPlus1.);
                  rc = st.setInt('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),0,0);
                  putVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
                  deleteVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
 
                  /*** initiate the children hash ***/
                  createVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),maxNumberParentsChildrenPlus1.);
                  rc = st.setInt('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),0,0);
                  putVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
                  deleteVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
 
                  loggerString = 'NOTE: ...added parent and children vectors for hierarchy '||strip(thisHierarchyName);
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                end;
                deleteVector ('hierarchyList');
 
                /*** initiate assetID hash with info provided ***/
                createVector ('asset|'||strip(di),3);
                rc = st.setString('asset|'||strip(di),0,strip(dt));
                rc = st.setString('asset|'||strip(di),1,strip(dl));
                putVector ('asset|'||strip(di));
                deleteVector ('asset|'||strip(di));
 
                if addToAList='Y' then do;
 
                  /*** add assetID to assetList hash ***/
                  numAssets=numAssets+1;
                  rc = st.setInt('assetType|'||strip(dt)||'|assetList',0,numAssets);
                  rc = st.setString('assetType|'||strip(dt)||'|assetList',numAssets,strip(di));
                  replaceVector ('assetType|'||strip(dt)||'|assetList');
 
                  if oar='Y' then do;
 
                    numOutputAssets=numOutputAssets+1;
                    rc = st.setInt('assetType|'||strip(dt)||'|outputAssetList',0,numOutputAssets);
                    rc = st.setString('assetType|'||strip(dt)||'|outputAssetList',numOutputAssets,strip(di));
                    replaceVector ('assetType|'||strip(dt)||'|outputAssetList');
 
                  end;
 
                end;
 
                loggerString = 'NOTE: ...complete';
                if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
              end;
              else do;
 
                loggerString = 'WARNING: assetID '||strip(di)||' already exists.';
                writeTo.log('i', loggerString);
 
              end;
              deleteVector ('assetType|'||strip(dt)||'|assetList');
              deleteVector ('assetType|'||strip(dt)||'|outputAssetList');
 
            end;
            else do;
 
              loggerString = 'ERROR: assetID '||strip(di)||' was not added. assetType '||strip(dt)||' does not exist.';
              writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method getABStatus(in_out char _statusAB, in_out char _inactiveStatusAB);
 
            /*** obtain current AB status ***/
            _statusAB='-';
            getVector ('statusAB');
            _statusAB=st.getString('statusAB',0);
            deleteVector ('statusAB');
 
            if      _statusAB='A' then _inactiveStatusAB='B';
            else if _statusAB='B' then _inactiveStatusAB='A';
            else                       _inactiveStatusAB='-';
 
          end;
 
          method flipABStatus(in_out char _statusAB, in_out char _inactiveStatusAB);
 
            declare char(1) tstatusAB;
 
            /*** switch AB status so new sensors update the other while processing is occurring ***/
            /*** obtain current AB status ***/
            tstatusAB='-';
            getVector ('statusAB');
            tstatusAB=st.getString('statusAB',0);
 
            /*** update the status ***/
            if      tstatusAB='A' then _statusAB='B';
            else if tstatusAB='B' then _statusAB='A';
            else do;
              _statusAB='-';
              loggerString = 'WARNING: Current AB status missing - attribute will not be written to in-memory data model.';
              writeTo.log('i', loggerString);
            end;
 
            loggerString = 'NOTE: Switching AB status from '||strip(tstatusAB)||' to '||strip(_statusAB)||'.';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            rc = st.setString('statusAB',0,strip(_statusAB));
 
            replaceVector ('statusAB');
            deleteVector ('statusAB');
 
            if      _statusAB='A' then _inactiveStatusAB='B';
            else if _statusAB='B' then _inactiveStatusAB='A';
            else                       _inactiveStatusAB='-';
 
          end;
 
          method getOutputInProgress() returns char(10);
 
            declare char(10) _outputInProgress;
 
            _outputInProgress='false';
            getVector ('outputInProgress');
            _outputInProgress=st.getString('outputInProgress',0);
            deleteVector ('outputInProgress');
 
            return _outputInProgress;
 
          end;
 
          method setOutputInProgress(char(10) oipvalue);
 
            getVector ('outputInProgress');
            rc = st.setString('outputInProgress',0,strip(oipvalue));
            replaceVector ('outputInProgress');
            deleteVector ('outputInProgress');
 
          end;
 
          method getRawRecordQueueDetail(in_out integer _rawRecordQueueSize,
                                         in_out integer _rawRecordQueueNext,
                                         in_out integer _rawRecordQueueLast);
 
            _rawRecordQueueSize=0;
            _rawRecordQueueNext=0;
            _rawRecordQueueLast=0;
 
            getVector ('rawRecordQueue');
 
            _rawRecordQueueSize=st.getInt('rawRecordQueue',0);
            _rawRecordQueueNext=st.getInt('rawRecordQueue',1);
            _rawRecordQueueLast=st.getInt('rawRecordQueue',2);
 
            deleteVector ('rawRecordQueue');
 
          end;
 
          method updateRawRecordQueueDetail(integer _rawRecordQueueSize,
                                            integer _rawRecordQueueNext,
                                            integer _rawRecordQueueLast);
 
            getVector ('rawRecordQueue');
 
            rc = st.setInt('rawRecordQueue',0,_rawRecordQueueSize);
            rc = st.setInt('rawRecordQueue',1,_rawRecordQueueNext);
            rc = st.setInt('rawRecordQueue',2,_rawRecordQueueLast);
 
            replaceVector ('rawRecordQueue');
            deleteVector ('rawRecordQueue');
 
          end;
 
          method getTriggerRecordQueueDetail(in_out integer _triggerRecordQueueSize,
                                             in_out integer _triggerRecordQueueNext,
                                             in_out integer _triggerRecordQueueLast);
 
            _triggerRecordQueueSize=0;
            _triggerRecordQueueNext=0;
            _triggerRecordQueueLast=0;
 
            getVector ('triggerRecordQueue');
 
            _triggerRecordQueueSize=st.getInt('triggerRecordQueue',0);
            _triggerRecordQueueNext=st.getInt('triggerRecordQueue',1);
            _triggerRecordQueueLast=st.getInt('triggerRecordQueue',2);
 
            deleteVector ('triggerRecordQueue');
 
          end;
 
          method updateTriggerRecordQueueDetail(integer _triggerRecordQueueSize,
                                                integer _triggerRecordQueueNext,
                                                integer _triggerRecordQueueLast);
 
            getVector ('triggerRecordQueue');
 
            rc = st.setInt('triggerRecordQueue',0,_triggerRecordQueueSize);
            rc = st.setInt('triggerRecordQueue',1,_triggerRecordQueueNext);
            rc = st.setInt('triggerRecordQueue',2,_triggerRecordQueueLast);
 
            replaceVector ('triggerRecordQueue');
            deleteVector ('triggerRecordQueue');
 
          end;
 
          method getTriggerDetail(
                   bigint   _msr_timestamp,
            in_out char     _crossedTrigger,
            in_out bigint   _createTriggerFirst,
            in_out bigint   _createTriggerLast,
            in_out bigint   _expectedTrigger
          );
 
            declare bigint  _origNextTriggerTimestamp _origExpectedTrigger;
            declare bigint  _maxLookback;
            declare integer _maxHistoryPeriods;
 
            /*** retrieve the next trigger timestamp ***/
            _origExpectedTrigger=.;
            getVector ('expectedNextTimestamp');
            _origExpectedTrigger=st.getLong('expectedNextTimestamp',0);
 
            /*** determine whether the record crossed a trigger ***/
            /*** determine what triggers need to be created and store in variables ***/
            if _origExpectedTrigger=0 then do;
 
              /*** if this is the first sensor then set a first trigger time and store the attribute ***/
 
              _crossedTrigger    ='false';
              _createTriggerFirst=.;
              _createTriggerLast =.;
              _expectedTrigger   =int( (ceil((_msr_timestamp*1.0)/(@historyInterval@*1000000.0))*1.0)*(@historyInterval@*1000000.0) );
 
              rc = st.setLong('expectedNextTimestamp',0,_expectedTrigger);
 
              replaceVector ('expectedNextTimestamp');
              deleteVector ('expectedNextTimestamp');
 
              loggerString = 'NOTE: First output trigger will be '||strip(put((_expectedTrigger/1000000.0)-dhms(mdy(1,1,1970),0,0,0),datetime20.))||'.';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            end;
            else if _msr_timestamp gt _origExpectedTrigger then do;
 
              /*** if this is the first record on the other side of the trigger, then assign variables ***/
              _crossedTrigger ='true';
              _expectedTrigger   =int( (ceil((_msr_timestamp*1.0)/(@historyInterval@*1000000.0))*1.0)*(@historyInterval@*1000000.0) );
 
              _createTriggerFirst=_origExpectedTrigger;
              _createTriggerLast =int( (_expectedTrigger*1.0) - (@historyInterval@*1000000.0) );
 
              /*** we will fill in a max period depending on state, so limit that here if necessary ***/
              _maxHistoryPeriods=ceil( ( (_createTriggerLast*1.0) - (_createTriggerFirst*1.0) ) / (@historyInterval@*1000000.0));
              if _maxHistoryPeriods gt 99 then do;
                loggerString = 'WARNING: A data gap of longer than 100 periods occurred...';
                writeTo.log('i', loggerString);
                loggerString = 'WARNING: Data gap is from '||strip(put((_createTriggerFirst / 1000000.0)-dhms(mdy(1,1,1970),0,0,0),datetime20.))||' to '||strip(put((_createTriggerLast / 1000000.0)-dhms(mdy(1,1,1970),0,0,0),datetime20.));
                writeTo.log('i', loggerString);
              end;
 
              loggerString = 'NOTE: Output triggers will be generated from '||strip(put((_createTriggerFirst/1000000.0)-dhms(mdy(1,1,1970),0,0,0),datetime20.))||
                             ' through '||strip(put((_createTriggerLast/1000000.0)-dhms(mdy(1,1,1970),0,0,0),datetime20.))||'.';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
              loggerString = 'NOTE: The expected next trigger will be '||strip(put((_expectedTrigger/1000000.0)-dhms(mdy(1,1,1970),0,0,0),datetime20.))||'.';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
              /*** update the next timestamp ***/
              rc = st.setLong('expectedNextTimestamp',0,_expectedTrigger);
              replaceVector ('expectedNextTimestamp');
              deleteVector ('expectedNextTimestamp');
 
            end;
            else do;
 
              /*** if this sensor did not cross a trigger ***/
 
              _crossedTrigger       ='false';
              _createTriggerFirst=.;
              _createTriggerLast =.;
              _expectedTrigger   =_origExpectedTrigger;
 
              loggerString = 'NOTE: No threshold was crossed - the expected next trigger is '||
                             strip(put((_expectedTrigger/1000000.0)-dhms(mdy(1,1,1970),0,0,0),datetime20.))||'.';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
              deleteVector ('expectedNextTimestamp');
 
            end;
 
          end;
 
          method updateCurrentValue(
            bigint    _msr_timestamp,
            char(300) _assetID,
            char(100) _attributeID,
            char(100) _value
          );
 
            declare char(1)  _StatusAB _InactiveStatusAB;
            declare char(75) _assetType assignAssetType;
            declare char(20)  _attributeType _dataType _dataFormat acceptableMinLogic _acceptableMaxLogic;
            declare char(100) _attributeLabel;
            declare integer   _dataLength _historyMaxEvents _historyMaxTime _retentionPeriod _numHistory valueIsMissing;
            declare double    _acceptableMin _acceptableMax;
            declare integer  _baseHistoryLocation _nextHistoryLocation _maxHistoryLength;
            declare integer  foundAttribute numAttributes cntChkAtt;
            declare double   _tempValue;
 
            localRawRecordCount = localRawRecordCount + 1;
 
            /* CHECK IF THE ASSET EXISTS AND IF NOT THEN CREATE IF OBVIOUS */
            if checkIfVectorExists('asset|'||strip(_assetID)) = 1 then do;
 
              /* IF THE ASSET EXISTS THEN CONTINUE ON */
 
            end;
            else if 'N'='Y' then do;
 
              assignAssetType='NONE';
 
              /* ITERATE ACROSS ASSET TYPES TO DETERMINE IF THIS ATTRIBUTE EXISTS FOR ONLY ONE ASSET TYPE */
              numAssetTypes=0;
              getVector ('assetTypeList');
              numAssetTypes=st.getInt('assetTypeList',0);
              do cnt=1 to numAssetTypes;
                thisAssetType = strip(st.getString('assetTypeList',cnt));
 
                /* ITERATE ACROSS RAW ATTRIBUTES FOR THAT ASSET TYPE */
                numRawAttributes=0;
                getVector ('assetType|'||strip(thisAssetType)||'|rawAttributeList');
                numRawAttributes=st.getInt('assetType|'||strip(thisAssetType)||'|rawAttributeList',0);
 
                do cnt2=1 to numRawAttributes;
                  thisAttributeID=st.getString('assetType|'||strip(thisAssetType)||'|rawAttributeList',cnt2);
 
                  if strip(_attributeID) = strip(thisAttributeID) and strip(assignAssetType)='NONE' then assignAssetType=strip(thisAssetType);
                  else if strip(_attributeID) = strip(thisAttributeID) and strip(assignAssetType) ne 'NONE' then assignAssetType='MULTIPLE';
                end;
                deleteVector ('assetType|'||strip(thisAssetType)||'|rawAttributeList');
 
              end;
              deleteVector ('assetTypeList');
 
              if assignAssetType ne 'NONE' and assignAssetType ne 'MULTIPLE' then do;
 
                /* create an asset of that type */
                addAsset(strip(_assetID),strip(assignAssetType),strip(_assetID),'N','N');
                queueAssetUpdateCV('add',_assetID,assignAssetType,_assetID,'Y',_msr_timestamp);
 
              end;
              else do;
 
                loggerString = 'NOTE: AssetID not defined for '||strip(_assetID)||' and unclear which asset type to assign it to based on attribute.';
                if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
              end;
 
            end;
            else do;
 
                loggerString = 'NOTE: AssetID not defined for '||strip(_assetID)||' - implicit adds not permitted per project settings.';
                if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            end;
 
            /* if the attribute exists, then process the update */
            if checkIfVectorExists('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValue') = 1 and
               strip(_value) not in ('','.') then do;
 
              getABStatus(_StatusAB,_InactiveStatusAB);
 
              /*** get the asset type for the asset ***/
              _assetType = '';
 
              getVector ('asset|'||strip(_assetID));
 
              _assetType  = st.getString('asset|'||strip(_assetID),0);
              _assetLabel = st.getString('asset|'||strip(_assetID),1);
 
              deleteVector ('asset|'||strip(_assetID));
 
              /*** pull information about the attribute ***/
              _attributeType      = '';
              _attributeLabel     = '';
              _dataType           = '';
              _dataLength         = .;
              _dataFormat         = '';
              _retentionPeriod     = .;
              _acceptableMin      = .;
              _acceptableMinLogic = '';
              _acceptableMax      = .;
              _acceptableMaxLogic = '';
              _historyMaxEvents   = .;
              _historyMaxTime     = .;
              _numHistory         = 0;
 
              getVector ('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID));
 
              _attributeType      = st.getString('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),0);
              _attributeLabel     = st.getString('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),1);
              _dataType           = st.getString('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),2);
              _dataLength         = st.getInt('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),3);
              _dataFormat         = st.getString('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),4);
              _retentionPeriod     = st.getInt('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),5);
              _acceptableMin      = st.getDouble('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),6);
              _acceptableMinLogic = st.getString('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),7);
              _acceptableMax      = st.getDouble('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),8);
              _acceptableMaxLogic = st.getString('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),9);
 
              _historyMaxEvents   = st.getInt('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),11);
              _historyMaxTime     = st.getInt('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID),12);
 
              _numHistory = int( (_historyMaxTime * 1.0) / (@historyInterval@ * 1.0) );
 
              deleteVector ('assetType|'||strip(_assetType)||'|attribute|'||strip(_attributeID));
 
              /*** retrieve and update appropriate current value storage vector ***/
              getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValueStorage'||strip(_StatusAB));
 
              valueIsMissing=0;
              _tempValue=.;
              if _dataType='double' then do;
                _tempValue=inputn(strip(_value),'24.');
                if _acceptableMin ne -999999999999 then do;
                  if _tempValue gt -999999999999 and _tempValue lt _acceptableMin then do;
                    if _acceptableMinLogic='missing' then do;
                      _tempValue=.;
                      valueIsMissing=1;
                      loggerString = 'NOTE: Overrode raw value for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' value '||strip(_value)||' to be '||strip(put(_tempValue,24.))||' with timestamp '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||'.';
                      if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                    end;
                    else if _acceptableMinLogic='limit' then do;
                      _tempValue=_acceptableMin;
                      loggerString = 'NOTE: Overrode raw value for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' value '||strip(_value)||' to be '||strip(put(_tempValue,24.))||' with timestamp '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||'.';
                      if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                    end;
                  end;
                end;
                if _acceptableMax ne 999999999999 then do;
                  if _tempValue gt -999999999999 and _tempValue gt _acceptableMax then do;
                    if _acceptableMaxLogic='missing' then do;
                      _tempValue=.;
                      valueIsMissing=1;
                      loggerString = 'NOTE: Overrode raw value for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' value '||strip(_value)||' to be '||strip(put(_tempValue,24.))||' with timestamp '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||'.';
                      if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                    end;
                    else if _acceptableMaxLogic='limit' then do;
                      _tempValue=_acceptableMax;
                      loggerString = 'NOTE: Overrode raw value for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' value '||strip(_value)||' to be '||strip(put(_tempValue,24.))||' with timestamp '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||'.';
                      if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                    end;
                  end;
                end;
                if valueIsMissing=0 then do;
                  rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValueStorage'||strip(_StatusAB),2,_msr_timestamp);
                  rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValueStorage'||strip(_StatusAB),3,_tempValue);
                  loggerString = 'NOTE: Updated currentValueStorage'||strip(_StatusAB)||' for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' to be '||strip(put(_tempValue,24.))||' with timestamp '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||'.';
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                end;
              end;
              else do;
                rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValueStorage'||strip(_StatusAB),2,_msr_timestamp);
                rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValueStorage'||strip(_StatusAB),3,strip(_value));
                loggerString = 'CHKTHIS!!! NOTE: Updated currentValueStorage'||strip(_StatusAB)||' for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' to be '||strip(_value)||' with timestamp '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||'.';
                if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
              end;
              replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValueStorage'||strip(_StatusAB));
              deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|currentValueStorage'||strip(_StatusAB));
 
              /*** if _historyMaxEvents gt 0 then retrieve and update the events vector ***/
              if _historyMaxEvents gt 0 and not (_dataType='double' and valueIsMissing=1) then do;
 
                getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events');
 
                _maxHistoryLength    = st.getInt('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',2);
                _baseHistoryLocation = st.getInt('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',3);
 
                if _baseHistoryLocation=. then _nextHistoryLocation=1;
                else if _baseHistoryLocation=_maxHistoryLength then _nextHistoryLocation=1;
                else _nextHistoryLocation=_baseHistoryLocation+1;
 
                if _dataType='double' then do;
                  rc = st.setInt('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',3,_nextHistoryLocation);
                  rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',2+int(_nextHistoryLocation*2),_msr_timestamp);
                  rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',int(_nextHistoryLocation*2)+3,_tempValue);
                  loggerString = 'NOTE: Updated events for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' to be '||strip(put(_tempValue,24.))||'.';
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                end;
                else do;
                  rc = st.setInt('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',3,_nextHistoryLocation);
                  rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',2+int(_nextHistoryLocation*2),_msr_timestamp);
                  rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events',int(_nextHistoryLocation*2)+3,strip(_value));
                  loggerString = 'NOTE: Updated events for assetID '||strip(_assetID)||' attributeID '||strip(_attributeID)||' to be '||strip(_value)||'.';
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                end;
 
                replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events');
                deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(_attributeID)||'|events');
 
              end;
 
            end;
 
          end;
 
          method addCurrentValueToQueue(
            bigint    _msr_timestamp,
            char(300) _assetID,
            char(100) _attributeID,
            char(100) _value
          );
 
            declare integer _RawRecordQueueSize _RawRecordQueueNext _RawRecordQueueLast;
 
            getRawRecordQueueDetail(_RawRecordQueueSize,
                                    _RawRecordQueueNext,
                                    _RawRecordQueueLast);
 
            if _RawRecordQueueSize=999999 then do;
 
              loggerString = 'ERROR: Raw queue is full. Data loss will occur.';
              writeTo.log('i', loggerString);
 
            end;
            else do;
 
              if _RawRecordQueueSize=0 then do;
 
                _RawRecordQueueSize = 1;
                _RawRecordQueueNext = 1;
                _RawRecordQueueLast = 1;
 
              end;
              else do;
 
                _RawRecordQueueSize = _RawRecordQueueSize + 1;
 
                _RawRecordQueueLast = _RawRecordQueueLast + 1;
                if _RawRecordQueueLast>999999 then _RawRecordQueueLast=1;
 
              end;
 
              updateRawRecordQueueDetail(_RawRecordQueueSize,
                                         _RawRecordQueueNext,
                                         _RawRecordQueueLast);
 
              if checkIfVectorExists('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.))) = 0 then do;
                createVector('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),4);
                rc = st.setLong('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),0,0);
                rc = st.setString('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),1,'assetID');
                rc = st.setString('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),2,'attributeID');
                rc = st.setString('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),3,'value');
                putVector('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)));
                deleteVector('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)));
              end;
 
              getVector ('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)));
 
              rc = st.setLong('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),0,_msr_timestamp);
              rc = st.setString('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),1,strip(_assetID));
              rc = st.setString('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),2,strip(_attributeID));
              rc = st.setString('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)),3,strip(_value));
 
              replaceVector ('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)));
              deleteVector ('rawRecordQueue'||strip(put(_RawRecordQueueLast,z6.)));
 
              loggerString = 'NOTE: Added '||strip(_assetID)||' / '||strip(_attributeID)||' / '||strip(put((_msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' / '||strip(_value)||' to raw queue location '||strip(put(_RawRecordQueueLast,z6.))||'.';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method addTriggersToQueue(
            bigint    _createTriggerFirst,
            bigint    _createTriggerLast
          );
 
            declare integer _TriggerRecordQueueSize _TriggerRecordQueueNext _TriggerRecordQueueLast;
            declare bigint i intrvlTemp1 intrvlTemp2 intrvlSize;
 
            intrvlTemp1 = @historyInterval@;
            intrvlTemp2 = 1000000;
            intrvlSize = intrvlTemp1 * intrvlTemp2;
 
            do i = _createTriggerFirst to _createTriggerLast by intrvlSize;
 
              getTriggerRecordQueueDetail(_TriggerRecordQueueSize,
                                          _TriggerRecordQueueNext,
                                          _TriggerRecordQueueLast);
 
              if _TriggerRecordQueueSize=9999 then do;
 
                loggerString = 'ERROR: Trigger queue is full. Unexpected results may occur.';
                writeTo.log('i', loggerString);
 
              end;
              else do;
 
                if _TriggerRecordQueueSize=0 then do;
 
                  _TriggerRecordQueueSize = 1;
                  _TriggerRecordQueueNext = 1;
                  _TriggerRecordQueueLast = 1;
 
                end;
                else do;
 
                  _TriggerRecordQueueSize = _TriggerRecordQueueSize + 1;
 
                  _TriggerRecordQueueLast = _TriggerRecordQueueLast + 1;
                  if _TriggerRecordQueueLast>9999 then _TriggerRecordQueueLast=1;
 
                end;
 
                updateTriggerRecordQueueDetail(_TriggerRecordQueueSize,
                                               _TriggerRecordQueueNext,
                                               _TriggerRecordQueueLast);
 
                if checkIfVectorExists('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.))) = 0 then do;
                  createVector('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)),1);
                  rc = st.setLong('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)),0,0);
                  putVector('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)));
                  deleteVector('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)));
                end;
 
                getVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)));
 
                rc = st.setLong('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)),0,i);
 
                replaceVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)));
                deleteVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueLast,z4.)));
 
                loggerString = 'NOTE: Added '||strip(put((i/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' to trigger queue location '||strip(put(_TriggerRecordQueueLast,z4.))||'.';
                if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
              end;
 
            end;
 
          end;
 
          method checkNextTriggerInQueue() returns bigint;
 
            declare integer _TriggerRecordQueueSize _TriggerRecordQueueNext _TriggerRecordQueueLast;
            declare bigint  _NextTriggerInQueue;
 
            getTriggerRecordQueueDetail(_TriggerRecordQueueSize,
                                        _TriggerRecordQueueNext,
                                        _TriggerRecordQueueLast);
 
            if _TriggerRecordQueueSize=0 then do;
 
              _NextTriggerInQueue=.;
 
            end;
            else do;
 
              _NextTriggerInQueue=.;
              getVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueNext,z4.)));
              _NextTriggerInQueue = st.getLong('triggerRecordQueue'||strip(put(_TriggerRecordQueueNext,z4.)),0);
              deleteVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueNext,z4.)));
 
            end;
 
            return _NextTriggerInQueue;
 
          end;
 
          method getTriggerFromQueue(in_out bigint _ThisTrigger);
 
            declare integer _TriggerRecordQueueSize _TriggerRecordQueueNext _TriggerRecordQueueLast;
 
            getTriggerRecordQueueDetail(_TriggerRecordQueueSize,
                                        _TriggerRecordQueueNext,
                                        _TriggerRecordQueueLast);
 
            _ThisTrigger=.;
            getVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueNext,z4.)));
            _ThisTrigger = st.getLong('triggerRecordQueue'||strip(put(_TriggerRecordQueueNext,z4.)),0);
            deleteVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueNext,z4.)));
            removeVector ('triggerRecordQueue'||strip(put(_TriggerRecordQueueNext,z4.)));
 
            _TriggerRecordQueueSize = _TriggerRecordQueueSize - 1;
 
            if _TriggerRecordQueueSize=0 then do;
 
              _TriggerRecordQueueNext=0;
              _TriggerRecordQueueLast=0;
 
            end;
            else do;
 
              _TriggerRecordQueueNext = _TriggerRecordQueueNext + 1;
              if _TriggerRecordQueueNext>9999 then _TriggerRecordQueueNext=1;
 
            end;
 
            updateTriggerRecordQueueDetail(_TriggerRecordQueueSize,
                                           _TriggerRecordQueueNext,
                                           _TriggerRecordQueueLast);
 
            loggerString = 'NOTE: getTriggerFromQueue '||strip(put((_ThisTrigger/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
          end;
 
          method processRawQueueThrough(
            bigint _NextTriggerInQueue
          );
 
            declare integer _RawRecordQueueSize _RawRecordQueueNext _RawRecordQueueLast;
            declare char(300) _AssetID;
            declare char(100) _AttributeID;
            declare bigint    _Msr_timestamp;
            declare char(100) _Value;
            declare integer   i thisloc;
 
            getRawRecordQueueDetail(_RawRecordQueueSize,
                                    _RawRecordQueueNext,
                                    _RawRecordQueueLast);
 
            if _RawRecordQueueSize gt 0 then do;
 
              i=_RawRecordQueueNext;
              do while (i le (_RawRecordQueueNext+_RawRecordQueueSize-1));
 
                thisloc = i;
                if thisloc gt 999999 then thisloc = thisloc - 999999;
 
                getVector ('rawRecordQueue'||strip(put(thisloc,z6.)));
 
                _Msr_timestamp = st.getLong('rawRecordQueue'||strip(put(thisloc,z6.)),0);
                _AssetID      = strip(st.getString('rawRecordQueue'||strip(put(thisloc,z6.)),1));
                _AttributeID = strip(st.getString('rawRecordQueue'||strip(put(thisloc,z6.)),2));
                _Value         = strip(st.getString('rawRecordQueue'||strip(put(thisloc,z6.)),3));
 
                deleteVector ('rawRecordQueue'||strip(put(thisloc,z6.)));
 
                if _Msr_timestamp le _NextTriggerInQueue or _NextTriggerInQueue=. then do;
 
                  removeVector ('rawRecordQueue'||strip(put(thisloc,z6.)));
 
                  updateCurrentValue(
                    _Msr_timestamp,
                    _AssetID,
                    _AttributeID,
                    _Value
                  );
 
                  _RawRecordQueueSize = _RawRecordQueueSize - 1;
 
                  if _RawRecordQueueSize=0 then do;
 
                    _RawRecordQueueNext=0;
                    _RawRecordQueueLast=0;
 
                  end;
                  else do;
 
                    _RawRecordQueueNext = _RawRecordQueueNext + 1;
                    if _RawRecordQueueNext>999999 then _RawRecordQueueNext=1;
 
                  end;
 
                  updateRawRecordQueueDetail(_RawRecordQueueSize,
                                             _RawRecordQueueNext,
                                             _RawRecordQueueLast);
 
                end;
                else do;
 
                  /* force to exit loop since records are ordered in ascending time order */
                  i = 9999999;
 
                end;
 
                i = i + 1;
 
              end;
 
            end;
 
          end;
 
          method runUpdateCurrentValue(
            bigint    key1,
            bigint    msr_timestamp,
            char(300) assetID,
            char(100) attributeID,
            char(100) value,
            in_out    bigint triggerTimestamp,
            in_out    bigint rawRecordCount,
            in_out    bigint printRawQueueCount,
            in_out    bigint printTriggerQueueCount,
            in_out    char  consolidateStatusAB,
            in_out    char _outOpcode
          );
 
            /*** replace special characters ***/
            assetID=tranwrd(assetID,'|','^$*1*$^');
            attributeID=tranwrd(attributeID,'|','^$*1*$^');
 
            if msr_timestamp=0 or (msr_timestamp/1000000.0)=dhms(mdy(1,1,1970),0,0,0) then do;
            /* if its a static attribute - these come in with a timestamp of 0 */
 
              updateCurrentValue(msr_timestamp,assetID,attributeID,value);
              _outOpcode='delete';
 
            end;
            else if strip(attributeID)='outputTrigger' then do;
            /* if its a trigger */
 
              if runFirstTime le 0 then do;
                runFirstTime=msr_timestamp;
 
                loggerString = 'NOTE: Run initiated at '||strip(put((runFirstTime/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                writeTo.log('i', loggerString);
              end;
 
              if runStage='historical' then do;
              /* if this is a historical run and a realtime output trigger, then disregard */
              /* but it can kickoff processing of queues */
 
                getRawRecordQueueDetail(rawRecordQueueSize,rawRecordQueueNext,rawRecordQueueLast);
                getTriggerRecordQueueDetail(triggerRecordQueueSize,triggerRecordQueueNext,triggerRecordQueueLast);
                outputInProgress = getOutputInProgress();
 
                if triggerRecordQueueSize=0 then do;
                /* no queue - process raw as needed */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(99999999999999999);
                  end;
 
                  _outOpcode='delete';
 
                end;
                else do;
                /* process what you can from queues */
 
                  if outputInProgress='true' then do;
                  /* since output is already in progress, just process raw through the next trigger */
 
                    nextTriggerInQueue = checkNextTriggerInQueue();
                    if rawRecordQueueSize gt 0 then do;
                      processRawQueueThrough(nextTriggerInQueue);
                    end;
 
                    _outOpcode='delete';
 
                  end;
                  else if outputInProgress='false' then do;
                  /* since output is not in progress, process raw until the next queue and then issue the next trigger */
 
                    nextTriggerInQueue = checkNextTriggerInQueue();
                    if rawRecordQueueSize gt 0 then do;
                      processRawQueueThrough(nextTriggerInQueue);
                    end;
 
                    /* process the trigger */
                    flipABStatus(statusAB,inactiveStatusAB);
                    setOutputInProgress('true');
 
                    getTriggerFromQueue(thisTrigger);
                    triggerTimestamp=thisTrigger;
                    consolidateStatusAB=inactiveStatusAB;
 
                    /* flip to realtime mode if this will be the first real-time trigger processed */
                    if triggerTimestamp gt runFirstTime and runFirstTime gt 0 and runStage='historical' then do;
                      runStage='realTime';
                      loggerString = 'NOTE: Switching from HISTORICAL mode to REALTIME mode for trigger '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                      writeTo.log('i', loggerString);
                    end;
 
                    _outOpcode='insert';
 
                  end;
 
                end;
 
              end;
              else do;
              /* output trigger running realtime */
 
                getRawRecordQueueDetail(rawRecordQueueSize,rawRecordQueueNext,rawRecordQueueLast);
                getTriggerRecordQueueDetail(triggerRecordQueueSize,triggerRecordQueueNext,triggerRecordQueueLast);
                getTriggerDetail(msr_timestamp,crossedTrigger,createTriggerFirst,createTriggerLast,expectedTrigger);
                outputInProgress = getOutputInProgress();
 
                if triggerRecordQueueSize=0 and outputInProgress='false' and crossedTrigger='false' then do;
                /* there is no queue and no trigger was crossed, so just update current value */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(99999999999999999);
                  end;
 
                  _outOpcode='delete';
 
                end;
                else if triggerRecordQueueSize=0 and outputInProgress='false' and crossedTrigger='true' then do;
                /* there is no queue and no output in progress but you just crossed a trigger */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(createTriggerFirst);
                  end;
 
                  flipABStatus(statusAB,inactiveStatusAB);
                  setOutputInProgress('true');
 
                  if createTriggerLast gt createTriggerFirst then do;
                    createTriggerSecondTemp1 = @historyInterval@;
                    createTriggerSecondTemp2 = 1000000;
                    createTriggerSecondInterval = createTriggerSecondTemp1 * createTriggerSecondTemp2;
                    createTriggerSecond = createTriggerFirst + createTriggerSecondInterval;
 
                    addTriggersToQueue(createTriggerSecond,createTriggerLast);
                  end;
 
                  triggerTimestamp=createTriggerFirst;
                  consolidateStatusAB=inactiveStatusAB;
                  _outOpcode='insert';
 
                  /* flip to realtime mode if this will be the first real-time trigger processed */
                  if triggerTimestamp gt runFirstTime and runFirstTime gt 0 and runStage='historical' then do;
                    runStage='realTime';
                    loggerString = 'NOTE: Switching from HISTORICAL mode to REALTIME mode for trigger '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    writeTo.log('i', loggerString);
                  end;
 
                end;
                else if triggerRecordQueueSize=0 and outputInProgress='true' and crossedTrigger='false' then do;
                /* there is no queue, output is in progress, but a new trigger has not been crossed */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(99999999999999999);
                  end;
 
                  _outOpcode='delete';
 
                end;
                else if triggerRecordQueueSize=0 and outputInProgress='true' and crossedTrigger='true' then do;
                /* there is no queue, output is in progress, but you just crossed another trigger - queue needed now */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(createTriggerFirst);
                  end;
 
                  addTriggersToQueue(createTriggerFirst,createTriggerLast);
                  _outOpcode='delete';
 
                end;
                else do;
                  /* there is a queue - add new record to end of the queue and process from the beginning of the queue */
 
                  if crossedTrigger='true' then do;
 
                    addTriggersToQueue(createTriggerFirst,createTriggerLast);
 
                  end;
 
                  nextTriggerInQueue = checkNextTriggerInQueue();
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(nextTriggerInQueue);
                  end;
 
                  if outputInProgress='true' then do;
                  /* since output is in progress, just process raw data until the next queue */
 
                    _outOpcode='delete';
 
                  end;
                  else if outputInProgress='false' then do;
                  /* since output is not in progress, process raw data until next queue and the next trigger */
 
                    /* process the next trigger */
                    flipABStatus(statusAB,inactiveStatusAB);
                    setOutputInProgress('true');
 
                    getTriggerFromQueue(thisTrigger);
                    triggerTimestamp=thisTrigger;
                    consolidateStatusAB=inactiveStatusAB;
 
                    /* flip to realtime mode if this will be the first real-time trigger processed */
                    if triggerTimestamp gt runFirstTime and runFirstTime gt 0 and runStage='historical' then do;
                      runStage='realTime';
                      loggerString = 'NOTE: Switching from HISTORICAL mode to REALTIME mode for trigger '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                      writeTo.log('i', loggerString);
                    end;
 
                    _outOpcode='insert';
 
                  end;
 
                end;
 
              end;
 
            end;
            else do;
            /* if its a raw record */
 
              if (runStage='historical' and runFirstTime gt 0 and msr_timestamp gt runFirstTime) then do;
              /* if this is a realtime sensor record that is seen during the historical run stage */
              /* specifically historical run has finished being read but is still be processing out of the queue */
              /* these realtime records will just get tacked onto the end of the queue */
 
                getRawRecordQueueDetail(rawRecordQueueSize,rawRecordQueueNext,rawRecordQueueLast);
                getTriggerRecordQueueDetail(triggerRecordQueueSize,triggerRecordQueueNext,triggerRecordQueueLast);
                getTriggerDetail(msr_timestamp,crossedTrigger,createTriggerFirst,createTriggerLast,expectedTrigger);
 
                addCurrentValueToQueue(msr_timestamp,assetID,attributeID,value);
 
                if crossedTrigger='true' then do;
                  addTriggersToQueue(createTriggerFirst,createTriggerLast);
                end;
 
                _outOpcode='delete';
 
              end;
              else do;
              /* not a special case */
 
                getRawRecordQueueDetail(rawRecordQueueSize,rawRecordQueueNext,rawRecordQueueLast);
                getTriggerRecordQueueDetail(triggerRecordQueueSize,triggerRecordQueueNext,triggerRecordQueueLast);
                getTriggerDetail(msr_timestamp,crossedTrigger,createTriggerFirst,createTriggerLast,expectedTrigger);
                outputInProgress = getOutputInProgress();
 
                if triggerRecordQueueSize=0 and outputInProgress='false' and crossedTrigger='false' then do;
                /* there is no queue and no trigger was crossed, so just update current value */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(99999999999999999);
                  end;
 
                  updateCurrentValue(msr_timestamp,assetID,attributeID,value);
 
                  _outOpcode='delete';
 
                end;
                else if triggerRecordQueueSize=0 and outputInProgress='false' and crossedTrigger='true' then do;
                /* there is no queue and no output in progress but you just crossed a trigger */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(createTriggerFirst);
                  end;
 
                  flipABStatus(statusAB,inactiveStatusAB);
                  setOutputInProgress('true');
 
                  if createTriggerLast gt createTriggerFirst then do;
                    createTriggerSecondTemp1 = @historyInterval@;
                    createTriggerSecondTemp2 = 1000000;
                    createTriggerSecondInterval = createTriggerSecondTemp1 * createTriggerSecondTemp2;
                    createTriggerSecond = createTriggerFirst + createTriggerSecondInterval;
 
                    addTriggersToQueue(createTriggerSecond,createTriggerLast);
                    addCurrentValueToQueue(msr_timestamp,assetID,attributeID,value);
                  end;
                  else do;
                    updateCurrentValue(msr_timestamp,assetID,attributeID,value);
                  end;
 
                  triggerTimestamp=createTriggerFirst;
                  consolidateStatusAB=inactiveStatusAB;
                  _outOpcode='insert';
 
                  /* flip to realtime mode if this will be the first real-time trigger processed */
                  if triggerTimestamp gt runFirstTime and runFirstTime gt 0 and runStage='historical' then do;
                    runStage='realTime';
                    loggerString = 'NOTE: Switching from HISTORICAL mode to REALTIME mode for trigger '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    writeTo.log('i', loggerString);
                  end;
 
                end;
                else if triggerRecordQueueSize=0 and outputInProgress='true' and crossedTrigger='false' then do;
                /* there is no queue, output is in progress, but a new trigger has not been crossed */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(99999999999999999);
                  end;
 
                  updateCurrentValue(msr_timestamp,assetID,attributeID,value);
 
                  _outOpcode='delete';
 
                end;
                else if triggerRecordQueueSize=0 and outputInProgress='true' and crossedTrigger='true' then do;
                /* there is no queue, output is in progress, but you just crossed another trigger - queue needed now */
 
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(createTriggerFirst);
                  end;
 
                  addCurrentValueToQueue(msr_timestamp,assetID,attributeID,value);
 
                  addTriggersToQueue(createTriggerFirst,createTriggerLast);
 
                  _outOpcode='delete';
 
                end;
                else do;
                  /* there is a queue - add new record to end of the queue and process from the beginning of the queue */
 
                  addCurrentValueToQueue(msr_timestamp,assetID,attributeID,value);
 
                  if crossedTrigger='true' then do;
                    addTriggersToQueue(createTriggerFirst,createTriggerLast);
                  end;
 
                  getRawRecordQueueDetail(rawRecordQueueSize,rawRecordQueueNext,rawRecordQueueLast);
                  getTriggerRecordQueueDetail(triggerRecordQueueSize,triggerRecordQueueNext,triggerRecordQueueLast);
 
                  nextTriggerInQueue = checkNextTriggerInQueue();
                  if rawRecordQueueSize gt 0 then do;
                    processRawQueueThrough(nextTriggerInQueue);
                  end;
 
                  if outputInProgress='true' then do;
                  /* since output is in progress, just process raw data until the next queue */
 
                    _outOpcode='delete';
 
                  end;
                  else if outputInProgress='false' then do;
                  /* since output is not in progress, process raw data until next queue and the next trigger */
                  /* process the next trigger */
 
                    flipABStatus(statusAB,inactiveStatusAB);
                    setOutputInProgress('true');
 
                    getTriggerFromQueue(thisTrigger);
                    triggerTimestamp=thisTrigger;
                    consolidateStatusAB=inactiveStatusAB;
 
                    /* flip to realtime mode if this will be the first real-time trigger processed */
                    if triggerTimestamp gt runFirstTime and runFirstTime gt 0 and runStage='historical' then do;
                      runStage='realTime';
                      loggerString = 'NOTE: Switching from HISTORICAL mode to REALTIME mode for trigger '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                      writeTo.log('i', loggerString);
                    end;
 
                    _outOpcode='insert';
 
                  end;
 
                end;
 
              end;
 
            end;
 
            if _outOpcode='insert' then do;
              getRawRecordQueueDetail(rawRecordQueueSize,rawRecordQueueNext,rawRecordQueueLast);
              getTriggerRecordQueueDetail(triggerRecordQueueSize,triggerRecordQueueNext,triggerRecordQueueLast);
              rawRecordCount        =localRawRecordCount;
              printRawQueueCount    =rawRecordQueueSize;
              printTriggerQueueCount=triggerRecordQueueSize;
 
              loggerString = 'NOTE: Issuing trigger from updateCurrentValue for '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
              if '@logLevel@' in ('luaDebug') then writeTo.log('i', loggerString);
            end;
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="updateHistoryModule" language="ds2" func-names="runUpdateHistory">
      <code><![CDATA[ds2_options sas;
 
        package updateHistoryPackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep valueIsMissing;
          declare integer numDevMeas cnt breakloc numAssets numHistory;
          declare char(500) thisDevMeas;
          declare char(75)  thisAssetType;
          declare char(100) thisAttributeID;
 
          declare char(20)  attributeType dataType dataFormat acceptableMinLogic acceptableMaxLogic;
          declare char(100) attributeLabel;
          declare integer   dataLength historyMaxEvents historyMaxTime retentionPeriod;
          declare double    acceptableMin acceptableMax;
 
          declare bigint    currentValueTimestamp;
          declare double    currentValueDouble;
          declare char(100) currentValueString;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          declare integer   numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method runUpdateHistory(
            bigint     key1,
            bigint     triggerTimestamp,
            in_out char(10) _outOpcode
          );
 
            _outOpcode='insert';
 
            /*** retrieve devMeasHistoryList ***/
            numDevMeas=0;
            getVector ('devMeasHistoryList');
            numDevMeas=st.getInt('devMeasHistoryList',0);
 
            /*** iterate through devMeasHistoryList - assetTypes/attributeIDs ***/
            do cnt=1 to numDevMeas;
              thisDevMeas=strip(st.getString('devMeasHistoryList',cnt));
              breakloc = index(strip(thisDevMeas),'|');
              thisAssetType = substr(strip(thisDevMeas),1,breakloc-1);
              thisAttributeID = substr(strip(thisDevMeas),breakloc+1);
 
              /*** obtain details about how history is being maintained for that attribute ***/
              attributeType      = '';
              attributeLabel     = '';
              dataType           = '';
              dataLength         = .;
              dataFormat         = '';
              retentionPeriod     = .;
              acceptableMin      = .;
              acceptableMinLogic = '';
              acceptableMax      = .;
              acceptableMaxLogic = '';
              historyMaxEvents   = .;
              historyMaxTime     = .;
              numHistory         = 0;
 
              getVector ('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID));
 
              attributeType      = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),0);
              attributeLabel     = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),1);
              dataType           = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),2);
              dataLength         = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),3);
              dataFormat         = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),4);
              retentionPeriod     = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),5);
              acceptableMin      = st.getDouble('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),6);
              acceptableMinLogic = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),7);
              acceptableMax      = st.getDouble('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),8);
              acceptableMaxLogic = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),9);
 
              historyMaxEvents   = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),11);
              historyMaxTime     = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),12);
 
              numHistory = int( (historyMaxTime*1.0) / (@historyInterval@ * 1.0) );
 
              deleteVector ('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID));
 
              /*** iterate through the assetIDs for that assetType ***/
              if numHistory gt 0 then do;
 
                numAssets=0;
                getVector ('assetType|'||strip(thisAssetType)||'|assetList');
                numAssets=st.getInt('assetType|'||strip(thisAssetType)||'|assetList',0);
 
                /*** iterate through each asset for the assetType ***/
                do cnt2=1 to numAssets;
 
                  thisAssetID=strip(st.getString('assetType|'||strip(thisAssetType)||'|assetList',cnt2));
 
                  /*** retrieve currentValue ***/
                  currentValueTimestamp = .;
                  currentValueDouble    = .;
                  currentValueString    = '';
 
                  getVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
 
                  if dataType='double' then do;
                    currentValueTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2);
                    currentValueDouble    = st.getDouble('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3);
                  end;
                  else if dataType='string' then do;
                    currentValueTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2);
                    currentValueString    = st.getString('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3);
                  end;
                  deleteVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
 
                  /*** retrieve currentValueHistory ***/
                  getVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history');
 
                  /*** update history value and base location for history vector ***/
                  maxHistoryLength    = st.getInt('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history',2);
                  baseHistoryLocation = st.getInt('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history',3);
 
                  if baseHistoryLocation=. then nextHistoryLocation=1;
                  else if baseHistoryLocation=maxHistoryLength then nextHistoryLocation=1;
                  else nextHistoryLocation=baseHistoryLocation+1;
 
                  rc = st.setInt('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history',3,nextHistoryLocation);
                  rc = st.setLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history',2+int(nextHistoryLocation*2),currentValueTimestamp);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history',int(nextHistoryLocation*2)+3,currentValueDouble);
                    loggerString = 'NOTE: Added '||strip(put(currentValueDouble,24.8))||' with timestamp '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' to the history vector for '||strip(thisAssetID)||' / '||strip(thisAttributeID)||'.';
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history',int(nextHistoryLocation*2)+3,currentValueString);
                    loggerString = 'NOTE: Added '||strip(currentValueString)||' with timestamp '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' to the history vector for '||strip(thisAssetID)||' / '||strip(thisAttributeID)||'.';
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
 
                  replaceVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history');
                  deleteVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|history');
 
                end;
                deleteVector ('assetType|'||strip(thisAssetType)||'|assetList');
 
              end;
 
            end;
            deleteVector ('devMeasHistoryList');
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="consolidateCurrentValueModule" language="ds2" func-names="consolidateCurrentValue">
      <code><![CDATA[ds2_options sas;
 
        package consolidateCurrentValuePackage / overwrite = yes;
 
          declare double    rc rc1 rc1s rc2 rc2s rcsleep cnt cnt2 cnt3;
 
          declare integer   numAssetTypes numAssets numAttributes symUpdateNeeded isFirstOutput;
          declare char(75)  thisAssetType;
          declare char(300) thisAssetID;
          declare char(100) thisAttributeID;
          declare bigint    currentValueTimestamp currentValueStorageTimestamp lastValueTimestamp;
          declare double    currentValueDouble currentValueStorageDouble lastValueDouble;
          declare char(100) currentValueString currentValueStorageString lastValueString;
 
          declare char(20)  attributeType dataType dataFormat acceptableMinLogic acceptableMaxLogic;
          declare char(100) attributeLabel;
          declare integer   dataLength historyMaxEvents historyMaxTime retentionPeriod numHistory;
          declare double    acceptableMin acceptableMax;
 
          declare integer   numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          declare bigint    initialOutputUTC;
          declare bigint    initialOutputUTCHelp1;
          declare bigint    initialOutputUTCHelp2;
          declare bigint    initialOutputUTCHelp3;
          declare integer   initialOutputUTCMessage;
 
          declare char(1)   outputRecordsToABT;
          declare integer   startedOutputToABT;
 
          method init();
 
            isFirstOutput = 1;
 
            if '@initialOutputTimestampUTC@'='@'||'initialOutputTimestampUTC'||'@' then do;
              initialOutputUTC=0;
 
              loggerString = 'NOTE: All output records will be processed.';
              writeTo.log('i', loggerString);
            end;
            else do;
              initialOutputUTCHelp1 = inputn(strip('@initialOutputTimestampUTC@'),'16.0');
              initialOutputUTCHelp2 = 315619200000000;
              initialOutputUTC = initialOutputUTCHelp1 + initialOutputUTCHelp2;
 
              loggerString = 'NOTE: Skipping output periods prior to UTC '||strip(put((initialOutputUTC - initialOutputUTCHelp2),20.0));
              writeTo.log('i', loggerString);
            end;
            initialOutputUTCMessage=0;
 
            startedOutputToABT=0;
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method getAssetRecordQueueDetail(in_out bigint _assetRecordQueueSize,
                                           in_out bigint _assetRecordQueueLast);
 
            _assetRecordQueueSize=0;
            _assetRecordQueueLast=0;
 
            getVector ('assetRecordQueue');
            _assetRecordQueueSize=st.getLong('assetRecordQueue',0);
            deleteVector ('assetRecordQueue');
 
            getVector ('assetRecordQueueL');
            _assetRecordQueueLast=st.getLong('assetRecordQueueL',0);
            deleteVector ('assetRecordQueueL');
 
          end;
          method getAssetRecordQueueDetailCV(in_out bigint _assetRecordQueueSize,
                                             in_out bigint _assetRecordQueueLast);
 
            _assetRecordQueueSize=0;
            _assetRecordQueueLast=0;
 
            getVector ('assetRecordQueueCV');
            _assetRecordQueueSize=st.getLong('assetRecordQueueCV',0);
            deleteVector ('assetRecordQueueCV');
 
            getVector ('assetRecordQueueCVL');
            _assetRecordQueueLast=st.getLong('assetRecordQueueCVL',0);
            deleteVector ('assetRecordQueueCVL');
 
          end;
          method getConnRecordQueueDetail(in_out bigint _connRecordQueueSize,
                                          in_out bigint _connRecordQueueLast);
 
            _connRecordQueueSize=0;
            _connRecordQueueLast=0;
 
            getVector ('connRecordQueue');
            _connRecordQueueSize=st.getLong('connRecordQueue',0);
            deleteVector ('connRecordQueue');
 
            getVector ('connRecordQueueL');
            _connRecordQueueLast=st.getLong('connRecordQueueL',0);
            deleteVector ('connRecordQueueL');
 
          end;
 
          method checkNextAssetInQueue() returns bigint;
 
            declare bigint _AssetRecordQueueSize _AssetRecordQueueLast;
            declare bigint _NextAssetInQueue;
 
            getAssetRecordQueueDetail(_AssetRecordQueueSize,
                                      _AssetRecordQueueLast);
 
            if _AssetRecordQueueLast = _AssetRecordQueueSize then do;
 
              _NextAssetInQueue=.;
 
            end;
            else do;
 
              newLocation=mod(_AssetRecordQueueLast,10000);
 
              _NextAssetInQueue=.;
 
              getVector ('assetRecordQueue'||strip(put(newLocation,z4.)));
 
              _NextAssetInQueue = st.getLong('assetRecordQueue'||strip(put(newLocation,z4.)),0);
 
              deleteVector ('assetRecordQueue'||strip(put(newLocation,z4.)));
 
            end;
 
            return _NextAssetInQueue;
 
          end;
          method checkNextAssetInQueueCV() returns bigint;
 
            declare bigint _AssetRecordQueueSize _AssetRecordQueueLast;
            declare bigint _NextAssetInQueue;
 
            getAssetRecordQueueDetailCV(_AssetRecordQueueSize,
                                        _AssetRecordQueueLast);
 
            if _AssetRecordQueueLast = _AssetRecordQueueSize then do;
 
              _NextAssetInQueue=.;
 
            end;
            else do;
 
              _NextAssetInQueue=.;
 
              newLocation=mod(_AssetRecordQueueLast,10000);
 
              getVector ('assetRecordQueueCV'||strip(put(newLocation,z4.)));
 
              _NextAssetInQueue = st.getLong('assetRecordQueueCV'||strip(put(newLocation,z4.)),0);
 
              deleteVector ('assetRecordQueueCV'||strip(put(newLocation,z4.)));
 
            end;
 
            return _NextAssetInQueue;
 
          end;
 
          method checkNextConnectionInQueue() returns bigint;
 
            declare bigint _ConnRecordQueueSize _ConnRecordQueueLast;
            declare bigint _NextConnInQueue;
 
            getConnRecordQueueDetail(_ConnRecordQueueSize,
                                     _ConnRecordQueueLast);
 
            if _ConnRecordQueueLast = _ConnRecordQueueSize then do;
 
              _NextConnInQueue=.;
 
            end;
            else do;
 
              _NextConnInQueue=.;
 
              newLocation=mod(_ConnRecordQueueLast,10000);
 
              getVector ('connRecordQueue'||strip(put(newLocation,z4.)));
 
              _NextConnInQueue = st.getLong('connRecordQueue'||strip(put(newLocation,z4.)),0);
 
              deleteVector ('connRecordQueue'||strip(put(newLocation,z4.)));
 
            end;
 
            return _NextConnInQueue;
 
          end;
 
          method updateConnRecordQueueDetailL(bigint _connRecordQueueLast);
 
            getVector ('connRecordQueueL');
 
            rc = st.setLong('connRecordQueueL',0,_connRecordQueueLast);
 
            replaceVector ('connRecordQueueL');
            deleteVector ('connRecordQueueL');
 
          end;
 
          method updateAssetRecordQueueDetailL(bigint _assetRecordQueueLast);
 
            getVector ('assetRecordQueueL');
 
            rc = st.setLong('assetRecordQueueL',0,_assetRecordQueueLast);
 
            replaceVector ('assetRecordQueueL');
            deleteVector ('assetRecordQueueL');
 
          end;
          method updateAssetRecordQueueDetailCVL(bigint _assetRecordQueueLast);
 
            getVector ('assetRecordQueueCVL');
 
            rc = st.setLong('assetRecordQueueCVL',0,_assetRecordQueueLast);
 
            replaceVector ('assetRecordQueueCVL');
            deleteVector ('assetRecordQueueCVL');
 
          end;
 
          method addAsset (char(300) di, char(75) dt, char(300) dl, char(1) oar, char(1) addToAList);
 
            /*** retrieve assetTypeList vector and check whether assetType is already in list ***/
            numAssetTypes=0;
            foundAssetType=0;
 
            getVector ('assetTypeList');
 
            numAssetTypes=st.getInt('assetTypeList',0);
            foundAssetType=0;
            do cnt=1 to numAssetTypes;
              if strip(st.getString('assetTypeList',cnt))=strip(dt) then foundAssetType=1;
            end;
            deleteVector ('assetTypeList');
 
            if foundAssetType=1 then do;
 
              /*** retrieve assetList vector and check whether assetID is already in list ***/
              numAssets=0;
              foundAsset=0;
              getVector ('assetType|'||strip(dt)||'|assetList');
              numAssets=st.getInt('assetType|'||strip(dt)||'|assetList',0);
              foundAsset=0;
              do cnt=1 to numAssets;
                if strip(st.getString('assetType|'||strip(dt)||'|assetList',cnt))=strip(di) then foundAsset=1;
              end;
 
              numOutputAssets=0;
              getVector ('assetType|'||strip(dt)||'|outputAssetList');
              numOutputAssets=st.getInt('assetType|'||strip(dt)||'|outputAssetList',0);
 
              if numAssets = 10000 then do;
 
                loggerString = 'ERROR: assetID '||strip(di)||' could not be added - number of assets at max.';
                writeTo.log('i', loggerString);
 
              end;
              else if foundAsset=0 then do;
 
                loggerString = 'NOTE: Adding assetID '||strip(di)||' of assetType '||strip(dt)||' (consolidate current value)';
                writeTo.log('i', loggerString);
 
                /*** retrieve the attributes hash ***/
                numAttributes=0;
                getVector ('assetType|'||strip(dt)||'|attributeList');
                numAttributes=st.getInt('assetType|'||strip(dt)||'|attributeList',0);
 
                /*** make a copy of the attribute list and attach to the asset for easier navigation ***/
                createVector ('asset|'||strip(di)||'|attributeList',1001);
                rc = st.setInt('asset|'||strip(di)||'|attributeList',0,numAttributes);
 
                /*** iterate through the attributeList hash and initiate the assetID|attributeID|currentValueA,currentValueB,history hashes ***/
                do cnt=1 to numAttributes;
 
                  /*** choose a attributeID to process ***/
                  thisAttributeID=st.getString('assetType|'||strip(dt)||'|attributeList',cnt);
                  rc = st.setString('asset|'||strip(di)||'|attributeList',cnt,strip(thisAttributeID));
 
                  /*** pull information about the attribute ***/
                  attributeType      = '';
                  attributeLabel     = '';
                  dataType           = '';
                  dataLength         = .;
                  dataFormat         = '';
                  retentionPeriod     = .;
                  acceptableMin      = .;
                  acceptableMinLogic = '';
                  acceptableMax      = .;
                  acceptableMaxLogic = '';
                  historyMaxEvents   = .;
                  historyMaxTime     = .;
                  numHistory         = 0;
 
                  getVector ('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID));
 
                  attributeType      = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),0);
                  attributeLabel     = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),1);
                  dataType           = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),2);
                  dataLength         = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),3);
                  dataFormat         = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),4);
                  retentionPeriod     = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),5);
                  acceptableMin      = st.getDouble('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),6);
                  acceptableMinLogic = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),7);
                  acceptableMax      = st.getDouble('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),8);
                  acceptableMaxLogic = st.getString('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),9);
 
                  historyMaxEvents   = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),11);
                  historyMaxTime     = st.getInt('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID),12);
 
                  numHistory = int( (historyMaxTime * 1.0) / (@historyInterval@ * 1.0) );
 
                  deleteVector ('assetType|'||strip(dt)||'|attribute|'||strip(thisAttributeID));
 
                  /*** initiate currentValue ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,'');
                  end;
 
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
 
                  /*** initiate lastValue ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,'');
                  end;
 
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
 
                  /*** initiate currentValueStorageA ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA',3,'');
                  end;
 
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA');
 
                  /*** initiate currentValueStorageB ***/
                  createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',5);
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',0,strip(dataType));
                  rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',1,'');
                  rc = st.setLong('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',2,0);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',3,.);
                  end;
                  else do;
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB',3,'');
                  end;
                  putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB');
                  deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB');
 
                  /*** initiate the history vector ***/
                  if numHistory gt 0 then do;
                    createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',4+(numHistory*2));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',0,strip(dataType));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',1,'');
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',2,numHistory);
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history',3,0);
 
                    putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history');
                    deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history');
                  end;
 
                  /*** initiate the events vector ***/
                  if historyMaxEvents gt 0 then do;
                    createVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',4+(historyMaxEvents*2));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',0,strip(dataType));
                    rc = st.setString('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',1,'');
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',2,historyMaxEvents);
                    rc = st.setInt('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events',3,0);
 
                    putVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events');
                    deleteVector ('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events');
                  end;
 
                  loggerString = 'NOTE: ...added attributeID '||strip(thisAttributeID);
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                end;
 
                /*** now store the copy of the attribute list attached to the asset for easier navigation ***/
                putVector ('asset|'||strip(di)||'|attributeList');
                deleteVector ('asset|'||strip(di)||'|attributeList');
 
                /*** retrieve the attributes hash ***/
                numRawAttributes=0;
                getVector ('assetType|'||strip(dt)||'|rawAttributeList');
                numRawAttributes=st.getInt('assetType|'||strip(dt)||'|rawAttributeList',0);
 
                /*** make a copy of the attribute list and attach to the asset for easier navigation ***/
                createVector ('asset|'||strip(di)||'|rawAttributeList',1001);
                rc = st.setInt('asset|'||strip(di)||'|rawAttributeList',0,numRawAttributes);
 
                /*** iterate through the attributeList hash and initiate the assetID|attributeID|currentValueA,currentValueB,history hashes ***/
                do cnt=1 to numRawAttributes;
 
                  /*** choose a attributeID to process ***/
                  thisAttributeID=st.getString('assetType|'||strip(dt)||'|rawAttributeList',cnt);
                  rc = st.setString('asset|'||strip(di)||'|rawAttributeList',cnt,strip(thisAttributeID));
 
                end;
 
                /*** now store the copy of the raw attribute list attached to the asset for easier navigation ***/
                putVector ('asset|'||strip(di)||'|rawAttributeList');
                deleteVector ('asset|'||strip(di)||'|rawAttributeList');
 
                /*** retrieve the hierarchies hash ***/
                numHierarchies=0;
 
                getVector ('hierarchyList');
 
                numHierarchies=st.getInt('hierarchyList',0);
 
                /*** iterate through the hierarchies hash and initiate assetID|parents|hierarchyName,children|hierarchyName hashes with no parents-children ***/
                do cnt=1 to numHierarchies;
 
                  /*** choose a hierarchyName to process ***/
                  thisHierarchyName=st.getString('hierarchyList',cnt);
 
                  /*** initiate the parents hash ***/
                  createVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),maxNumberParentsChildrenPlus1.);
                  rc = st.setInt('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),0,0);
                  putVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
                  deleteVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
 
                  /*** initiate the children hash ***/
                  createVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),maxNumberParentsChildrenPlus1.);
                  rc = st.setInt('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),0,0);
                  putVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
                  deleteVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
 
                  loggerString = 'NOTE: ...added parent and children vectors for hierarchy '||strip(thisHierarchyName);
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                end;
                deleteVector ('hierarchyList');
 
                /*** initiate assetID hash with info provided ***/
                createVector ('asset|'||strip(di),2);
                rc = st.setString('asset|'||strip(di),0,strip(dt));
                rc = st.setString('asset|'||strip(di),1,strip(dl));
                putVector ('asset|'||strip(di));
                deleteVector ('asset|'||strip(di));
 
                if addToAList='Y' then do;
 
                  /*** add assetID to assetList hash ***/
                  numAssets=numAssets+1;
                  rc = st.setInt('assetType|'||strip(dt)||'|assetList',0,numAssets);
                  rc = st.setString('assetType|'||strip(dt)||'|assetList',numAssets,strip(di));
                  replaceVector ('assetType|'||strip(dt)||'|assetList');
 
                  /* this is only used for initial asset updates */
                  if oar='Y' then do;
 
                    numOutputAssets=numOutputAssets+1;
                    rc = st.setInt('assetType|'||strip(dt)||'|outputAssetList',0,numOutputAssets);
                    rc = st.setString('assetType|'||strip(dt)||'|outputAssetList',numOutputAssets,strip(di));
                    replaceVector ('assetType|'||strip(dt)||'|outputAssetList');
 
                  end;
 
                end;
 
                loggerString = 'NOTE: ...complete';
                if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
              end;
              else do;
 
                loggerString = 'WARNING: assetID '||strip(di)||' already exists.';
                writeTo.log('i', loggerString);
 
              end;
              deleteVector ('assetType|'||strip(dt)||'|assetList');
              deleteVector ('assetType|'||strip(dt)||'|outputAssetList');
 
            end;
            else do;
 
              loggerString = 'ERROR: assetID '||strip(di)||' was not added. assetType '||strip(dt)||' does not exist.';
              writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method updateAsset (char(300) di, char(300) dl, char(1) oar);
 
            /*** update the asset label ***/
            getVector ('asset|'||strip(di));
            thisAssetType = st.getString('asset|'||strip(di),0);
            rc = st.setString('asset|'||strip(di),1,strip(dl));
            replaceVector ('asset|'||strip(di));
            deleteVector ('asset|'||strip(di));
 
            /* update the output asset list for the asset type */
            addItem ('assetType|'||strip(thisAssetType)||'|assetList',strip(di));
            if oar='Y' then do;
              addItem ('assetType|'||strip(thisAssetType)||'|outputAssetList',strip(di));
            end;
            else if oar='N' then do;
              removeItem ('assetType|'||strip(thisAssetType)||'|outputAssetList',strip(di));
            end;
 
          end;
 
          method addConnection (char(25) hi, char(300) pdi, char(3) lnkdir, char(300) cdi);
 
            /*** retrieve hierarchyList vector and check whether hierarchyName is already in list ***/
            numHierarchies=0;
            foundHierarchy=0;
 
            getVector ('hierarchyList');
 
            numHierarchies=st.getInt('hierarchyList',0);
            foundHierarchy=0;
            do cnt=1 to numHierarchies;
              if strip(st.getString('hierarchyList',cnt))=strip(hi) then foundHierarchy=1;
            end;
            deleteVector ('hierarchyList');
 
            if foundHierarchy=1 then do;
 
              if checkIfVectorExists('asset|'||strip(pdi)) = 1 and
                 checkIfVectorExists('asset|'||strip(cdi)) = 1 then do;
 
                /*** add the parent to childs list and increment the counter ***/
                /*** add the child to parents list and increment the counter ***/
                numParents=0;
                foundParent=0;
                getVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
                numParents=st.getInt('asset|'||strip(cdi)||'|parents|'||strip(hi),0);
                foundParent=0;
                do cnt=1 to numParents;
                  if strip(st.getString('asset|'||strip(cdi)||'|parents|'||strip(hi),cnt))=strip(pdi) then foundParent=1;
                end;
 
                numChildren=0;
                foundChild=0;
                getVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
                numChildren=st.getInt('asset|'||strip(pdi)||'|children|'||strip(hi),0);
                foundChild=0;
                do cnt=1 to numChildren;
                  if strip(st.getString('asset|'||strip(pdi)||'|children|'||strip(hi),cnt))=strip(cdi) then foundChild=1;
                end;
 
                if foundParent=0 and lnkdir in ('<--','<->') then do;
 
                  numParents=numParents+1;
                  rc = st.setInt('asset|'||strip(cdi)||'|parents|'||strip(hi),0,numParents);
                  rc = st.setString('asset|'||strip(cdi)||'|parents|'||strip(hi),numParents,strip(pdi));
                  replaceVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
 
                end;
                deleteVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
 
                if foundParent=1 and lnkdir in ('-->') then do;
 
                  removeItem ('asset|'||strip(cdi)||'|parents|'||strip(hi),strip(pdi));
 
                end;
 
                if foundChild=0 and lnkdir in ('-->','<->') then do;
 
                  numChildren=numChildren+1;
                  rc = st.setInt('asset|'||strip(pdi)||'|children|'||strip(hi),0,numChildren);
                  rc = st.setString('asset|'||strip(pdi)||'|children|'||strip(hi),numChildren,strip(cdi));
                  replaceVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
 
                end;
                deleteVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
 
                if foundChild=1 and lnkdir in ('<--') then do;
 
                  removeItem ('asset|'||strip(pdi)||'|children|'||strip(hi),strip(cdi));
 
                end;
 
                loggerString = 'NOTE: Added/updated connection in hierarchy '||strip(hi)||' between parent '||strip(pdi)||' and child '||strip(cdi)||' AFTER project initialization.';
                writeTo.log('i', loggerString);
 
              end;
              else do;
 
                loggerString = 'ERROR: Connection was not added in hierarchy '||strip(hi)||' between parent '||strip(pdi)||' and child '||strip(cdi)||'. Parent or child does not exist.';
                writeTo.log('i', loggerString);
 
              end;
 
            end;
            else do;
 
              loggerString = 'ERROR: Connection was not added in hierarchy '||strip(hi)||' between parent '||strip(pdi)||' and child '||strip(cdi)||'. Hierarchy '||strip(hi)||' does not exist.';
              writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method deleteConnection (char(25) hi, char(300) pdi, char(300) cdi);
 
            /***   delete the parent from the childs list for the assetID and decrement the counter ***/
            /***   delete the child from the parents list for the assetID and decrement the counter ***/
 
            /*** retrieve hierarchyList vector and check whether hierarchyName is already in list ***/
            numHierarchies=0;
            foundHierarchy=0;
 
            getVector ('hierarchyList');
 
            numHierarchies=st.getInt('hierarchyList',0);
            foundHierarchy=0;
            do cnt=1 to numHierarchies;
              if strip(st.getString('hierarchyList',cnt))=strip(hi) then foundHierarchy=1;
            end;
            deleteVector ('hierarchyList');
 
            if foundHierarchy=1 then do;
 
              if checkIfVectorExists('asset|'||strip(cdi)) = 1 then do;
 
                /*** add the parent to childs list and increment the counter ***/
                /*** add the child to parents list and increment the counter ***/
                numParents=0;
                foundParent=0;
                getVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
                numParents=st.getInt('asset|'||strip(cdi)||'|parents|'||strip(hi),0);
                foundParent=0;
                do cnt=1 to numParents;
                  if strip(st.getString('asset|'||strip(cdi)||'|parents|'||strip(hi),cnt))=strip(pdi) then foundParent=1;
                end;
                deleteVector ('asset|'||strip(cdi)||'|parents|'||strip(hi));
 
                if foundParent=1 then do;
                  removeItem ('asset|'||strip(cdi)||'|parents|'||strip(hi),strip(pdi));
                end;
 
              end;
 
              if checkIfVectorExists('asset|'||strip(pdi)) = 1 then do;
 
                numChildren=0;
                foundChild=0;
                getVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
                numChildren=st.getInt('asset|'||strip(pdi)||'|children|'||strip(hi),0);
                foundChild=0;
                do cnt=1 to numChildren;
                  if strip(st.getString('asset|'||strip(pdi)||'|children|'||strip(hi),cnt))=strip(cdi) then foundChild=1;
                end;
                deleteVector ('asset|'||strip(pdi)||'|children|'||strip(hi));
 
                if foundChild=1 then do;
                  removeItem ('asset|'||strip(pdi)||'|children|'||strip(hi),strip(cdi));
                end;
 
              end;
 
              loggerString = 'NOTE: Deleted connection in hierarchy '||strip(hi)||' between parent '||strip(pdi)||' and child '||strip(cdi)||' AFTER project initialization.';
              writeTo.log('i', loggerString);
 
            end;
 
          end;
 
          method processConnQueueThrough(
            bigint _NextConnInQueue
          );
 
            declare bigint    _ConnRecordQueueSize _ConnRecordQueueLast;
            declare char(50)  _Action;
            declare char(25)  _HierarchyName;
            declare char(300) _ParentAssetID;
            declare char(300) _ChildAssetID;
            declare char(3)   _Direction;
            declare bigint    _Msr_timestamp;
            declare integer   i thisloc;
 
            getConnRecordQueueDetail(_ConnRecordQueueSize,
                                     _ConnRecordQueueLast);
 
            if _ConnRecordQueueSize gt _ConnRecordQueueLast then do;
 
              i = _ConnRecordQueueLast + 1;
              do while (i le _ConnRecordQueueSize);
 
                thisloc = mod(i-1,10000);
 
                getVector ('connRecordQueue'||strip(put(thisloc,z4.)));
 
                _Msr_timestamp = st.getLong('connRecordQueue'||strip(put(thisloc,z4.)),0);
                _Action        = strip(st.getString('connRecordQueue'||strip(put(thisloc,z4.)),1));
                _HierarchyName = strip(st.getString('connRecordQueue'||strip(put(thisloc,z4.)),2));
                _ParentAssetID = strip(st.getString('connRecordQueue'||strip(put(thisloc,z4.)),3));
                _Direction     = strip(st.getString('connRecordQueue'||strip(put(thisloc,z4.)),4));
                _ChildAssetID  = strip(st.getString('connRecordQueue'||strip(put(thisloc,z4.)),5));
 
                deleteVector ('connRecordQueue'||strip(put(thisloc,z4.)));
 
                if _Msr_timestamp le _NextConnInQueue or _NextConnInQueue=. then do;
 
                  if _Action='add' then do;
                    addConnection(_HierarchyName,_ParentAssetID,_Direction,_ChildAssetID);
                  end;
                  else if _Action='delete' then do;
                    deleteConnection (_HierarchyName,_ParentAssetID,_ChildAssetID);
                  end;
 
                  removeVector('connRecordQueue'||strip(put(thisloc,z4.)));
 
                  updateConnRecordQueueDetailL(i);
 
                end;
                else i=9999999999;
 
                i = i + 1;
 
              end;
 
            end;
 
          end;
 
          method processAssetQueueThrough(
            bigint _NextAssetInQueue
          );
 
            declare bigint     _AssetRecordQueueSize _AssetRecordQueueLast;
            declare bigint     _Msr_timestamp;
            declare char(50)   _Action;
            declare char(300)  _AssetID;
            declare char(75)   _AssetType;
            declare char(300)  _AssetLabel;
            declare char(1)    _OutputAssetRequired;
            declare integer    i thisloc;
 
            getAssetRecordQueueDetail(_AssetRecordQueueSize,
                                      _AssetRecordQueueLast);
 
            if _AssetRecordQueueSize gt _AssetRecordQueueLast then do;
 
              i = _AssetRecordQueueLast + 1;
              do while (i le _AssetRecordQueueSize);
 
                thisloc = mod(i-1,10000);
 
                getVector ('assetRecordQueue'||strip(put(thisloc,z4.)));
 
                _Msr_timestamp       = st.getLong('assetRecordQueue'||strip(put(thisloc,z4.)),0);
                _Action              = strip(st.getString('assetRecordQueue'||strip(put(thisloc,z4.)),1));
                _AssetID             = strip(st.getString('assetRecordQueue'||strip(put(thisloc,z4.)),2));
                _AssetType           = strip(st.getString('assetRecordQueue'||strip(put(thisloc,z4.)),3));
                _AssetLabel          = strip(st.getString('assetRecordQueue'||strip(put(thisloc,z4.)),4));
                _OutputAssetRequired = strip(st.getString('assetRecordQueue'||strip(put(thisloc,z4.)),5));
 
                deleteVector ('assetRecordQueue'||strip(put(thisloc,z4.)));
 
                if _Msr_timestamp le _NextAssetInQueue or _NextAssetInQueue=. then do;
 
                  if _Action='add' or _Action='update' then do;
 
                    if checkIfVectorExists('asset|'||strip(_AssetID)) = 1 then do;
                      updateAsset(_AssetID,_AssetLabel,_OutputAssetRequired);
                    end;
                    else do;
                      addAsset(_AssetID,_AssetType,_AssetLabel,_OutputAssetRequired,'Y');
                    end;
 
                  end;
                  else if _Action='delete' then do;
 
                    /* do nothing - this should never occur since only adds are kept here */
 
                  end;
 
                  removeVector('assetRecordQueue'||strip(put(thisloc,z4.)));
 
                  updateAssetRecordQueueDetailL(i);
 
                end;
                else i=99999999999;
 
                i = i + 1;
 
              end;
 
            end;
 
          end;
 
          method processAssetQueueThroughCV(
            bigint _NextAssetInQueue
          );
 
            declare bigint     _AssetRecordQueueSize _AssetRecordQueueLast;
            declare bigint     _Msr_timestamp;
            declare char(50)   _Action;
            declare char(300)  _AssetID;
            declare char(75)   _AssetType;
            declare char(300)  _AssetLabel;
            declare char(1)    _OutputAssetRequired;
            declare integer    i thisloc;
 
            getAssetRecordQueueDetailCV(_AssetRecordQueueSize,
                                        _AssetRecordQueueLast);
 
            if _AssetRecordQueueSize gt _AssetRecordQueueLast then do;
 
              i = _AssetRecordQueueLast + 1;
              do while (i le _AssetRecordQueueSize);
 
                thisloc = mod(i-1,10000);
 
                getVector ('assetRecordQueueCV'||strip(put(thisloc,z4.)));
 
                _Msr_timestamp       = st.getLong('assetRecordQueueCV'||strip(put(thisloc,z4.)),0);
                _Action              = strip(st.getString('assetRecordQueueCV'||strip(put(thisloc,z4.)),1));
                _AssetID             = strip(st.getString('assetRecordQueueCV'||strip(put(thisloc,z4.)),2));
                _AssetType           = strip(st.getString('assetRecordQueueCV'||strip(put(thisloc,z4.)),3));
                _AssetLabel          = strip(st.getString('assetRecordQueueCV'||strip(put(thisloc,z4.)),4));
                _OutputAssetRequired = strip(st.getString('assetRecordQueueCV'||strip(put(thisloc,z4.)),5));
 
                deleteVector ('assetRecordQueueCV'||strip(put(thisloc,z4.)));
 
                if _Msr_timestamp le _NextAssetInQueue or _NextAssetInQueue=. then do;
 
                  if _Action='add' or _Action='update' then do;
 
                    if checkIfVectorExists('asset|'||strip(_AssetID)) = 1 then do;
                      updateAsset(_AssetID,_AssetLabel,_OutputAssetRequired);
                    end;
                    else do;
                      addAsset(_AssetID,_AssetType,_AssetLabel,_OutputAssetRequired,'Y');
                    end;
 
                  end;
                  else if _Action='delete' then do;
 
                    /* do nothing - this should never occur since only adds are kept here */
 
                  end;
 
                  removeVector('assetRecordQueueCV'||strip(put(thisloc,z4.)));
 
                  updateAssetRecordQueueDetailCVL(i);
 
                end;
                else i=9999999999;
 
                i = i + 1;
 
              end;
 
            end;
 
          end;
 
          method runConsolidateCurrentValue(
            bigint  key1,
            bigint  triggerTimestamp,
            char(1) consolidateStatusAB,
            bigint  rawRecordCount,
            bigint  printRawQueueCount,
            bigint  printTriggerQueueCount,
            in_out  char(10) processRecordType,
            in_out  char(10) _outOpcode
          );
 
            declare bigint nextAssetInQueueCV nextAssetInQueue nextConnInQueue;
 
            _outOpcode='insert';
 
            /*** retrieve assetTypeList vector ***/
            numAssetTypes=0;
            getVector ('assetTypeList');
            numAssetTypes=st.getInt('assetTypeList',0);
 
            /*** iterate through each assetType ***/
            do cnt=1 to numAssetTypes;
 
              thisAssetType=strip(st.getString('assetTypeList',cnt));
 
              /*** retrieve assetList vector for this assetType ***/
              numAssets=0;
              getVector ('assetType|'||strip(thisAssetType)||'|assetList');
              numAssets=st.getInt('assetType|'||strip(thisAssetType)||'|assetList',0);
 
              /*** retrieve the attributes hash for this assetType ***/
              numAttributes=0;
              getVector ('assetType|'||strip(thisAssetType)||'|rawAttributeList');
              numAttributes=st.getInt('assetType|'||strip(thisAssetType)||'|rawAttributeList',0);
 
              /*** iterate through each asset for the assetType ***/
              do cnt2=1 to numAssets;
                thisAssetID=strip(st.getString('assetType|'||strip(thisAssetType)||'|assetList',cnt2));
 
                /*** iterate through each attributeID for the assetType ***/
                do cnt3=1 to numAttributes;
                  thisAttributeID=st.getString('assetType|'||strip(thisAssetType)||'|rawAttributeList',cnt3);
 
                  /*** pull information about the attribute ***/
                  attributeType      = '';
                  attributeLabel     = '';
                  dataType           = '';
                  dataLength         = .;
                  dataFormat         = '';
                  retentionPeriod     = .;
                  acceptableMin      = .;
                  acceptableMinLogic = '';
                  acceptableMax      = .;
                  acceptableMaxLogic = '';
                  historyMaxEvents   = .;
                  historyMaxTime     = .;
                  numHistory         = 0;
 
                  getVector ('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID));
 
                  attributeType      = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),0);
                  attributeLabel     = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),1);
                  dataType           = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),2);
                  dataLength         = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),3);
                  dataFormat         = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),4);
                  retentionPeriod     = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),5);
                  acceptableMin      = st.getDouble('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),6);
                  acceptableMinLogic = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),7);
                  acceptableMax      = st.getDouble('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),8);
                  acceptableMaxLogic = st.getString('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),9);
 
                  historyMaxEvents   = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),11);
                  historyMaxTime     = st.getInt('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID),12);
 
                  numHistory = int( (historyMaxTime * 1.0) / (@historyInterval@ * 1.0) );
 
                  deleteVector ('assetType|'||strip(thisAssetType)||'|attribute|'||strip(thisAttributeID));
 
                  loggerString = 'dataType is '||strip(dataType);
                  if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                  /*** retrieve currentValue ***/
                  currentValueTimestamp = .;
                  currentValueDouble    = .;
                  currentValueString    = '';
 
                  getVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
 
                  if dataType='double' then do;
                    currentValueTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2);
                    currentValueDouble    = st.getDouble('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3);
                    loggerString = 'Consolidating values - current value for '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' is '||strip(put(currentValueDouble,24.8))||' timestamp '||strip(put((currentValueTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
                  else if dataType='string' then do;
                    currentValueTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2);
                    currentValueString    = st.getString('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3);
                    loggerString = 'Consolidating values - current value for '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' is '||strip(currentValueString)||' timestamp '||strip(put((currentValueTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
 
                  /*** if timestamp is within validity window then keep it - if outside then set to missing ***/
                  if retentionPeriod gt 0 and (1.0*(triggerTimestamp - currentValueTimestamp)) gt (retentionPeriod * 1000000.0) then do;
                    loggerString = 'Stale value for current value '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' trigger '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' sensor '||strip(put((currentValueTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                    currentValueTimestamp = .;
                    currentValueDouble = .;
                    currentValueString = '';
                  end;
 
                  /*** retrieve lastValue ***/
                  lastValueTimestamp = .;
                  lastValueDouble    = .;
                  lastValueString    = '';
 
                  getVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
 
                  if dataType='double' then do;
                    lastValueTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue',2);
                    lastValueDouble    = st.getDouble('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3);
                    loggerString = 'Consolidating values - last value for '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' is '||strip(put(lastValueDouble,24.8))||' timestamp '||strip(put((lastValueTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
                  else if dataType='string' then do;
                    lastValueTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue',2);
                    lastValueString    = st.getString('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3);
                    loggerString = 'Consolidating values - last value for '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' is '||strip(lastValueString)||' timestamp '||strip(put((lastValueTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
 
                  /*** retrieve currentValueStorageX where X is not in use ***/
                  currentValueStorageTimestamp = .;
                  currentValueStorageDouble    = .;
                  currentValueStorageString    = '';
 
                  getVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorage'||strip(consolidateStatusAB));
 
                  if dataType='double' then do;
                    currentValueStorageTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorage'||strip(consolidateStatusAB),2);
                    currentValueStorageDouble    = st.getDouble('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorage'||strip(consolidateStatusAB),3);
                    loggerString = 'Consolidating values - new value for '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' is '||strip(put(currentValueStorageDouble,24.8))||' timestamp '||strip(put((currentValueStorageTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
                  else if dataType='string' then do;
                    currentValueStorageTimestamp = st.getLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorage'||strip(consolidateStatusAB),2);
                    currentValueStorageString    = st.getString('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorage'||strip(consolidateStatusAB),3);
                    loggerString = 'Consolidating values - new value for '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' is '||strip(currentValueStorageString)||' timestamp '||strip(put((currentValueStorageTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
                  end;
 
                  /*** keep the newest set of info for lastValue - done BEFORE retentionPeriod applied to the storage vector ***/
                  if currentValueStorageTimestamp ge 0 and currentValueStorageTimestamp ge max(0,lastValueTimestamp) then do;
                    lastValueTimestamp=currentValueStorageTimestamp;
                    if dataType='double' then do;
                      lastValueDouble=currentValueStorageDouble;
                    end;
                    else if dataType='string' then do;
                      lastValueString=currentValueStorageString;
                    end;
                  end;
 
                  /*** if timestamp is within validity window then keep it - if outside then set to missing ***/
                  if retentionPeriod gt 0 and (1.0*(triggerTimestamp - currentValueStorageTimestamp)) gt (retentionPeriod * 1000000.0) then do;
                    loggerString = 'Stale value for current value '||strip(thisAssetID)||' attributeID '||strip(thisAttributeID)||' trigger '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0))||' sensor '||strip(put((currentValueStorageTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
                    if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
                    currentValueStorageTimestamp = .;
                    currentValueStorageDouble = .;
                    currentValueStorageString = '';
                  end;
 
                  /*** keep the newest set of info for currentValue - done AFTER retentionPeriod applied ***/
                  if currentValueStorageTimestamp ge 0 and currentValueStorageTimestamp ge max(0,currentValueTimestamp) then do;
                    currentValueTimestamp=currentValueStorageTimestamp;
                    if dataType='double' then do;
                      currentValueDouble=currentValueStorageDouble;
                    end;
                    else if dataType='string' then do;
                      currentValueString=currentValueStorageString;
                    end;
                  end;
 
                  /* replace currentValue */
                  rc = st.setLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',2,currentValueTimestamp);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,currentValueDouble);
                  end;
                  else if dataType='string' then do;
                    rc = st.setString('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue',3,strip(currentValueString));
                  end;
                  replaceVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
                  deleteVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
 
                  /* replace lastValue */
                  rc = st.setLong('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue',2,lastValueTimestamp);
                  if dataType='double' then do;
                    rc = st.setDouble('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,lastValueDouble);
                  end;
                  else if dataType='string' then do;
                    rc = st.setString('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue',3,strip(lastValueString));
                  end;
                  replaceVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
                  deleteVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
 
                  /* delete currentValueStorage vector */
                  deleteVector ('asset|'||strip(thisAssetID)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorage'||strip(consolidateStatusAB));
 
                end;
              end;
              deleteVector ('assetType|'||strip(thisAssetType)||'|assetList');
              deleteVector ('assetType|'||strip(thisAssetType)||'|rawAttributeList');
 
            end;
            deleteVector ('assetTypeList');
 
            /* update symUpdateNeeded to define how creation of output tables should be done */
            getVector ('symUpdateNeeded');
            if isFirstOutput = 1 then do;
              rc = st.setInt('symUpdateNeeded',0,1);
            end;
            else do;
              /* check if any asset updates are needed before further processing occurs */
              /* check if any connection updates are needed before further processing occurs */
              nextAssetInQueue = checkNextAssetInQueue();
              nextAssetInQueueCV = checkNextAssetInQueueCV();
              nextConnInQueue = checkNextConnectionInQueue();
              if 0 lt nextAssetInQueue le triggerTimestamp then do;
                rc = st.setInt('symUpdateNeeded',0,1);
              end;
              else if 0 lt nextAssetInQueueCV le triggerTimestamp then do;
                rc = st.setInt('symUpdateNeeded',0,1);
              end;
              else if 0 lt nextConnInQueue le triggerTimestamp then do;
                rc = st.setInt('symUpdateNeeded',0,1);
              end;
            end;
            replaceVector ('symUpdateNeeded');
            deleteVector ('symUpdateNeeded');
 
            /*** check if history period and output period - or just history period ***/
            if mod(int(triggerTimestamp/1000000.0),@outputInterval@)=0 then do;
 
              processRecordType = 'output';
 
              /* update when to outputRecordsToABT */
              /* if first output after skipped records, then need to make sure to assign symlinks */
              /* since this would not have been done */
              if startedOutputToABT=0 then do;
                if triggerTimestamp ge initialOutputUTC then do;
 
                  getVector ('outputRecordsToABT');
                  rc = st.setString('outputRecordsToABT',0,'Y');
                  replaceVector ('outputRecordsToABT');
                  deleteVector ('outputRecordsToABT');
 
                  getVector ('symUpdateNeeded');
                  rc = st.setInt('symUpdateNeeded',0,1);
                  replaceVector ('symUpdateNeeded');
                  deleteVector ('symUpdateNeeded');
 
                  startedOutputToABT=1;
                end;
              end;
 
              getVector ('rawRecordCount');
              rc = st.setLong('rawRecordCount',0,rawRecordCount);
              replaceVector ('rawRecordCount');
              deleteVector ('rawRecordCount');
 
              getVector ('printRawQueueCount');
              rc = st.setLong('printRawQueueCount',0,printRawQueueCount);
              replaceVector ('printRawQueueCount');
              deleteVector ('printRawQueueCount');
 
              getVector ('printTriggerQueueCount');
              rc = st.setLong('printTriggerQueueCount',0,printTriggerQueueCount);
              replaceVector ('printTriggerQueueCount');
              deleteVector ('printTriggerQueueCount');
 
              /* process any asset updates that are needed before further processing occurs */
              /* do adds from current values first */
              nextAssetInQueueCV = checkNextAssetInQueueCV();
              if 0 lt nextAssetInQueueCV le triggerTimestamp then do;
                processAssetQueueThroughCV(triggerTimestamp);
              end;
 
              nextAssetInQueue = checkNextAssetInQueue();
              if 0 lt nextAssetInQueue le triggerTimestamp then do;
                processAssetQueueThrough(triggerTimestamp);
              end;
 
              /* process any connection updates that are needed before further processing occurs */
              nextConnInQueue = checkNextConnectionInQueue();
              if 0 lt nextConnInQueue le triggerTimestamp then do;
                processConnQueueThrough(triggerTimestamp);
              end;
 
              /* determine which output asset types actually have assets */
              numOutputAssetTypes=0;
              numOutputAssetTypesTHIS=0;
              getVector ('outputAssetTypeList');
              getVector ('outputAssetTypeListTHIS');
              numOutputAssetTypes=st.getInt('outputAssetTypeList',0);
              do cnt=1 to numOutputAssetTypes;
                thisAssetType = strip(st.getString('outputAssetTypeList',cnt));
 
                getVector ('assetType|'||strip(thisAssetType)||'|outputAssetList');
                numOutputAssets=st.getInt('assetType|'||strip(thisAssetType)||'|outputAssetList',0);
 
                if numOutputAssets gt 0 then do;
                  numOutputAssetTypesTHIS=numOutputAssetTypesTHIS+1;
                  rc = st.setString('outputAssetTypeListTHIS',numOutputAssetTypesTHIS,strip(thisAssetType));
                end;
 
                deleteVector ('assetType|'||strip(thisAssetType)||'|outputAssetList');
              end;
              do cnt=(numOutputAssetTypesTHIS+1) to 101;
                rc = st.setString('outputAssetTypeListTHIS',cnt,'');
              end;
              rc = st.setInt('outputAssetTypeListTHIS',0,numOutputAssetTypesTHIS);
              replaceVector ('outputAssetTypeListTHIS');
              deleteVector ('outputAssetTypeList');
              deleteVector ('outputAssetTypeListTHIS');
 
            end;
            else do;
 
              processRecordType = 'history';
 
              /*** set outputInProgress to false ***/
              getVector ('outputInProgress');
 
              rc = st.setString('outputInProgress',0,'false');
 
              replaceVector ('outputInProgress');
              deleteVector ('outputInProgress');
 
              loggerString = 'NOTE: History processing complete for '||strip(put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
              if '@logLevel@' in ('luaDebug') then writeTo.log('i', loggerString);
            end;
 
            isFirstOutput = 0;
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="enrichDataModelStartModule" language="ds2" func-names="runEnrichDataModelStart">
      <code><![CDATA[ds2_options sas;
 
        package enrichDataModelStartPackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep;
          declare bigint lastHistoricalTimestamp;
          declare integer   cnt cnt2;
          declare integer   numAssetTypes numAssets numRawAttributes numAttributes numHierarchies;
          declare integer   dataLength historyMaxEvents historyMaxTime retentionPeriod numHistory;
          declare double    acceptableMin acceptableMax;
          declare char(20)  attributeType dataType dataFormat acceptableMinLogic acceptableMaxLogic;
          declare char(100) attributeLabel;
          declare integer   foundAssetType foundAsset;
          declare char(100) thisAttributeID;
          declare char(75)  thisAssetType;
          declare char(25)  thisHierarchyName;
          declare integer   numParents foundParent numChildren foundChild numOutputAssets foundHierarchy;
          declare char(300) thisParentAssetID thisChildAssetID;
          declare bigint    nextAssetInQueue nextConnInQueue numOutputAssetTypes numOutputAssetTypesTHIS;
          declare integer   numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method runEnrichDataModelStart(bigint key1,
                                         bigint triggerTimestamp,
                                         char(10) processRecordType,
                                         in_out char(10) _outOpcode);
 
            /*** check if history period and output period - or just history period ***/
            if processRecordType='output' then do;
 
              /*** if this is an output period then let the trigger through ***/
              _outOpcode='insert';
 
              loggerString = 'NOTE: '||put(datetime(),24.6)||' Beginning processing of output record(s) - '||put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0)||'.';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            end;
            else do;
 
              /*** if this is only a history period, then stop the trigger here ***/
              _outOpcode='delete';
 
              loggerString = 'NOTE: Completed history-only processing for - '||put((triggerTimestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0)||'.';
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            end;
 
          end;
 
        endpackage;]]></code>
    </mas-module>
<mas-module module="gateModule_station_expectedNextTrain1ID" language="ds2" func-names="runGate_station_expectedNextTrain1ID">
<code><![CDATA[ds2_options sas;
 
package gatePackage_station_expectedNextTrain1ID / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_station_expectedNextTrain1ID(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=1;
numRequirements=2;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_station_prevStationTrain1' then thisRequirementNum=1;
else if previousWindowName='compute_station_prevTrackTrain1' then thisRequirementNum=2;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_station_expectedNextTrain1Time" language="ds2" func-names="runGate_station_expectedNextTrain1Time">
<code><![CDATA[ds2_options sas;
 
package gatePackage_station_expectedNextTrain1Time / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_station_expectedNextTrain1Time(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=2;
numRequirements=3;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_station_prevStationTrain1' then thisRequirementNum=1;
else if previousWindowName='compute_station_prevTrackTrain1' then thisRequirementNum=2;
else if previousWindowName='compute_station_prevTrackTravelTime' then thisRequirementNum=3;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_station_expectedNextTrain2ID" language="ds2" func-names="runGate_station_expectedNextTrain2ID">
<code><![CDATA[ds2_options sas;
 
package gatePackage_station_expectedNextTrain2ID / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_station_expectedNextTrain2ID(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=3;
numRequirements=4;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_station_prevStationTrain1' then thisRequirementNum=1;
else if previousWindowName='compute_station_prevStationTrain2' then thisRequirementNum=2;
else if previousWindowName='compute_station_prevTrackTrain1' then thisRequirementNum=3;
else if previousWindowName='compute_station_prevTrackTrain2' then thisRequirementNum=4;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_station_expectedNextTrain2Time" language="ds2" func-names="runGate_station_expectedNextTrain2Time">
<code><![CDATA[ds2_options sas;
 
package gatePackage_station_expectedNextTrain2Time / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_station_expectedNextTrain2Time(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=4;
numRequirements=6;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_station_expectedNextTrain1Time' then thisRequirementNum=1;
else if previousWindowName='compute_station_prevStationTrain1' then thisRequirementNum=2;
else if previousWindowName='compute_station_prevStationTrain2' then thisRequirementNum=3;
else if previousWindowName='compute_station_prevTrackTrain1' then thisRequirementNum=4;
else if previousWindowName='compute_station_prevTrackTrain2' then thisRequirementNum=5;
else if previousWindowName='compute_station_prevTrackTravelTime' then thisRequirementNum=6;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_station_prevTrackTravelTime" language="ds2" func-names="runGate_station_prevTrackTravelTime">
<code><![CDATA[ds2_options sas;
 
package gatePackage_station_prevTrackTravelTime / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_station_prevTrackTravelTime(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=5;
numRequirements=2;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_station_prevTrack' then thisRequirementNum=1;
else if previousWindowName='compute_track_travelTimeRollingAvg' then thisRequirementNum=2;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_station_waitTime" language="ds2" func-names="runGate_station_waitTime">
<code><![CDATA[ds2_options sas;
 
package gatePackage_station_waitTime / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_station_waitTime(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=6;
numRequirements=3;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_station_lastDepartedTrainArrivalTime' then thisRequirementNum=1;
else if previousWindowName='compute_station_lastDepartedTrainStatus' then thisRequirementNum=2;
else if previousWindowName='compute_station_lastDepartedTrainTime' then thisRequirementNum=3;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_track_travelTime" language="ds2" func-names="runGate_track_travelTime">
<code><![CDATA[ds2_options sas;
 
package gatePackage_track_travelTime / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_track_travelTime(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=7;
numRequirements=3;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_track_lastEnrouteTrainEnd' then thisRequirementNum=1;
else if previousWindowName='compute_track_lastEnrouteTrainStart' then thisRequirementNum=2;
else if previousWindowName='compute_track_lastEnrouteTrainStatus' then thisRequirementNum=3;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_train_trainLatitude" language="ds2" func-names="runGate_train_trainLatitude">
<code><![CDATA[ds2_options sas;
 
package gatePackage_train_trainLatitude / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_train_trainLatitude(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=8;
numRequirements=2;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_track_enrouteTrain1' then thisRequirementNum=1;
else if previousWindowName='compute_track_enrouteTrain2' then thisRequirementNum=2;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="gateModule_train_trainLongitude" language="ds2" func-names="runGate_train_trainLongitude">
<code><![CDATA[ds2_options sas;
 
package gatePackage_train_trainLongitude / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runGate_train_trainLongitude(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=9;
numRequirements=2;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_track_enrouteTrain1' then thisRequirementNum=1;
else if previousWindowName='compute_track_enrouteTrain2' then thisRequirementNum=2;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_expectedNextTrain1ID" language="ds2" func-names="runCompute_station_expectedNextTrain1ID">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_expectedNextTrain1ID / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
 
declare char(50) expectedNextTrain1ID;
declare char(50) prevStationTrain1;
declare char(50) prevTrackTrain1;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='station';
attributeID='expectedNextTrain1ID';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_expectedNextTrain1ID';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_station_expectedNextTrain1ID(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'station','prevStationTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevStationTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTrain1 = thisFoundStringResult;
 
 
if strip(prevTrackTrain1) ne '' then expectedNextTrain1ID=strip(prevTrackTrain1);
else if strip(prevStationTrain1) ne '' then expectedNextTrain1ID=strip(prevStationTrain1);
else expectedNextTrain1ID='';
 
 
myNewStringValue = expectedNextTrain1ID;
 
end;
 
method runCompute_station_expectedNextTrain1ID(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_expectedNextTrain1ID';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_expectedNextTrain1ID(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_expectedNextTrain1Time" language="ds2" func-names="runCompute_station_expectedNextTrain1Time">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_expectedNextTrain1Time / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
 
declare char(50) expectedNextTrain1Time;
declare char(50) prevStationTrain1;
declare char(50) prevTrackTrain1;
declare double prevTrackTravelTime;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='station';
attributeID='expectedNextTrain1Time';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_expectedNextTrain1Time';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_station_expectedNextTrain1Time(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'station','prevStationTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevStationTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTravelTime','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTravelTime = thisFoundDoubleResult;
 
 
if strip(prevTrackTrain1) ne '' then expectedNextTrain1Time='1 minute';
else if strip(prevStationTrain1) ne '' then do;
if prevTrackTravelTime gt 0 then do;
expectedNextTrain1Time=strip(put(ceil(prevTrackTravelTime/60.0),8.0))||' minutes';
end;
else do;
expectedNextTrain1Time='2 minutes';
end;
end;
else expectedNextTrain1Time='';
 
 
myNewStringValue = expectedNextTrain1Time;
 
end;
 
method runCompute_station_expectedNextTrain1Time(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_expectedNextTrain1Time';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_expectedNextTrain1Time(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_expectedNextTrain2ID" language="ds2" func-names="runCompute_station_expectedNextTrain2ID">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_expectedNextTrain2ID / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
declare double countPrevTrack;
declare double countPrevStation;
 
declare char(50) expectedNextTrain2ID;
declare char(50) prevStationTrain1;
declare char(50) prevStationTrain2;
declare char(50) prevTrackTrain1;
declare char(50) prevTrackTrain2;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='station';
attributeID='expectedNextTrain2ID';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_expectedNextTrain2ID';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_station_expectedNextTrain2ID(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'station','prevStationTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevStationTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevStationTrain2','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevStationTrain2 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTrain2','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTrain2 = thisFoundStringResult;
 
 
expectedNextTrain2ID='';
 
countPrevTrack=0;
if strip(prevTrackTrain1) ne '' then countPrevTrack=countPrevTrack+1;
if strip(prevTrackTrain2) ne '' then countPrevTrack=countPrevTrack+1;
 
countPrevStation=0;
if strip(prevStationTrain1) ne '' then countPrevStation=countPrevStation+1;
if strip(prevStationTrain2) ne '' then countPrevStation=countPrevStation+1;
 
if countPrevTrack=2 then do;
expectedNextTrain2ID=strip(prevTrackTrain2);
end;
else if countPrevTrack=1 then do;
if countPrevStation ge 1 then do;
expectedNextTrain2ID=strip(prevStationTrain1);
end;
end;
else if countPrevTrack=0 then do;
if countPrevStation ge 2 then do;
expectedNextTrain2ID=strip(prevStationTrain2);
end;
end;
 
 
myNewStringValue = expectedNextTrain2ID;
 
end;
 
method runCompute_station_expectedNextTrain2ID(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_expectedNextTrain2ID';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_expectedNextTrain2ID(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_expectedNextTrain2Time" language="ds2" func-names="runCompute_station_expectedNextTrain2Time">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_expectedNextTrain2Time / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
declare double countPrevTrack;
declare double countPrevStation;
declare double expectedTrain1TimeN;
declare double expectedTrain2TimeN;
 
declare char(50) expectedNextTrain2Time;
declare char(50) expectedNextTrain1Time;
declare char(50) prevStationTrain1;
declare char(50) prevStationTrain2;
declare char(50) prevTrackTrain1;
declare char(50) prevTrackTrain2;
declare double prevTrackTravelTime;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='station';
attributeID='expectedNextTrain2Time';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_expectedNextTrain2Time';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_station_expectedNextTrain2Time(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'station','expectedNextTrain1Time','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
expectedNextTrain1Time = thisFoundStringResult;
getAttributeValue(assetID,'station','prevStationTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevStationTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevStationTrain2','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevStationTrain2 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTrain2','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTrain2 = thisFoundStringResult;
getAttributeValue(assetID,'station','prevTrackTravelTime','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
prevTrackTravelTime = thisFoundDoubleResult;
 
 
expectedNextTrain2Time='';
 
countPrevTrack=0;
if strip(prevTrackTrain1) ne '' then countPrevTrack=countPrevTrack+1;
if strip(prevTrackTrain2) ne '' then countPrevTrack=countPrevTrack+1;
 
countPrevStation=0;
if strip(prevStationTrain1) ne '' then countPrevStation=countPrevStation+1;
if strip(prevStationTrain2) ne '' then countPrevStation=countPrevStation+1;
 
if countPrevTrack=2 then do;
expectedNextTrain2Time='2 minutes';
end;
else if countPrevTrack=1 then do;
if countPrevStation ge 1 then do;
if prevTrackTravelTime gt 0 then do;
expectedNextTrain2Time=strip(put(1.0+ceil(prevTrackTravelTime/60.0),8.0))||' minutes';
end;
else do;
expectedNextTrain2Time='3 minutes';
end;
end;
end;
else if countPrevTrack=0 then do;
if countPrevStation ge 2 then do;
if prevTrackTravelTime gt 0 then do;
expectedNextTrain2Time=strip(put(2.0+ceil(prevTrackTravelTime/60.0),8.0))||' minutes';
end;
else do;
expectedNextTrain2Time='4 minutes';
end;
end;
end;
 
if strip(expectedNextTrain1Time) ne '' and strip(expectedNextTrain2Time) ne '' then do;
expectedTrain1TimeN = inputn(scan(expectedNextTrain1Time,1,' '),8.0);
expectedTrain2TimeN = inputn(scan(expectedNextTrain2Time,1,' '),8.0);
 
if expectedTrain1TimeN gt 0 and
expectedTrain2TimeN gt 0 and
expectedTrain2TimeN le expectedTrain1TimeN then do;
expectedNextTrain2Time=strip(put(expectedTrain1TimeN+1.0,8.0))||' minutes';
end;
end;
 
 
myNewStringValue = expectedNextTrain2Time;
 
end;
 
method runCompute_station_expectedNextTrain2Time(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_expectedNextTrain2Time';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_expectedNextTrain2Time(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_waitTime" language="ds2" func-names="runCompute_station_waitTime">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_waitTime / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
declare double countPrevTrack;
declare double countPrevStation;
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
 
declare double waitTime;
declare double lastDepartedTrainArrivalTime;
declare char(50) lastDepartedTrainStatus;
declare double lastDepartedTrainTime;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='station';
attributeID='waitTime';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_waitTime';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_station_waitTime(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'station','lastDepartedTrainArrivalTime','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
lastDepartedTrainArrivalTime = thisFoundDoubleResult;
getAttributeValue(assetID,'station','lastDepartedTrainStatus','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
lastDepartedTrainStatus = thisFoundStringResult;
getAttributeValue(assetID,'station','lastDepartedTrainTime','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
lastDepartedTrainTime = thisFoundDoubleResult;
 
 
if find(lastDepartedTrainStatus, 'arrived') = 1 or find(lastDepartedTrainStatus, 'completed') = 1 then do;
if lastDepartedTrainArrivalTime gt 0 and lastDepartedTrainTime gt 0 then do;
waitTime = (lastDepartedTrainTime - lastDepartedTrainArrivalTime) / 1000000.0;
end;
else do;
waitTime=.;
end;
end;
else do;
waitTime=.;
end;
 
if waitTime le 0 then waitTime=.;
 
 
if strip(prevTrackTrain1) ne '' then expectedNextTrain1Time='1 minute';
else if strip(prevStationTrain1) ne '' then expectedNextTrain1Time='2 minutes';
else expectedNextTrain1Time='';
 
 
myNewDoubleValue = waitTime;
 
end;
 
method runCompute_station_waitTime(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_waitTime';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_waitTime(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_travelTime" language="ds2" func-names="runCompute_track_travelTime">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_travelTime / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
declare double countPrevTrack;
declare double countPrevStation;
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
 
declare double travelTime;
declare double lastEnrouteTrainEnd;
declare double lastEnrouteTrainStart;
declare char(50) lastEnrouteTrainStatus;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='track';
attributeID='travelTime';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_travelTime';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_track_travelTime(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'track','lastEnrouteTrainEnd','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
lastEnrouteTrainEnd = thisFoundDoubleResult;
getAttributeValue(assetID,'track','lastEnrouteTrainStart','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
lastEnrouteTrainStart = thisFoundDoubleResult;
getAttributeValue(assetID,'track','lastEnrouteTrainStatus','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
lastEnrouteTrainStatus = thisFoundStringResult;
 
 
if find(lastEnrouteTrainStatus, 'arrived') = 1 or find(lastEnrouteTrainStatus, 'completed') = 1 then do;
if lastEnrouteTrainStart gt 0 and lastEnrouteTrainEnd gt 0 then do;
travelTime = (lastEnrouteTrainEnd - lastEnrouteTrainStart) / 1000000.0;
end;
else do;
travelTime=.;
end;
end;
else do;
travelTime=.;
end;
 
if travelTime le 0 then travelTime=.;
 
 
if strip(prevTrackTrain1) ne '' then expectedNextTrain1Time='1 minute';
else if strip(prevStationTrain1) ne '' then expectedNextTrain1Time='2 minutes';
else expectedNextTrain1Time='';
 
 
myNewDoubleValue = travelTime;
 
end;
 
method runCompute_track_travelTime(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_travelTime';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_travelTime(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_train_trainLatitude" language="ds2" func-names="runCompute_train_trainLatitude">
<code><![CDATA[ds2_options sas;
 
package computePackage_train_trainLatitude / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
declare double countPrevTrack;
declare double countPrevStation;
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
 
declare double trainLatitude;
declare double stationLatitude;
declare char(50) enrouteTrain1;
declare char(50) enrouteTrain2;
declare double trackLatitude;
declare double trackLatitude1;
declare char(50) currentLocation;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='train';
attributeID='trainLatitude';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_train_trainLatitude';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_train_trainLatitude(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'station','stationLatitude','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
stationLatitude = thisFoundDoubleResult;
getAttributeValue(assetID,'track','enrouteTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
enrouteTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'track','enrouteTrain2','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
enrouteTrain2 = thisFoundStringResult;
getAttributeValue(assetID,'track','trackLatitude','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
trackLatitude = thisFoundDoubleResult;
getAttributeValue(assetID,'track','trackLatitude1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
trackLatitude1 = thisFoundDoubleResult;
getAttributeValue(assetID,'train','currentLocation','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
currentLocation = thisFoundStringResult;
 
 
if currentLocation='' then do;
trainLatitude=.;
end;
else if find(currentLocation,'enroute')=1 then do;
if assetID=enrouteTrain1 then do;
trainLatitude=trackLatitude;
end;
else do;
trainLatitude=trackLatitude1;
end;
end;
else do;
trainLatitude=stationLatitude;
end;
 
 
if strip(prevTrackTrain1) ne '' then expectedNextTrain1Time='1 minute';
else if strip(prevStationTrain1) ne '' then expectedNextTrain1Time='2 minutes';
else expectedNextTrain1Time='';
 
 
myNewDoubleValue = trainLatitude;
 
end;
 
method runCompute_train_trainLatitude(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_train_trainLatitude';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_train_trainLatitude(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_train_trainLongitude" language="ds2" func-names="runCompute_train_trainLongitude">
<code><![CDATA[ds2_options sas;
 
package computePackage_train_trainLongitude / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) assetType;
declare char(100) attributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
declare double countPrevTrack;
declare double countPrevStation;
 
 
/* insert supporting variable declarations here, if applicable */
/* for example... declare double mySupportingVariable; */
 
declare double trainLongitude;
declare double stationLongitude;
declare char(50) enrouteTrain1;
declare char(50) enrouteTrain2;
declare double trackLongitude;
declare double trackLongitude1;
declare char(50) currentLocation;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
assetType='train';
attributeID='trainLongitude';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_train_trainLongitude';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
/* insert DS2 code to include in the the init method here, if applicable */
 
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
/* insert supporting method definitions as DS2 code here, if applicable */
 
 
method calculate_train_trainLongitude(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
getAttributeValue(assetID,'station','stationLongitude','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
stationLongitude = thisFoundDoubleResult;
getAttributeValue(assetID,'track','enrouteTrain1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
enrouteTrain1 = thisFoundStringResult;
getAttributeValue(assetID,'track','enrouteTrain2','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
enrouteTrain2 = thisFoundStringResult;
getAttributeValue(assetID,'track','trackLongitude','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
trackLongitude = thisFoundDoubleResult;
getAttributeValue(assetID,'track','trackLongitude1','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
trackLongitude1 = thisFoundDoubleResult;
getAttributeValue(assetID,'train','currentLocation','currentValue','navigate','','','Y',maxTraversals,'N',maxTraversals,'N',thisFoundDoubleResult,thisFoundStringResult);
currentLocation = thisFoundStringResult;
 
 
if currentLocation='' then do;
trainLongitude=.;
end;
else if find(currentLocation,'enroute')=1 then do;
if assetID=enrouteTrain1 then do;
trainLongitude=trackLongitude;
end;
else do;
trainLongitude=trackLongitude1;
end;
end;
else do;
trainLongitude=stationLongitude;
end;
 
 
if strip(prevTrackTrain1) ne '' then expectedNextTrain1Time='1 minute';
else if strip(prevStationTrain1) ne '' then expectedNextTrain1Time='2 minutes';
else expectedNextTrain1Time='';
 
 
myNewDoubleValue = trainLongitude;
 
end;
 
method runCompute_train_trainLongitude(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_train_trainLongitude';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_train_trainLongitude(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_numTrainsAtNextStation" language="ds2" func-names="runCompute_station_numTrainsAtNextStation">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_numTrainsAtNextStation / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='countConn';
assetType='station';
attributeID='numTrainsAtNextStation';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
queryAssetIDFromThisAttribID='nextStation';
SASAttributeID='numTrainsAtNextStation';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_numTrainsAtNextStation';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_numTrainsAtNextStation(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query the number of connections for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
 
end;
 
end;
 
method runCompute_station_numTrainsAtNextStation(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_numTrainsAtNextStation';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_numTrainsAtNextStation(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_numTrainsAtPrevStation" language="ds2" func-names="runCompute_station_numTrainsAtPrevStation">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_numTrainsAtPrevStation / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='countConn';
assetType='station';
attributeID='numTrainsAtPrevStation';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
queryAssetIDFromThisAttribID='prevStation';
SASAttributeID='numTrainsAtPrevStation';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_numTrainsAtPrevStation';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_numTrainsAtPrevStation(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query the number of connections for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
 
end;
 
end;
 
method runCompute_station_numTrainsAtPrevStation(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_numTrainsAtPrevStation';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_numTrainsAtPrevStation(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_numTrainsEnrouteFromThis" language="ds2" func-names="runCompute_station_numTrainsEnrouteFromThis">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_numTrainsEnrouteFromThis / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='countConn';
assetType='station';
attributeID='numTrainsEnrouteFromThis';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
queryAssetIDFromThisAttribID='nextTrack';
SASAttributeID='numTrainsEnrouteFromThis';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_numTrainsEnrouteFromThis';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_numTrainsEnrouteFromThis(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query the number of connections for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
 
end;
 
end;
 
method runCompute_station_numTrainsEnrouteFromThis(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_numTrainsEnrouteFromThis';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_numTrainsEnrouteFromThis(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_numTrainsEnrouteToThis" language="ds2" func-names="runCompute_station_numTrainsEnrouteToThis">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_numTrainsEnrouteToThis / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='countConn';
assetType='station';
attributeID='numTrainsEnrouteToThis';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
queryAssetIDFromThisAttribID='prevTrack';
SASAttributeID='numTrainsEnrouteToThis';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_numTrainsEnrouteToThis';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_numTrainsEnrouteToThis(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query the number of connections for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('_ALL_','') then connectionsThisAssetType=connectionsThisAssetType+1;
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
myNewDoubleValue = connectionsThisAssetType;
 
end;
 
end;
 
end;
 
method runCompute_station_numTrainsEnrouteToThis(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_numTrainsEnrouteToThis';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_numTrainsEnrouteToThis(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_nextStationTrain1" language="ds2" func-names="runCompute_station_nextStationTrain1">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_nextStationTrain1 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='nextStationTrain1';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='1';
searchLogic='oldest';
queryAssetIDFromThisAttribID='nextStation';
SASAttributeID='nextStationTrain1';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_nextStationTrain1';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_nextStationTrain1(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_nextStationTrain1(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_nextStationTrain1';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_nextStationTrain1(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_nextStationTrain2" language="ds2" func-names="runCompute_station_nextStationTrain2">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_nextStationTrain2 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='nextStationTrain2';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='2';
searchLogic='oldest';
queryAssetIDFromThisAttribID='nextStation';
SASAttributeID='nextStationTrain2';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_nextStationTrain2';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_nextStationTrain2(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_nextStationTrain2(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_nextStationTrain2';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_nextStationTrain2(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_nextTrackTrain1" language="ds2" func-names="runCompute_station_nextTrackTrain1">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_nextTrackTrain1 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='nextTrackTrain1';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='1';
searchLogic='oldest';
queryAssetIDFromThisAttribID='nextTrack';
SASAttributeID='nextTrackTrain1';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_nextTrackTrain1';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_nextTrackTrain1(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_nextTrackTrain1(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_nextTrackTrain1';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_nextTrackTrain1(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_nextTrackTrain2" language="ds2" func-names="runCompute_station_nextTrackTrain2">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_nextTrackTrain2 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='nextTrackTrain2';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='2';
searchLogic='oldest';
queryAssetIDFromThisAttribID='nextTrack';
SASAttributeID='nextTrackTrain2';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_nextTrackTrain2';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_nextTrackTrain2(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_nextTrackTrain2(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_nextTrackTrain2';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_nextTrackTrain2(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_prevStationTrain1" language="ds2" func-names="runCompute_station_prevStationTrain1">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_prevStationTrain1 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='prevStationTrain1';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='1';
searchLogic='oldest';
queryAssetIDFromThisAttribID='prevStation';
SASAttributeID='prevStationTrain1';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_prevStationTrain1';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_prevStationTrain1(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_prevStationTrain1(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_prevStationTrain1';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_prevStationTrain1(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_prevStationTrain2" language="ds2" func-names="runCompute_station_prevStationTrain2">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_prevStationTrain2 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='prevStationTrain2';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='2';
searchLogic='oldest';
queryAssetIDFromThisAttribID='prevStation';
SASAttributeID='prevStationTrain2';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_prevStationTrain2';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_prevStationTrain2(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_prevStationTrain2(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_prevStationTrain2';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_prevStationTrain2(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_prevTrackTrain1" language="ds2" func-names="runCompute_station_prevTrackTrain1">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_prevTrackTrain1 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='prevTrackTrain1';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='1';
searchLogic='oldest';
queryAssetIDFromThisAttribID='prevTrack';
SASAttributeID='prevTrackTrain1';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_prevTrackTrain1';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_prevTrackTrain1(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_prevTrackTrain1(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_prevTrackTrain1';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_prevTrackTrain1(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_prevTrackTrain2" language="ds2" func-names="runCompute_station_prevTrackTrain2">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_prevTrackTrain2 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='prevTrackTrain2';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='2';
searchLogic='oldest';
queryAssetIDFromThisAttribID='prevTrack';
SASAttributeID='prevTrackTrain2';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_prevTrackTrain2';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_prevTrackTrain2(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_prevTrackTrain2(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_prevTrackTrain2';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_prevTrackTrain2(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_trainInStation" language="ds2" func-names="runCompute_station_trainInStation">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_trainInStation / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='station';
attributeID='trainInStation';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='1';
searchLogic='oldest';
queryAssetIDFromThisAttribID='';
SASAttributeID='trainInStation';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_trainInStation';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_trainInStation(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_station_trainInStation(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_trainInStation';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_trainInStation(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_enrouteTrain1" language="ds2" func-names="runCompute_track_enrouteTrain1">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_enrouteTrain1 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='track';
attributeID='enrouteTrain1';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='1';
searchLogic='oldest';
queryAssetIDFromThisAttribID='';
SASAttributeID='enrouteTrain1';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_enrouteTrain1';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_track_enrouteTrain1(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_track_enrouteTrain1(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_enrouteTrain1';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_enrouteTrain1(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_enrouteTrain2" language="ds2" func-names="runCompute_track_enrouteTrain2">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_enrouteTrain2 / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) parentsOrChildren;
declare char(100) subsetAssetType;
declare char(100) instanceNumber;
declare char(100) searchLogic;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   cntIter connectionsThisAssetType totalCountConnections numInstances;
declare char(300) thisConnAssetID;
declare char(75)  thisConnAssetType;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getConn';
assetType='track';
attributeID='enrouteTrain2';
hierarchyValue='';
hierarchyAttributeID='route';
parentsOrChildren='children';
subsetAssetType='train';
instanceNumber='2';
searchLogic='oldest';
queryAssetIDFromThisAttribID='';
SASAttributeID='enrouteTrain2';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_enrouteTrain2';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_track_enrouteTrain2(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) parentsOrChildren */
/* char(100) subsetAssetType */
/* char(100) instanceNumber */
/* char(100) searchLogic */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* if the hierarchy will come from another attribute then get it */
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* now query to obtain the connection ID for the specified assetID */
if strip(queryAssetIDFromHere)='' or strip(useThisHierarchy)='' then do;
 
/* no assignment needed - result in missing */
 
end;
else do;
 
if strip(upcase(parentsOrChildren))='PARENTS' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|parents|'||strip(useThisHierarchy));
 
end;
else if strip(upcase(parentsOrChildren))='CHILDREN' then do;
 
getVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
totalCountConnections=1.0 * st.getInt('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),0);
 
/* now keep only if the asset type matches */
connectionsThisAssetType=0;
 
if strip(searchLogic)='oldest' then do;
 
do cntIter=1 to totalCountConnections;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
else do;
 
do cntIter=totalCountConnections to 1 by -1;
thisConnAssetID = strip(st.getString('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy),cntIter));
 
getVector ('asset|'||strip(thisConnAssetID));
thisConnAssetType  = st.getString('asset|'||strip(thisConnAssetID),0);
deleteVector ('asset|'||strip(thisConnAssetID));
 
if strip(thisConnAssetType)=strip(subsetAssetType) or strip(upcase(subsetAssetType)) in ('','_ALL_') then connectionsThisAssetType=connectionsThisAssetType+1;
 
if connectionsThisAssetType=numInstances then myNewStringValue = thisConnAssetID;
end;
 
end;
 
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|children|'||strip(useThisHierarchy));
 
end;
end;
 
end;
 
method runCompute_track_enrouteTrain2(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_enrouteTrain2';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_enrouteTrain2(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_lastDepartedTrainStatus" language="ds2" func-names="runCompute_station_lastDepartedTrainStatus">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_lastDepartedTrainStatus / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAssetType;
declare char(100) targetAttributeID;
declare char(100) targetAttributeMetric;
declare char(100) navMethod;
declare char(100) attribIDContainingKnownAssetID;
declare char(100) chkThisAssetYN;
declare char(100) maxUpTrav;
declare char(100) exactUpYN;
declare char(100) maxDownTrav;
declare char(100) exactDownYN;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   maxUpTravN maxDownTravN;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getValue';
assetType='station';
attributeID='lastDepartedTrainStatus';
targetAssetType='train';
targetAttributeID='currentStatus';
targetAttributeMetric='currentValue';
navMethod='knownassetid';
attribIDContainingKnownAssetID='lastDepartedTrain';
chkThisAssetYN='N';
maxUpTrav='0';
exactUpYN='N';
maxDownTrav='0';
exactDownYN='N';
hierarchyValue='';
hierarchyAttributeID='';
SASAttributeID='lastDepartedTrainStatus';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_lastDepartedTrainStatus';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_lastDepartedTrainStatus(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeID */
/* char(100) targetAssetType */
/* char(100) targetAttributeID */
/* char(100) targetAttributeMetric */
/* char(100) navMethod */
/* char(100) attribIDContainingKnownAssetID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) chkThisAssetYN */
/* char(100) maxUpTrav */
/* char(100) exactUpYN */
/* char(100) maxDownTrav */
/* char(100) exactDownYN */
 
/* store the traversal distances as integers */
maxUpTravN=.;
maxDownTravN=.;
if strip(maxUpTrav) = '' then  maxUpTravN   = maxTraversals;
else                           maxUpTravN   = inputn(maxUpTrav,'8.0');
if strip(maxDownTrav) ='' then maxDownTravN = maxTraversals;
else                           maxDownTravN = inputn(maxDownTrav,'8.0');
 
/* if the hierarchy will come from another attribute then get it */
useThisHierarchy='';
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* pull the value needed */
getAttributeValue(assetID,targetAssetType,targetAttributeID,targetAttributeMetric,
navMethod,attribIDContainingKnownAssetID,useThisHierarchy,
chkThisAssetYN,maxUpTravN,exactUpYN,maxDownTravN,exactDownYN,
myNewDoubleValue,myNewStringValue);
 
end;
 
method runCompute_station_lastDepartedTrainStatus(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_lastDepartedTrainStatus';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_lastDepartedTrainStatus(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_nextStation" language="ds2" func-names="runCompute_station_nextStation">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_nextStation / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAssetType;
declare char(100) targetAttributeID;
declare char(100) targetAttributeMetric;
declare char(100) navMethod;
declare char(100) attribIDContainingKnownAssetID;
declare char(100) chkThisAssetYN;
declare char(100) maxUpTrav;
declare char(100) exactUpYN;
declare char(100) maxDownTrav;
declare char(100) exactDownYN;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   maxUpTravN maxDownTravN;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getValue';
assetType='station';
attributeID='nextStation';
targetAssetType='station';
targetAttributeID='assetID';
targetAttributeMetric='';
navMethod='navigate';
attribIDContainingKnownAssetID='';
chkThisAssetYN='N';
maxUpTrav='0';
exactUpYN='N';
maxDownTrav='2';
exactDownYN='N';
hierarchyValue='';
hierarchyAttributeID='route';
SASAttributeID='nextStation';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_nextStation';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_nextStation(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeID */
/* char(100) targetAssetType */
/* char(100) targetAttributeID */
/* char(100) targetAttributeMetric */
/* char(100) navMethod */
/* char(100) attribIDContainingKnownAssetID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) chkThisAssetYN */
/* char(100) maxUpTrav */
/* char(100) exactUpYN */
/* char(100) maxDownTrav */
/* char(100) exactDownYN */
 
/* store the traversal distances as integers */
maxUpTravN=.;
maxDownTravN=.;
if strip(maxUpTrav) = '' then  maxUpTravN   = maxTraversals;
else                           maxUpTravN   = inputn(maxUpTrav,'8.0');
if strip(maxDownTrav) ='' then maxDownTravN = maxTraversals;
else                           maxDownTravN = inputn(maxDownTrav,'8.0');
 
/* if the hierarchy will come from another attribute then get it */
useThisHierarchy='';
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* pull the value needed */
getAttributeValue(assetID,targetAssetType,targetAttributeID,targetAttributeMetric,
navMethod,attribIDContainingKnownAssetID,useThisHierarchy,
chkThisAssetYN,maxUpTravN,exactUpYN,maxDownTravN,exactDownYN,
myNewDoubleValue,myNewStringValue);
 
end;
 
method runCompute_station_nextStation(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_nextStation';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_nextStation(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_nextTrack" language="ds2" func-names="runCompute_station_nextTrack">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_nextTrack / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAssetType;
declare char(100) targetAttributeID;
declare char(100) targetAttributeMetric;
declare char(100) navMethod;
declare char(100) attribIDContainingKnownAssetID;
declare char(100) chkThisAssetYN;
declare char(100) maxUpTrav;
declare char(100) exactUpYN;
declare char(100) maxDownTrav;
declare char(100) exactDownYN;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   maxUpTravN maxDownTravN;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getValue';
assetType='station';
attributeID='nextTrack';
targetAssetType='track';
targetAttributeID='assetID';
targetAttributeMetric='';
navMethod='navigate';
attribIDContainingKnownAssetID='';
chkThisAssetYN='N';
maxUpTrav='0';
exactUpYN='N';
maxDownTrav='1';
exactDownYN='N';
hierarchyValue='';
hierarchyAttributeID='route';
SASAttributeID='nextTrack';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_nextTrack';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_nextTrack(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeID */
/* char(100) targetAssetType */
/* char(100) targetAttributeID */
/* char(100) targetAttributeMetric */
/* char(100) navMethod */
/* char(100) attribIDContainingKnownAssetID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) chkThisAssetYN */
/* char(100) maxUpTrav */
/* char(100) exactUpYN */
/* char(100) maxDownTrav */
/* char(100) exactDownYN */
 
/* store the traversal distances as integers */
maxUpTravN=.;
maxDownTravN=.;
if strip(maxUpTrav) = '' then  maxUpTravN   = maxTraversals;
else                           maxUpTravN   = inputn(maxUpTrav,'8.0');
if strip(maxDownTrav) ='' then maxDownTravN = maxTraversals;
else                           maxDownTravN = inputn(maxDownTrav,'8.0');
 
/* if the hierarchy will come from another attribute then get it */
useThisHierarchy='';
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* pull the value needed */
getAttributeValue(assetID,targetAssetType,targetAttributeID,targetAttributeMetric,
navMethod,attribIDContainingKnownAssetID,useThisHierarchy,
chkThisAssetYN,maxUpTravN,exactUpYN,maxDownTravN,exactDownYN,
myNewDoubleValue,myNewStringValue);
 
end;
 
method runCompute_station_nextTrack(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_nextTrack';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_nextTrack(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_prevStation" language="ds2" func-names="runCompute_station_prevStation">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_prevStation / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAssetType;
declare char(100) targetAttributeID;
declare char(100) targetAttributeMetric;
declare char(100) navMethod;
declare char(100) attribIDContainingKnownAssetID;
declare char(100) chkThisAssetYN;
declare char(100) maxUpTrav;
declare char(100) exactUpYN;
declare char(100) maxDownTrav;
declare char(100) exactDownYN;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   maxUpTravN maxDownTravN;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getValue';
assetType='station';
attributeID='prevStation';
targetAssetType='station';
targetAttributeID='assetID';
targetAttributeMetric='';
navMethod='navigate';
attribIDContainingKnownAssetID='';
chkThisAssetYN='N';
maxUpTrav='2';
exactUpYN='N';
maxDownTrav='0';
exactDownYN='N';
hierarchyValue='';
hierarchyAttributeID='route';
SASAttributeID='prevStation';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_prevStation';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_prevStation(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeID */
/* char(100) targetAssetType */
/* char(100) targetAttributeID */
/* char(100) targetAttributeMetric */
/* char(100) navMethod */
/* char(100) attribIDContainingKnownAssetID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) chkThisAssetYN */
/* char(100) maxUpTrav */
/* char(100) exactUpYN */
/* char(100) maxDownTrav */
/* char(100) exactDownYN */
 
/* store the traversal distances as integers */
maxUpTravN=.;
maxDownTravN=.;
if strip(maxUpTrav) = '' then  maxUpTravN   = maxTraversals;
else                           maxUpTravN   = inputn(maxUpTrav,'8.0');
if strip(maxDownTrav) ='' then maxDownTravN = maxTraversals;
else                           maxDownTravN = inputn(maxDownTrav,'8.0');
 
/* if the hierarchy will come from another attribute then get it */
useThisHierarchy='';
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* pull the value needed */
getAttributeValue(assetID,targetAssetType,targetAttributeID,targetAttributeMetric,
navMethod,attribIDContainingKnownAssetID,useThisHierarchy,
chkThisAssetYN,maxUpTravN,exactUpYN,maxDownTravN,exactDownYN,
myNewDoubleValue,myNewStringValue);
 
end;
 
method runCompute_station_prevStation(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_prevStation';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_prevStation(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_prevTrack" language="ds2" func-names="runCompute_station_prevTrack">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_prevTrack / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAssetType;
declare char(100) targetAttributeID;
declare char(100) targetAttributeMetric;
declare char(100) navMethod;
declare char(100) attribIDContainingKnownAssetID;
declare char(100) chkThisAssetYN;
declare char(100) maxUpTrav;
declare char(100) exactUpYN;
declare char(100) maxDownTrav;
declare char(100) exactDownYN;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   maxUpTravN maxDownTravN;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getValue';
assetType='station';
attributeID='prevTrack';
targetAssetType='track';
targetAttributeID='assetID';
targetAttributeMetric='';
navMethod='navigate';
attribIDContainingKnownAssetID='';
chkThisAssetYN='N';
maxUpTrav='1';
exactUpYN='N';
maxDownTrav='0';
exactDownYN='N';
hierarchyValue='';
hierarchyAttributeID='route';
SASAttributeID='prevTrack';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_prevTrack';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_prevTrack(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeID */
/* char(100) targetAssetType */
/* char(100) targetAttributeID */
/* char(100) targetAttributeMetric */
/* char(100) navMethod */
/* char(100) attribIDContainingKnownAssetID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) chkThisAssetYN */
/* char(100) maxUpTrav */
/* char(100) exactUpYN */
/* char(100) maxDownTrav */
/* char(100) exactDownYN */
 
/* store the traversal distances as integers */
maxUpTravN=.;
maxDownTravN=.;
if strip(maxUpTrav) = '' then  maxUpTravN   = maxTraversals;
else                           maxUpTravN   = inputn(maxUpTrav,'8.0');
if strip(maxDownTrav) ='' then maxDownTravN = maxTraversals;
else                           maxDownTravN = inputn(maxDownTrav,'8.0');
 
/* if the hierarchy will come from another attribute then get it */
useThisHierarchy='';
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* pull the value needed */
getAttributeValue(assetID,targetAssetType,targetAttributeID,targetAttributeMetric,
navMethod,attribIDContainingKnownAssetID,useThisHierarchy,
chkThisAssetYN,maxUpTravN,exactUpYN,maxDownTravN,exactDownYN,
myNewDoubleValue,myNewStringValue);
 
end;
 
method runCompute_station_prevTrack(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_prevTrack';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_prevTrack(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_prevTrackTravelTime" language="ds2" func-names="runCompute_station_prevTrackTravelTime">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_prevTrackTravelTime / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAssetType;
declare char(100) targetAttributeID;
declare char(100) targetAttributeMetric;
declare char(100) navMethod;
declare char(100) attribIDContainingKnownAssetID;
declare char(100) chkThisAssetYN;
declare char(100) maxUpTrav;
declare char(100) exactUpYN;
declare char(100) maxDownTrav;
declare char(100) exactDownYN;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   maxUpTravN maxDownTravN;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getValue';
assetType='station';
attributeID='prevTrackTravelTime';
targetAssetType='track';
targetAttributeID='travelTimeRollingAvg';
targetAttributeMetric='currentValue';
navMethod='knownassetid';
attribIDContainingKnownAssetID='prevTrack';
chkThisAssetYN='N';
maxUpTrav='0';
exactUpYN='N';
maxDownTrav='0';
exactDownYN='N';
hierarchyValue='';
hierarchyAttributeID='';
SASAttributeID='prevTrackTravelTime';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_prevTrackTravelTime';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_prevTrackTravelTime(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeID */
/* char(100) targetAssetType */
/* char(100) targetAttributeID */
/* char(100) targetAttributeMetric */
/* char(100) navMethod */
/* char(100) attribIDContainingKnownAssetID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) chkThisAssetYN */
/* char(100) maxUpTrav */
/* char(100) exactUpYN */
/* char(100) maxDownTrav */
/* char(100) exactDownYN */
 
/* store the traversal distances as integers */
maxUpTravN=.;
maxDownTravN=.;
if strip(maxUpTrav) = '' then  maxUpTravN   = maxTraversals;
else                           maxUpTravN   = inputn(maxUpTrav,'8.0');
if strip(maxDownTrav) ='' then maxDownTravN = maxTraversals;
else                           maxDownTravN = inputn(maxDownTrav,'8.0');
 
/* if the hierarchy will come from another attribute then get it */
useThisHierarchy='';
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* pull the value needed */
getAttributeValue(assetID,targetAssetType,targetAttributeID,targetAttributeMetric,
navMethod,attribIDContainingKnownAssetID,useThisHierarchy,
chkThisAssetYN,maxUpTravN,exactUpYN,maxDownTravN,exactDownYN,
myNewDoubleValue,myNewStringValue);
 
end;
 
method runCompute_station_prevTrackTravelTime(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_prevTrackTravelTime';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_prevTrackTravelTime(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_lastEnrouteTrainStatus" language="ds2" func-names="runCompute_track_lastEnrouteTrainStatus">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_lastEnrouteTrainStatus / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAssetType;
declare char(100) targetAttributeID;
declare char(100) targetAttributeMetric;
declare char(100) navMethod;
declare char(100) attribIDContainingKnownAssetID;
declare char(100) chkThisAssetYN;
declare char(100) maxUpTrav;
declare char(100) exactUpYN;
declare char(100) maxDownTrav;
declare char(100) exactDownYN;
declare char(100) hierarchyValue;
declare char(100) hierarchyAttributeID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare char(100) useThisHierarchy;
declare double    ignoreThisDouble;
declare integer   maxUpTravN maxDownTravN;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='getValue';
assetType='track';
attributeID='lastEnrouteTrainStatus';
targetAssetType='train';
targetAttributeID='currentStatus';
targetAttributeMetric='currentValue';
navMethod='knownassetid';
attribIDContainingKnownAssetID='lastEnrouteTrain';
chkThisAssetYN='N';
maxUpTrav='0';
exactUpYN='N';
maxDownTrav='0';
exactDownYN='N';
hierarchyValue='';
hierarchyAttributeID='';
SASAttributeID='lastEnrouteTrainStatus';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_lastEnrouteTrainStatus';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_track_lastEnrouteTrainStatus(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeID */
/* char(100) targetAssetType */
/* char(100) targetAttributeID */
/* char(100) targetAttributeMetric */
/* char(100) navMethod */
/* char(100) attribIDContainingKnownAssetID */
/* char(100) hierarchyValue */
/* char(100) hierarchyAttributeID */
/* char(100) chkThisAssetYN */
/* char(100) maxUpTrav */
/* char(100) exactUpYN */
/* char(100) maxDownTrav */
/* char(100) exactDownYN */
 
/* store the traversal distances as integers */
maxUpTravN=.;
maxDownTravN=.;
if strip(maxUpTrav) = '' then  maxUpTravN   = maxTraversals;
else                           maxUpTravN   = inputn(maxUpTrav,'8.0');
if strip(maxDownTrav) ='' then maxDownTravN = maxTraversals;
else                           maxDownTravN = inputn(maxDownTrav,'8.0');
 
/* if the hierarchy will come from another attribute then get it */
useThisHierarchy='';
if strip(hierarchyValue) ne '' then do;
useThisHierarchy=strip(hierarchyValue);
end;
else do;
getAttributeValue(assetID,assetType,hierarchyAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,useThisHierarchy);
end;
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* pull the value needed */
getAttributeValue(assetID,targetAssetType,targetAttributeID,targetAttributeMetric,
navMethod,attribIDContainingKnownAssetID,useThisHierarchy,
chkThisAssetYN,maxUpTravN,exactUpYN,maxDownTravN,exactDownYN,
myNewDoubleValue,myNewStringValue);
 
end;
 
method runCompute_track_lastEnrouteTrainStatus(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_lastEnrouteTrainStatus';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_lastEnrouteTrainStatus(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_lastDepartedTrain" language="ds2" func-names="runCompute_station_lastDepartedTrain">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_lastDepartedTrain / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriod;
declare char(100) recentTimePeriod;
declare char(100) maxEventsToSearch;
declare char(100) searchLogic;
declare char(100) instanceNumber;
declare char(100) searchSubsetValue;
declare char(100) searchSubsetAttributeID;
declare char(100) returnValue;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    thisDoubleValue searchDoubleValue;
declare char(50)  attribDataType;
declare char(50)  thisStringValue searchStringValue;
declare integer   maxPeriods currentIter currentSlot exitNow howManyFound;
declare integer   maxHistoryLength baseHistoryLocation numInstances;
declare bigint    earliestTimestamp latestTimestamp thisTime;
declare integer   hasSubsetCondition;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='searchEvents';
assetType='station';
attributeID='lastDepartedTrain';
targetAttributeID='trainDepartureFrom';
oldTimePeriod='3600';
recentTimePeriod='0';
maxEventsToSearch='100';
searchLogic='newest';
instanceNumber='1';
searchSubsetValue='';
searchSubsetAttributeID='';
returnValue='value';
queryAssetIDFromThisAttribID='';
SASAttributeID='lastDepartedTrain';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_lastDepartedTrain';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_lastDepartedTrain(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriod */
/* char(100) recentTimePeriod */
/* char(100) maxEventsToSearch */
/* char(100) searchLogic */
/* char(100) instanceNumber */
/* char(100) searchSubsetValue */
/* char(100) searchSubsetAttributeID */
/* char(100) returnValue */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* pull the vector of interest */
getVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
/* read the data type, max history and base history */
attribDataType = st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',0);
maxHistoryLength    = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',2);
baseHistoryLocation = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',3);
 
/* find the max events to search */
maxPeriods=inputn(maxEventsToSearch,'16.');
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* determine if there is a subset condition and obtain the value */
hasSubsetCondition=0;
if strip(searchSubsetValue) ne '' then do;
hasSubsetCondition=1;
if attribDataType='double' then do;
searchDoubleValue = inputn(searchSubsetValue,'16.');
end;
else do;
searchStringValue = strip(searchSubsetValue);
end;
end;
else if strip(searchSubsetAttributeID) ne '' then do;
getAttributeValue(assetID,assetType,searchSubsetAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
searchDoubleValue,searchStringValue);
if searchDoubleValue ne . or strip(searchStringValue) ne '' then hasSubsetCondition=1;
end;
 
/* calculate earliest and latest timestamps to look at */
earliestTimestamp = outputTimestamp - (inputn(oldTimePeriod,'16.') * 1000000);
latestTimestamp   = outputTimestamp - (inputn(recentTimePeriod,'16.') * 1000000);
 
/* execute logic depending on whether searching for most recent or first occurrence */
if searchLogic='oldest' then do;
 
/* find the earliest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime gt latestTimestamp then exitNow=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime ge earliestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
 
end;
 
end;
else do;
 
/* find the latest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime lt earliestTimestamp then foundOne=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime le latestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot-1;
if currentSlot=0 then currentSlot = maxHistoryLength;
 
end;
 
end;
 
/* delete the vector */
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
end;
 
method runCompute_station_lastDepartedTrain(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_lastDepartedTrain';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_lastDepartedTrain(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_lastDepartedTrainArrivalTime" language="ds2" func-names="runCompute_station_lastDepartedTrainArrivalTime">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_lastDepartedTrainArrivalTime / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriod;
declare char(100) recentTimePeriod;
declare char(100) maxEventsToSearch;
declare char(100) searchLogic;
declare char(100) instanceNumber;
declare char(100) searchSubsetValue;
declare char(100) searchSubsetAttributeID;
declare char(100) returnValue;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    thisDoubleValue searchDoubleValue;
declare char(50)  attribDataType;
declare char(50)  thisStringValue searchStringValue;
declare integer   maxPeriods currentIter currentSlot exitNow howManyFound;
declare integer   maxHistoryLength baseHistoryLocation numInstances;
declare bigint    earliestTimestamp latestTimestamp thisTime;
declare integer   hasSubsetCondition;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='searchEvents';
assetType='station';
attributeID='lastDepartedTrainArrivalTime';
targetAttributeID='trainArrival';
oldTimePeriod='3600';
recentTimePeriod='0';
maxEventsToSearch='100';
searchLogic='newest';
instanceNumber='1';
searchSubsetValue='';
searchSubsetAttributeID='lastDepartedTrain';
returnValue='time';
queryAssetIDFromThisAttribID='';
SASAttributeID='lastDepartedTrainArrivalTime';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_lastDepartedTrainArrivalTime';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_lastDepartedTrainArrivalTime(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriod */
/* char(100) recentTimePeriod */
/* char(100) maxEventsToSearch */
/* char(100) searchLogic */
/* char(100) instanceNumber */
/* char(100) searchSubsetValue */
/* char(100) searchSubsetAttributeID */
/* char(100) returnValue */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* pull the vector of interest */
getVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
/* read the data type, max history and base history */
attribDataType = st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',0);
maxHistoryLength    = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',2);
baseHistoryLocation = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',3);
 
/* find the max events to search */
maxPeriods=inputn(maxEventsToSearch,'16.');
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* determine if there is a subset condition and obtain the value */
hasSubsetCondition=0;
if strip(searchSubsetValue) ne '' then do;
hasSubsetCondition=1;
if attribDataType='double' then do;
searchDoubleValue = inputn(searchSubsetValue,'16.');
end;
else do;
searchStringValue = strip(searchSubsetValue);
end;
end;
else if strip(searchSubsetAttributeID) ne '' then do;
getAttributeValue(assetID,assetType,searchSubsetAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
searchDoubleValue,searchStringValue);
if searchDoubleValue ne . or strip(searchStringValue) ne '' then hasSubsetCondition=1;
end;
 
/* calculate earliest and latest timestamps to look at */
earliestTimestamp = outputTimestamp - (inputn(oldTimePeriod,'16.') * 1000000);
latestTimestamp   = outputTimestamp - (inputn(recentTimePeriod,'16.') * 1000000);
 
/* execute logic depending on whether searching for most recent or first occurrence */
if searchLogic='oldest' then do;
 
/* find the earliest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime gt latestTimestamp then exitNow=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime ge earliestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
 
end;
 
end;
else do;
 
/* find the latest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime lt earliestTimestamp then foundOne=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime le latestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot-1;
if currentSlot=0 then currentSlot = maxHistoryLength;
 
end;
 
end;
 
/* delete the vector */
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
end;
 
method runCompute_station_lastDepartedTrainArrivalTime(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_lastDepartedTrainArrivalTime';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_lastDepartedTrainArrivalTime(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_lastDepartedTrainTime" language="ds2" func-names="runCompute_station_lastDepartedTrainTime">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_lastDepartedTrainTime / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriod;
declare char(100) recentTimePeriod;
declare char(100) maxEventsToSearch;
declare char(100) searchLogic;
declare char(100) instanceNumber;
declare char(100) searchSubsetValue;
declare char(100) searchSubsetAttributeID;
declare char(100) returnValue;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    thisDoubleValue searchDoubleValue;
declare char(50)  attribDataType;
declare char(50)  thisStringValue searchStringValue;
declare integer   maxPeriods currentIter currentSlot exitNow howManyFound;
declare integer   maxHistoryLength baseHistoryLocation numInstances;
declare bigint    earliestTimestamp latestTimestamp thisTime;
declare integer   hasSubsetCondition;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='searchEvents';
assetType='station';
attributeID='lastDepartedTrainTime';
targetAttributeID='trainDepartureFrom';
oldTimePeriod='3600';
recentTimePeriod='0';
maxEventsToSearch='100';
searchLogic='newest';
instanceNumber='1';
searchSubsetValue='';
searchSubsetAttributeID='';
returnValue='time';
queryAssetIDFromThisAttribID='';
SASAttributeID='lastDepartedTrainTime';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_lastDepartedTrainTime';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_lastDepartedTrainTime(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriod */
/* char(100) recentTimePeriod */
/* char(100) maxEventsToSearch */
/* char(100) searchLogic */
/* char(100) instanceNumber */
/* char(100) searchSubsetValue */
/* char(100) searchSubsetAttributeID */
/* char(100) returnValue */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* pull the vector of interest */
getVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
/* read the data type, max history and base history */
attribDataType = st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',0);
maxHistoryLength    = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',2);
baseHistoryLocation = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',3);
 
/* find the max events to search */
maxPeriods=inputn(maxEventsToSearch,'16.');
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* determine if there is a subset condition and obtain the value */
hasSubsetCondition=0;
if strip(searchSubsetValue) ne '' then do;
hasSubsetCondition=1;
if attribDataType='double' then do;
searchDoubleValue = inputn(searchSubsetValue,'16.');
end;
else do;
searchStringValue = strip(searchSubsetValue);
end;
end;
else if strip(searchSubsetAttributeID) ne '' then do;
getAttributeValue(assetID,assetType,searchSubsetAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
searchDoubleValue,searchStringValue);
if searchDoubleValue ne . or strip(searchStringValue) ne '' then hasSubsetCondition=1;
end;
 
/* calculate earliest and latest timestamps to look at */
earliestTimestamp = outputTimestamp - (inputn(oldTimePeriod,'16.') * 1000000);
latestTimestamp   = outputTimestamp - (inputn(recentTimePeriod,'16.') * 1000000);
 
/* execute logic depending on whether searching for most recent or first occurrence */
if searchLogic='oldest' then do;
 
/* find the earliest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime gt latestTimestamp then exitNow=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime ge earliestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
 
end;
 
end;
else do;
 
/* find the latest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime lt earliestTimestamp then foundOne=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime le latestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot-1;
if currentSlot=0 then currentSlot = maxHistoryLength;
 
end;
 
end;
 
/* delete the vector */
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
end;
 
method runCompute_station_lastDepartedTrainTime(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_lastDepartedTrainTime';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_lastDepartedTrainTime(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_lastEnrouteTrain" language="ds2" func-names="runCompute_track_lastEnrouteTrain">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_lastEnrouteTrain / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriod;
declare char(100) recentTimePeriod;
declare char(100) maxEventsToSearch;
declare char(100) searchLogic;
declare char(100) instanceNumber;
declare char(100) searchSubsetValue;
declare char(100) searchSubsetAttributeID;
declare char(100) returnValue;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    thisDoubleValue searchDoubleValue;
declare char(50)  attribDataType;
declare char(50)  thisStringValue searchStringValue;
declare integer   maxPeriods currentIter currentSlot exitNow howManyFound;
declare integer   maxHistoryLength baseHistoryLocation numInstances;
declare bigint    earliestTimestamp latestTimestamp thisTime;
declare integer   hasSubsetCondition;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='searchEvents';
assetType='track';
attributeID='lastEnrouteTrain';
targetAttributeID='enrouteToEnd';
oldTimePeriod='3600';
recentTimePeriod='0';
maxEventsToSearch='100';
searchLogic='newest';
instanceNumber='1';
searchSubsetValue='';
searchSubsetAttributeID='';
returnValue='value';
queryAssetIDFromThisAttribID='';
SASAttributeID='lastEnrouteTrain';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_lastEnrouteTrain';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_track_lastEnrouteTrain(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriod */
/* char(100) recentTimePeriod */
/* char(100) maxEventsToSearch */
/* char(100) searchLogic */
/* char(100) instanceNumber */
/* char(100) searchSubsetValue */
/* char(100) searchSubsetAttributeID */
/* char(100) returnValue */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* pull the vector of interest */
getVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
/* read the data type, max history and base history */
attribDataType = st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',0);
maxHistoryLength    = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',2);
baseHistoryLocation = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',3);
 
/* find the max events to search */
maxPeriods=inputn(maxEventsToSearch,'16.');
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* determine if there is a subset condition and obtain the value */
hasSubsetCondition=0;
if strip(searchSubsetValue) ne '' then do;
hasSubsetCondition=1;
if attribDataType='double' then do;
searchDoubleValue = inputn(searchSubsetValue,'16.');
end;
else do;
searchStringValue = strip(searchSubsetValue);
end;
end;
else if strip(searchSubsetAttributeID) ne '' then do;
getAttributeValue(assetID,assetType,searchSubsetAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
searchDoubleValue,searchStringValue);
if searchDoubleValue ne . or strip(searchStringValue) ne '' then hasSubsetCondition=1;
end;
 
/* calculate earliest and latest timestamps to look at */
earliestTimestamp = outputTimestamp - (inputn(oldTimePeriod,'16.') * 1000000);
latestTimestamp   = outputTimestamp - (inputn(recentTimePeriod,'16.') * 1000000);
 
/* execute logic depending on whether searching for most recent or first occurrence */
if searchLogic='oldest' then do;
 
/* find the earliest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime gt latestTimestamp then exitNow=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime ge earliestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
 
end;
 
end;
else do;
 
/* find the latest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime lt earliestTimestamp then foundOne=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime le latestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot-1;
if currentSlot=0 then currentSlot = maxHistoryLength;
 
end;
 
end;
 
/* delete the vector */
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
end;
 
method runCompute_track_lastEnrouteTrain(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_lastEnrouteTrain';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_lastEnrouteTrain(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_lastEnrouteTrainEnd" language="ds2" func-names="runCompute_track_lastEnrouteTrainEnd">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_lastEnrouteTrainEnd / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriod;
declare char(100) recentTimePeriod;
declare char(100) maxEventsToSearch;
declare char(100) searchLogic;
declare char(100) instanceNumber;
declare char(100) searchSubsetValue;
declare char(100) searchSubsetAttributeID;
declare char(100) returnValue;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    thisDoubleValue searchDoubleValue;
declare char(50)  attribDataType;
declare char(50)  thisStringValue searchStringValue;
declare integer   maxPeriods currentIter currentSlot exitNow howManyFound;
declare integer   maxHistoryLength baseHistoryLocation numInstances;
declare bigint    earliestTimestamp latestTimestamp thisTime;
declare integer   hasSubsetCondition;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='searchEvents';
assetType='track';
attributeID='lastEnrouteTrainEnd';
targetAttributeID='enrouteToEnd';
oldTimePeriod='3600';
recentTimePeriod='0';
maxEventsToSearch='100';
searchLogic='newest';
instanceNumber='1';
searchSubsetValue='';
searchSubsetAttributeID='';
returnValue='time';
queryAssetIDFromThisAttribID='';
SASAttributeID='lastEnrouteTrainEnd';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_lastEnrouteTrainEnd';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_track_lastEnrouteTrainEnd(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriod */
/* char(100) recentTimePeriod */
/* char(100) maxEventsToSearch */
/* char(100) searchLogic */
/* char(100) instanceNumber */
/* char(100) searchSubsetValue */
/* char(100) searchSubsetAttributeID */
/* char(100) returnValue */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* pull the vector of interest */
getVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
/* read the data type, max history and base history */
attribDataType = st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',0);
maxHistoryLength    = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',2);
baseHistoryLocation = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',3);
 
/* find the max events to search */
maxPeriods=inputn(maxEventsToSearch,'16.');
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* determine if there is a subset condition and obtain the value */
hasSubsetCondition=0;
if strip(searchSubsetValue) ne '' then do;
hasSubsetCondition=1;
if attribDataType='double' then do;
searchDoubleValue = inputn(searchSubsetValue,'16.');
end;
else do;
searchStringValue = strip(searchSubsetValue);
end;
end;
else if strip(searchSubsetAttributeID) ne '' then do;
getAttributeValue(assetID,assetType,searchSubsetAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
searchDoubleValue,searchStringValue);
if searchDoubleValue ne . or strip(searchStringValue) ne '' then hasSubsetCondition=1;
end;
 
/* calculate earliest and latest timestamps to look at */
earliestTimestamp = outputTimestamp - (inputn(oldTimePeriod,'16.') * 1000000);
latestTimestamp   = outputTimestamp - (inputn(recentTimePeriod,'16.') * 1000000);
 
/* execute logic depending on whether searching for most recent or first occurrence */
if searchLogic='oldest' then do;
 
/* find the earliest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime gt latestTimestamp then exitNow=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime ge earliestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
 
end;
 
end;
else do;
 
/* find the latest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime lt earliestTimestamp then foundOne=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime le latestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot-1;
if currentSlot=0 then currentSlot = maxHistoryLength;
 
end;
 
end;
 
/* delete the vector */
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
end;
 
method runCompute_track_lastEnrouteTrainEnd(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_lastEnrouteTrainEnd';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_lastEnrouteTrainEnd(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_lastEnrouteTrainStart" language="ds2" func-names="runCompute_track_lastEnrouteTrainStart">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_lastEnrouteTrainStart / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriod;
declare char(100) recentTimePeriod;
declare char(100) maxEventsToSearch;
declare char(100) searchLogic;
declare char(100) instanceNumber;
declare char(100) searchSubsetValue;
declare char(100) searchSubsetAttributeID;
declare char(100) returnValue;
declare char(100) queryAssetIDFromThisAttribID;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    thisDoubleValue searchDoubleValue;
declare char(50)  attribDataType;
declare char(50)  thisStringValue searchStringValue;
declare integer   maxPeriods currentIter currentSlot exitNow howManyFound;
declare integer   maxHistoryLength baseHistoryLocation numInstances;
declare bigint    earliestTimestamp latestTimestamp thisTime;
declare integer   hasSubsetCondition;
declare char(32)  queryAssetIDFromHere;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='searchEvents';
assetType='track';
attributeID='lastEnrouteTrainStart';
targetAttributeID='enrouteToStart';
oldTimePeriod='3600';
recentTimePeriod='0';
maxEventsToSearch='100';
searchLogic='newest';
instanceNumber='1';
searchSubsetValue='';
searchSubsetAttributeID='lastEnrouteTrain';
returnValue='time';
queryAssetIDFromThisAttribID='';
SASAttributeID='lastEnrouteTrainStart';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_lastEnrouteTrainStart';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_track_lastEnrouteTrainStart(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriod */
/* char(100) recentTimePeriod */
/* char(100) maxEventsToSearch */
/* char(100) searchLogic */
/* char(100) instanceNumber */
/* char(100) searchSubsetValue */
/* char(100) searchSubsetAttributeID */
/* char(100) returnValue */
/* char(100) queryAssetIDFromThisAttribID */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
 
/* determine which assetID to query */
if strip(queryAssetIDFromThisAttribID)='' then do;
queryAssetIDFromHere=assetID;
end;
else do;
getAttributeValue(assetID,assetType,queryAssetIDFromThisAttribID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
ignoreThisDouble,queryAssetIDFromHere);
end;
 
/* pull the vector of interest */
getVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
/* read the data type, max history and base history */
attribDataType = st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',0);
maxHistoryLength    = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',2);
baseHistoryLocation = st.getInt('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',3);
 
/* find the max events to search */
maxPeriods=inputn(maxEventsToSearch,'16.');
 
/* find the number of instances to search */
numInstances=inputn(instanceNumber,'16.');
 
/* determine if there is a subset condition and obtain the value */
hasSubsetCondition=0;
if strip(searchSubsetValue) ne '' then do;
hasSubsetCondition=1;
if attribDataType='double' then do;
searchDoubleValue = inputn(searchSubsetValue,'16.');
end;
else do;
searchStringValue = strip(searchSubsetValue);
end;
end;
else if strip(searchSubsetAttributeID) ne '' then do;
getAttributeValue(assetID,assetType,searchSubsetAttributeID,'currentValue',
'NAVIGATE','','',
'Y',0,'N',0,'N',
searchDoubleValue,searchStringValue);
if searchDoubleValue ne . or strip(searchStringValue) ne '' then hasSubsetCondition=1;
end;
 
/* calculate earliest and latest timestamps to look at */
earliestTimestamp = outputTimestamp - (inputn(oldTimePeriod,'16.') * 1000000);
latestTimestamp   = outputTimestamp - (inputn(recentTimePeriod,'16.') * 1000000);
 
/* execute logic depending on whether searching for most recent or first occurrence */
if searchLogic='oldest' then do;
 
/* find the earliest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime gt latestTimestamp then exitNow=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime ge earliestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot+1;
if currentSlot=(maxHistoryLength+1) then currentSlot = 1;
 
end;
 
end;
else do;
 
/* find the latest non-missing value that meets the specified criteria */
/* exit as soon as a time period is found outside of the range OR a value is found */
exitNow=0;
howManyFound=0;
currentIter=1;
currentSlot=baseHistoryLocation;
do while (exitNow=0);
 
/* check the time of the event */
thisTime=st.getLong('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+2);
if thisTime gt 0 and thisTime lt earliestTimestamp then foundOne=1;
 
/* if the time is acceptable and search criteria satisfied, then pull the value */
if exitNow=0 and thisTime gt 0 and thisTime le latestTimestamp then do;
 
if attribDataType='double' then do;
thisDoubleValue=st.getDouble('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
thisStringValue='';
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if thisDoubleValue = searchDoubleValue then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewDoubleValue=thisDoubleValue;
end;
end;
end;
else do;
thisDoubleValue=.;
thisStringValue=st.getString('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events',int(currentSlot*2)+3);
 
if hasSubsetCondition=0 then do;
howManyFound=howManyFound+1;
end;
else do;
if strip(thisStringValue) = strip(searchStringValue) then do;
howManyFound=howManyFound+1;
end;
end;
 
if howManyFound=numInstances then do;
exitNow=1;
if strip(returnValue)='time' then do;
myNewDoubleValue=(1.0 * thisTime) - (dhms(mdy(1,1,1970),0,0,0) * 1000000.0);
end;
else do;
myNewStringValue=thisStringValue;
end;
end;
end;
 
end;
 
if currentIter ge maxPeriods then exitNow=1;
 
currentIter=currentIter+1;
currentSlot=currentSlot-1;
if currentSlot=0 then currentSlot = maxHistoryLength;
 
end;
 
end;
 
/* delete the vector */
deleteVector('asset|'||strip(queryAssetIDFromHere)||'|attribute|'||strip(targetAttributeID)||'|events');
 
end;
 
method runCompute_track_lastEnrouteTrainStart(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_lastEnrouteTrainStart';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_lastEnrouteTrainStart(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_station_waitTimeRollingAvg" language="ds2" func-names="runCompute_station_waitTimeRollingAvg">
<code><![CDATA[ds2_options sas;
 
package computePackage_station_waitTimeRollingAvg / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriodNumeric;
declare char(100) oldTimePeriodAssetType;
declare char(100) oldTimePeriodAttributeID;
declare char(100) recentTimePeriodNumeric;
declare char(100) recentTimePeriodAssetType;
declare char(100) recentTimePeriodAttributeID;
declare char(100) maxHistorySeconds;
declare char(100) summaryLogic;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    oldLagTimeSeconds recentLagTimeSeconds currentValue;
declare integer   oldLagSlot recentLagSlot lagSlot countRecs lagSlotCounter impliedRecCount;
declare integer   maxHistoryLength baseHistoryLocation;
declare double    aggHelp1 aggHelp2 rcHasValue;
 
declare package hash  thisAggList;
declare package hiter thisAggListHI;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='temporalAgg';
assetType='station';
attributeID='waitTimeRollingAvg';
targetAttributeID='waitTime';
oldTimePeriodNumeric='600';
oldTimePeriodAssetType='';
oldTimePeriodAttributeID='';
recentTimePeriodNumeric='0';
recentTimePeriodAssetType='';
recentTimePeriodAttributeID='';
maxHistorySeconds='';
summaryLogic='avg';
SASAttributeID='waitTimeRollingAvg';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_station_waitTimeRollingAvg';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
thisAggList = _new_ hash(3,'');
thisAggList.multidata('no');
thisAggList.defineKey('countRecs');
thisAggList.defineData('currentValue');
thisAggList.defineDone();
 
thisAggListHI = _new_ hiter('thisAggList');
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_station_waitTimeRollingAvg(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriodNumeric */
/* char(100) oldTimePeriodAssetType */
/* char(100) oldTimePeriodAttributeID */
/* char(100) recentTimePeriodNumeric */
/* char(100) recentTimePeriodAssetType */
/* char(100) recentTimePeriodAttributeID */
/* char(100) maxHistorySeconds */
/* char(100) summaryLogic */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
rc=thisAggList.clear();
 
/* find the min and max time periods */
if strip(oldTimePeriodAssetType) in ('','NA','.') then do;
oldLagTimeSeconds=inputn(oldTimePeriodNumeric,'16.');
end;
else do;
getAttributeValue(assetID,oldTimePeriodAssetType,oldTimePeriodAttributeID,'currentValue',
'navigate','','','Y',maxTraversals,'N',maxTraversals,'N',
thisFoundDoubleResult,thisFoundStringResult);
 
oldLagTimeSeconds = thisFoundDoubleResult;
if oldLagTimeSeconds gt inputn(maxHistorySeconds,'16.') then oldLagTimeSeconds=inputn(maxHistorySeconds,'16.');
end;
oldLagSlot = ceil( (oldLagTimeSeconds * 1.0) / (@historyInterval@ * 1.0) );
 
if strip(recentTimePeriodAssetType) in ('','NA','.') then do;
recentLagTimeSeconds=inputn(recentTimePeriodNumeric,'16.');
end;
else do;
getAttributeValue(assetID,recentTimePeriodAssetType,recentTimePeriodAttributeID,'currentValue',
'navigate','','','Y',maxTraversals,'N',maxTraversals,'N',
thisFoundDoubleResult,thisFoundStringResult);
 
recentLagTimeSeconds = thisFoundDoubleResult;
if recentLagTimeSeconds gt inputn(maxHistorySeconds,'16.') then recentLagTimeSeconds=inputn(maxHistorySeconds,'16.');
end;
recentLagSlot = ceil( (recentLagTimeSeconds * 1.0) / (@historyInterval@ * 1.0) );
 
getVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue');
dataType = st.getString('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue',0);
getVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history');
maxHistoryLength    = st.getInt('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history',2);
baseHistoryLocation = st.getInt('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history',3);
 
impliedRecCount = abs(oldLagSlot-recentLagSlot)+1;
countRecs=0;
do lagSlotCounter = oldLagSlot to recentLagSlot by -1;
 
/* obtain the value from the history vector for the asset/attribute */
if lagSlotCounter=0 then do;
 
if dataType='double' then do;
currentValue=st.getDouble('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue',3);
end;
else do;
currentValue=.;
end;
 
end;
else do;
 
/* adjust lag slot for where the base history location is */
if lagSlotCounter le maxHistoryLength then do;
 
lagSlot = baseHistoryLocation - lagSlotCounter + 1;
if lagSlot lt 1 then lagSlot = lagSlot + maxHistoryLength;
 
if dataType='double' then do;
currentValue=st.getDouble('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history',int(lagSlot*2)+3);
end;
else do;
currentValue=.;
end;
 
end;
 
end;
 
if currentValue ne . then do;
countRecs=countRecs+1;
rc=thisAggList.add();
end;
 
end;
 
/* if we have a full complement of records for the aggregation, the calculate */
if countRecs=impliedRecCount then do;
 
/* now iterate over thisAggList to create desired summary - sum avg min max */
aggHelp1=.;
aggHelp2=0;
rcHasValue=thisAggListHI.first();
do while (rcHasValue=0);
 
if summaryLogic='sum' then do;
 
aggHelp1=sum(aggHelp1,currentValue);
 
end;
else if summaryLogic='avg' then do;
 
aggHelp1=sum(aggHelp1,currentValue);
aggHelp2=aggHelp2+1;
 
end;
else if summaryLogic='max' then do;
 
if currentValue gt aggHelp1 then aggHelp1=currentValue;
 
end;
else if summaryLogic='min' then do;
 
if currentValue lt aggHelp1 and currentValue ne . and aggHelp1 ne . then aggHelp1=currentValue;
 
end;
 
/* go to the next value in the list */
rcHasValue=thisAggListHI.next();
 
end;
 
if summaryLogic='sum' then do;
 
myNewDoubleValue = aggHelp1;
 
end;
else if summaryLogic='avg' then do;
 
if aggHelp2 ne 0 then do;
myNewDoubleValue = aggHelp1 / aggHelp2;
end;
 
end;
else if summaryLogic='max' then do;
 
myNewDoubleValue = aggHelp1;
 
end;
else if summaryLogic='min' then do;
 
myNewDoubleValue = aggHelp1;
 
end;
 
end;
else do;
 
myNewDoubleValue = .;
 
end;
 
deleteVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue');
deleteVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history');
 
end;
 
method runCompute_station_waitTimeRollingAvg(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_station_waitTimeRollingAvg';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_station_waitTimeRollingAvg(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="computeModule_track_travelTimeRollingAvg" language="ds2" func-names="runCompute_track_travelTimeRollingAvg">
<code><![CDATA[ds2_options sas;
 
package computePackage_track_travelTimeRollingAvg / overwrite = yes;
 
declare double    rc rc1 rc1s rcsleep;
declare integer   numAssets cntAssets numItems foundTHIS cntALL cntTHIS;
declare char(300) _assetID tempItem thisAssetID thisStartAssetID newAssetID;
declare integer   numAttributes cpycnt2 foundValue numHierarchies cntHier numParents;
declare char(75)  thisAssetType;
declare char(100) thisAttributeID;
declare char(25)  thisHierarchyName;
declare char(20)  dataType;
declare double    myNewDoubleValueResult thisFoundDoubleResult;
declare char(50)  myNewStringValueResult thisFoundStringResult;
 
declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
declare char(500) symLink;
declare integer   cntLevel symUpdateNeeded maxTraversals numNextLevel numThisLevel traversalCnt;
declare char(300) getAssetID nextAssetID whichAssetID;
declare char(75)  getAssetType;
declare char(100) getAttributeID getAttribIDKnownAsset;
declare char(20)  getNavMethod getAttribMetric;
declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
declare integer   getMaxUpTrav getMaxDownTrav;
 
declare package   masstate st();
declare package   logger writeTo();
declare char(200) loggerString;
 
/* monitoring */
declare double processedRecordCount processedRecordTime processStartTime;
declare double processEndTime nextProcessTime avgProcessTime;
declare char(200) thisModuleName;
/* monitoring */
 
declare char(100) attributeType;
declare char(100) assetType;
declare char(100) attributeID;
declare char(100) targetAttributeID;
declare char(100) oldTimePeriodNumeric;
declare char(100) oldTimePeriodAssetType;
declare char(100) oldTimePeriodAttributeID;
declare char(100) recentTimePeriodNumeric;
declare char(100) recentTimePeriodAssetType;
declare char(100) recentTimePeriodAttributeID;
declare char(100) maxHistorySeconds;
declare char(100) summaryLogic;
declare char(100) SASAttributeID;
 
/****************************************************/
/* insert derived attribute specific variables here */
/****************************************************/
 
declare double    oldLagTimeSeconds recentLagTimeSeconds currentValue;
declare integer   oldLagSlot recentLagSlot lagSlot countRecs lagSlotCounter impliedRecCount;
declare integer   maxHistoryLength baseHistoryLocation;
declare double    aggHelp1 aggHelp2 rcHasValue;
 
declare package hash  thisAggList;
declare package hiter thisAggListHI;
 
/****************************************************/
 
declare package hash  thisNetworkList;
declare package hiter thisNetworkListHI;
declare package hash  nextNetworkList;
declare package hiter nextNetworkListHI;
declare package hash  previouslyVisitedList;
declare package hiter previouslyVisitedListHI;
declare package hash  symLinkList;
declare package hiter symLinkListHI;
 
method init();
 
attributeType='temporalAgg';
assetType='track';
attributeID='travelTimeRollingAvg';
targetAttributeID='travelTime';
oldTimePeriodNumeric='600';
oldTimePeriodAssetType='';
oldTimePeriodAttributeID='';
recentTimePeriodNumeric='0';
recentTimePeriodAssetType='';
recentTimePeriodAttributeID='';
maxHistorySeconds='';
summaryLogic='avg';
SASAttributeID='travelTimeRollingAvg';
 
maxTraversals = 10;
 
/* monitoring */
thisModuleName='computeModule_track_travelTimeRollingAvg';
processedRecordCount = 0;
processedRecordTime = 0;
processStartTime = .;
processEndTime = .;
nextProcessTime = .;
avgProcessTime = .;
/* monitoring */
 
/* initialize the hash tables */
thisNetworkList = _new_ hash(3,'');
thisNetworkList.multidata('no');
thisNetworkList.defineKey('thisAssetID');
thisNetworkList.defineData('thisAssetID');
thisNetworkList.defineDone();
 
thisNetworkListHI = _new_ hiter('thisNetworkList');
 
nextNetworkList = _new_ hash(3,'');
nextNetworkList.multidata('no');
nextNetworkList.defineKey('nextAssetID');
nextNetworkList.defineData('nextAssetID');
nextNetworkList.defineDone();
 
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
previouslyVisitedList = _new_ hash(3,'');
previouslyVisitedList.multidata('no');
previouslyVisitedList.defineKey('thisAssetID');
previouslyVisitedList.defineData('thisAssetID');
previouslyVisitedList.defineDone();
 
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
symLinkList = _new_ hash(3,'');
symLinkList.multidata('no');
symLinkList.defineKey('getAssetID');
symLinkList.defineKey('getAssetType');
symLinkList.defineKey('getAttributeID');
symLinkList.defineKey('getAttribMetric');
symLinkList.defineKey('getNavMethod');
symLinkList.defineKey('getAttribIDKnownAsset');
symLinkList.defineKey('getChkThisAssetYN');
symLinkList.defineKey('getMaxUpTrav');
symLinkList.defineKey('getExactUpYN');
symLinkList.defineKey('getMaxDownTrav');
symLinkList.defineKey('getExactDownYN');
symLinkList.defineData('symLink');
symLinkList.defineDone();
 
symLinkListHI = _new_ hiter('symLinkList');
/* initialize the hash tables */
 
thisAggList = _new_ hash(3,'');
thisAggList.multidata('no');
thisAggList.defineKey('countRecs');
thisAggList.defineData('currentValue');
thisAggList.defineDone();
 
thisAggListHI = _new_ hiter('thisAggList');
 
end;
 
method startMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
processStartTime = datetime();
if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
end;
 
end;
 
method endMonitoring();
 
if strip('@performanceMonitoring@')='true' then do;
 
processEndTime = datetime();
processedRecordCount = processedRecordCount + 1;
processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
if processStartTime gt nextProcessTime then do;
 
avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
strip(put(processedRecordCount,12.0))||' at '||
strip(put(avgProcessTime,14.1))||' ms';
writeTo.log('i', loggerString);
 
processedRecordCount = 0;
processedRecordTime = 0;
 
nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
end;
 
end;
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
mdv = .;
msv = '';
 
if strip(tsl)='' then do;
 
/* nothing to do here */
 
end;
else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
if checkIfVectorExists(strip(tsl)) = 1 then do;
 
getVector (strip(tsl));
 
if strip(st.getString(strip(tsl),0))='double' then do;
mdv = st.getDouble(strip(tsl),3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(tsl),3));
end;
 
deleteVector (tsl);
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
msv='';
end;
else do;
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
end;
 
if mdv=. and strip(msv)='' then do;
mdv = .;
msv = '';
end;
else do;
mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
msv = '';
end;
 
deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
mdv = .;
msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
end;
 
end;
else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
mdv = .;
msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
end;
 
end;
 
end;
 
method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
char(1) chkThisAsset,
integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
/* assign the search values to variables to facilitate checking previous searches */
getAssetID        = strip(aID);
getAssetType      = strip(aType);
getAttributeID    = strip(attribID);
 
getAttribMetric   = strip(attribMetric);
if strip(getAttribMetric)='' then getAttribMetric='currentValue';
getNavMethod      = strip(upcase(navMth));
if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
getAttribIDKnownAsset=strip(attribIDKnownAsset);
if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
getChkThisAssetYN = strip(upcase(chkThisAsset));
if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
getMaxUpTrav      = maxUp;
if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
getExactUpYN      = strip(upcase(exactUp));
if strip(getExactUpYN)='' then getExactUpYN='N';
getMaxDownTrav    = maxDown;
if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
getExactDownYN    = strip(upcase(exactDown));
if strip(getExactDownYN)='' then getExactDownYN='N';
 
/* initiate the return values */
thisFoundDouble=.;
thisFoundString='';
foundValue=0;
 
if symUpdateNeeded=0 then do;
/* if the symlinks have already been established */
 
symLink='';
rcGetSymLink=symLinkList.find();
getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
end;
else if getNavMethod='NAVIGATE' then do;
/* if the symlinks need to be reestablished */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
/* if this asset is the same asset type, then only try to pull from there */
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
else do;
/* otherwise navigate as instructed to try to find the requested value */
 
/* navigate all hierarchies until you find the asset-attribute */
thisStartAssetID=strip(getAssetID);
numHierarchies=0;
getVector ('hierarchyList');
numHierarchies=st.getInt('hierarchyList',0);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
do cntHier=1 to numHierarchies;
thisHierarchyName=st.getString('hierarchyList',cntHier);
 
/* if a specific hierarchy is selected, navigate only that one */
if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
/* walk up the hierarchy from that assetID */
if foundValue=0 and getMaxUpTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
thisAssetID=strip(thisStartAssetID);
getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate up the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add parents for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
or
getExactUpYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk up the hierarchy */
 
/* walk down the hierarchy from that assetID */
if foundValue=0 and getMaxDownTrav gt 0 then do;
 
/* initialize the search */
thisNetworkListHI.delete();
nextNetworkListHI.delete();
previouslyVisitedListHI.delete();
rc=thisNetworkList.clear();
rc=nextNetworkList.clear();
rc=previouslyVisitedList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
nextNetworkListHI = _new_ hiter('nextNetworkList');
previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
thisAssetID=strip(thisStartAssetID);
 
getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
 
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
if rcHasNext ne 0 then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* store the number of items in the list of assets */
numThisLevel=nextNetworkList.num_items;
 
traversalCnt=1;
 
/* navigate down the hierarchy to try to find the information requested */
do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
/* copy nextNetworkList to thisNetworkList */
thisNetworkListHI.delete();
rc=thisNetworkList.clear();
thisNetworkListHI = _new_ hiter('thisNetworkList');
rcHasNext=nextNetworkListHI.first();
do while (rcHasNext=0);
 
thisAssetID=nextAssetID;
rc=thisNetworkList.add();
rcHasNext=nextNetworkListHI.next();
 
end;
nextNetworkListHI.delete();
rc=nextNetworkList.clear();
nextNetworkListHI = _new_ hiter('nextNetworkList');
 
/* iterate through the assets on this level */
rcHasThis=thisNetworkListHI.first();
do while (rcHasThis=0 and foundValue=0);
 
/* add children for each asset to nextNetworkList as each gets processed */
numNextLevel=0;
getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
do cntLevel=1 to numNextLevel;
nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
 
rcHasNext=nextNetworkList.find();
rcHasPrvVis=previouslyVisitedList.find();
if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
rc=nextNetworkList.add();
end;
end;
deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
/* get the asset type */
thisAssetType='';
getVector ('asset|'||strip(thisAssetID));
thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
deleteVector ('asset|'||strip(thisAssetID));
 
/* if the asset type matches then get the current value of the attribute */
if strip(getAssetType)=strip(thisAssetType) and
( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
or
getExactDownYN='N'
) then do;
 
if strip(getAttributeID)='assetID' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetID';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttributeID)='assetLabel' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|assetLabel';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastValue' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='lastTime' then do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else do;
 
foundValue=1;
symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
/* add the asset to the list of previously visited assets so it is not checked again */
rcHasPrvVis=previouslyVisitedList.find();
if rcHasPrvVis ne 0 then do;
rc=previouslyVisitedList.add();
end;
 
/* go to the next asset in the list */
rcHasThis=thisNetworkListHI.next();
 
end;
 
traversalCnt=traversalCnt+1;
 
numThisLevel=nextNetworkList.num_items;
 
end;
 
end;
/* end of walk down the hierarchy */
 
end;
/* iteration over hierarchies */
deleteVector ('hierarchyList');
 
end;
/* end of navigation to find value */
 
end;
else if getNavMethod='KNOWNASSETID' then do;
/* if the asset ID to pull the data from is known */
 
/* get the assetType */
thisAssetID=strip(getAssetID);
thisAssetType='';
getVector('asset|'||strip(thisAssetID));
thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
deleteVector('asset|'||strip(thisAssetID));
 
whichAssetID = '';
 
if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
end;
 
/* now pull the desired value */
if strip(whichAssetID) ne '' then do;
 
if strip(getAttribMetric)='lastValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
else if strip(getAttribMetric)='currentValue' then do;
 
symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
rc=symLinkList.add();
 
getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
end;
 
end;
 
end;
 
end;
 
method calculate_track_travelTimeRollingAvg(
bigint outputTimestamp,
char(300) assetID,
in_out double myNewDoubleValue,
in_out char   myNewStringValue
);
 
/* has access to this from the call itself */
/* char(100) assetType */
/* char(100) attributeType */
/* char(100) attributeID */
/* char(100) targetAttributeID */
/* char(100) oldTimePeriodNumeric */
/* char(100) oldTimePeriodAssetType */
/* char(100) oldTimePeriodAttributeID */
/* char(100) recentTimePeriodNumeric */
/* char(100) recentTimePeriodAssetType */
/* char(100) recentTimePeriodAttributeID */
/* char(100) maxHistorySeconds */
/* char(100) summaryLogic */
 
/* ******************************************************************** */
/* insert logic here to compute value given all of the information in   */
/* the logic definition file and the current contents of the data model */
/* ******************************************************************** */
 
/* initiate output values */
myNewDoubleValue=.;
myNewStringValue='';
rc=thisAggList.clear();
 
/* find the min and max time periods */
if strip(oldTimePeriodAssetType) in ('','NA','.') then do;
oldLagTimeSeconds=inputn(oldTimePeriodNumeric,'16.');
end;
else do;
getAttributeValue(assetID,oldTimePeriodAssetType,oldTimePeriodAttributeID,'currentValue',
'navigate','','','Y',maxTraversals,'N',maxTraversals,'N',
thisFoundDoubleResult,thisFoundStringResult);
 
oldLagTimeSeconds = thisFoundDoubleResult;
if oldLagTimeSeconds gt inputn(maxHistorySeconds,'16.') then oldLagTimeSeconds=inputn(maxHistorySeconds,'16.');
end;
oldLagSlot = ceil( (oldLagTimeSeconds * 1.0) / (@historyInterval@ * 1.0) );
 
if strip(recentTimePeriodAssetType) in ('','NA','.') then do;
recentLagTimeSeconds=inputn(recentTimePeriodNumeric,'16.');
end;
else do;
getAttributeValue(assetID,recentTimePeriodAssetType,recentTimePeriodAttributeID,'currentValue',
'navigate','','','Y',maxTraversals,'N',maxTraversals,'N',
thisFoundDoubleResult,thisFoundStringResult);
 
recentLagTimeSeconds = thisFoundDoubleResult;
if recentLagTimeSeconds gt inputn(maxHistorySeconds,'16.') then recentLagTimeSeconds=inputn(maxHistorySeconds,'16.');
end;
recentLagSlot = ceil( (recentLagTimeSeconds * 1.0) / (@historyInterval@ * 1.0) );
 
getVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue');
dataType = st.getString('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue',0);
getVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history');
maxHistoryLength    = st.getInt('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history',2);
baseHistoryLocation = st.getInt('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history',3);
 
impliedRecCount = abs(oldLagSlot-recentLagSlot)+1;
countRecs=0;
do lagSlotCounter = oldLagSlot to recentLagSlot by -1;
 
/* obtain the value from the history vector for the asset/attribute */
if lagSlotCounter=0 then do;
 
if dataType='double' then do;
currentValue=st.getDouble('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue',3);
end;
else do;
currentValue=.;
end;
 
end;
else do;
 
/* adjust lag slot for where the base history location is */
if lagSlotCounter le maxHistoryLength then do;
 
lagSlot = baseHistoryLocation - lagSlotCounter + 1;
if lagSlot lt 1 then lagSlot = lagSlot + maxHistoryLength;
 
if dataType='double' then do;
currentValue=st.getDouble('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history',int(lagSlot*2)+3);
end;
else do;
currentValue=.;
end;
 
end;
 
end;
 
if currentValue ne . then do;
countRecs=countRecs+1;
rc=thisAggList.add();
end;
 
end;
 
/* if we have a full complement of records for the aggregation, the calculate */
if countRecs=impliedRecCount then do;
 
/* now iterate over thisAggList to create desired summary - sum avg min max */
aggHelp1=.;
aggHelp2=0;
rcHasValue=thisAggListHI.first();
do while (rcHasValue=0);
 
if summaryLogic='sum' then do;
 
aggHelp1=sum(aggHelp1,currentValue);
 
end;
else if summaryLogic='avg' then do;
 
aggHelp1=sum(aggHelp1,currentValue);
aggHelp2=aggHelp2+1;
 
end;
else if summaryLogic='max' then do;
 
if currentValue gt aggHelp1 then aggHelp1=currentValue;
 
end;
else if summaryLogic='min' then do;
 
if currentValue lt aggHelp1 and currentValue ne . and aggHelp1 ne . then aggHelp1=currentValue;
 
end;
 
/* go to the next value in the list */
rcHasValue=thisAggListHI.next();
 
end;
 
if summaryLogic='sum' then do;
 
myNewDoubleValue = aggHelp1;
 
end;
else if summaryLogic='avg' then do;
 
if aggHelp2 ne 0 then do;
myNewDoubleValue = aggHelp1 / aggHelp2;
end;
 
end;
else if summaryLogic='max' then do;
 
myNewDoubleValue = aggHelp1;
 
end;
else if summaryLogic='min' then do;
 
myNewDoubleValue = aggHelp1;
 
end;
 
end;
else do;
 
myNewDoubleValue = .;
 
end;
 
deleteVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|currentValue');
deleteVector('asset|'||strip(assetID)||'|attribute|'||strip(targetAttributeID)||'|history');
 
end;
 
method runCompute_track_travelTimeRollingAvg(bigint           key1,
bigint           triggerTimestamp,
in_out char(200) previousWindowName,
in_out char(10) _outOpcode);
 
startMonitoring();
 
previousWindowName='compute_track_travelTimeRollingAvg';
_outOpcode='insert';
 
/* get indicator on whether to use symlinks - and clear the symlinklist if needed */
getVector ('symUpdateNeeded');
symUpdateNeeded = st.getInt('symUpdateNeeded',0);
deleteVector ('symUpdateNeeded');
if symUpdateNeeded = 1 then do;
symLinkListHI.delete();
rc=symLinkList.clear();
symLinkListHI = _new_ hiter('symLinkList');
end;
 
/* obtain a list of all assets of the specified asset type */
numAssets=0;
getVector ('assetType|'||strip(assetType)||'|assetList');
numAssets=st.getInt('assetType|'||strip(assetType)||'|assetList',0);
 
/* obtain the min and max values for the attribute */
acceptableMin      = .;
acceptableMinLogic = '';
acceptableMax      = .;
acceptableMaxLogic = '';
 
getVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
acceptableMin      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),6);
acceptableMinLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),7);
acceptableMax      = st.getDouble('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),8);
acceptableMaxLogic = st.getString('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID),9);
deleteVector ('assetType|'||strip(assetType)||'|attribute|'||strip(attributeID));
 
/* iterate over all assets on the specified asset type */
do cntAssets=1 to numAssets;
_assetID=strip(st.getString('assetType|'||strip(assetType)||'|assetList',cntAssets));
 
calculate_track_travelTimeRollingAvg(
triggerTimestamp,
_assetID,
myNewDoubleValueResult,
myNewStringValueResult
);
 
/* retrieve the vector to update */
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
getVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
dataType = st.getString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',0);
 
/* enforce min and max on each derived attribute */
if dataType='double' then do;
if acceptableMin ne -999999999999 then do;
if myNewDoubleValueResult gt -999999999999 and myNewDoubleValueResult lt acceptableMin then do;
if acceptableMinLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMinLogic='limit' then do;
myNewDoubleValueResult=acceptableMin;
end;
end;
end;
if acceptableMax ne 999999999999 then do;
if myNewDoubleValueResult gt acceptableMax then do;
if acceptableMaxLogic='missing' then do;
myNewDoubleValueResult=.;
end;
else if acceptableMaxLogic='limit' then do;
myNewDoubleValueResult=acceptableMax;
end;
end;
end;
end;
 
/* store the new value in the appropriate shared hash location */
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue',3,myNewStringValueResult);
end;
 
rc = st.setLong('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',2,triggerTimestamp);
if dataType='double' then do;
rc = st.setDouble('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewDoubleValueResult);
end;
else do;
rc = st.setString('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue',3,myNewStringValueResult);
end;
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|currentValue');
 
replaceVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
deleteVector ('asset|'||strip(_assetID)||'|attribute|'||strip(attributeID)||'|lastValue');
 
end;
deleteVector('assetType|'||strip(assetType)||'|assetList');
 
endMonitoring();
 
end;
 
endpackage;]]></code>
</mas-module>
<mas-module module="enrichDataModelEndModule" language="ds2" func-names="runEnrichDataModelEnd">
<code><![CDATA[ds2_options sas;
 
package enrichDataModelEndPackage / overwrite = yes;
 
declare bigint  gateNum numRequirements thisRequirementNum;
declare integer allGatesOpenYN numItems foundTHIS cntALL cntTHIS;
declare double  rc rc1 rc1s rc2 rc2s rcsleep ;
declare char(250) tempItem;
 
declare package masstate st();
declare package logger writeTo();
declare char(200) loggerString;
 
method init();
 
end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
method openGate (bigint gt, bigint tr, bigint tdtm);
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)),0,tdtm);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.)));
 
loggerString = 'NOTE: Opened gate'||strip(put(gt,z4.))||'req'||strip(put(tr,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method checkAllGates (bigint gt, bigint nr, bigint tdtm) returns integer;
 
declare integer i nrs;
declare bigint thisTimestamp;
 
nrs=0;
do i=1 to nr;
 
thisTimestamp=0;
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
thisTimestamp=st.getLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0);
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
if thisTimestamp = tdtm then nrs = nrs + 1;
 
end;
 
loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
if nrs=nr then return 1;
else           return 0;
 
end;
 
method closeAllGates (bigint gt, bigint nr);
 
declare integer i;
 
do i=1 to nr;
 
getVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
rc = st.setLong('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)),0,0);
replaceVector ('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
deleteVector('gate'||strip(put(gt,z4.))||'req'||strip(put(i,z4.)));
 
end;
 
loggerString = 'NOTE: Reset gate'||strip(put(gt,z4.));
if '@SAFLogLevel@' in ('trace') then writeTo.log('i', loggerString);
 
end;
 
method runEnrichDataModelEnd(bigint     key,
bigint     triggerTimestamp,
char(200)  previousWindowName,
in_out char(10) _outOpcode);
 
gateNum=10;
numRequirements=15;
if 1=0 then thisRequirementNum=0;
else if previousWindowName='compute_station_expectedNextTrain1ID' then thisRequirementNum=1;
else if previousWindowName='compute_station_expectedNextTrain2ID' then thisRequirementNum=2;
else if previousWindowName='compute_station_expectedNextTrain2Time' then thisRequirementNum=3;
else if previousWindowName='compute_station_nextStationTrain1' then thisRequirementNum=4;
else if previousWindowName='compute_station_nextStationTrain2' then thisRequirementNum=5;
else if previousWindowName='compute_station_nextTrackTrain1' then thisRequirementNum=6;
else if previousWindowName='compute_station_nextTrackTrain2' then thisRequirementNum=7;
else if previousWindowName='compute_station_numTrainsAtNextStation' then thisRequirementNum=8;
else if previousWindowName='compute_station_numTrainsAtPrevStation' then thisRequirementNum=9;
else if previousWindowName='compute_station_numTrainsEnrouteFromThis' then thisRequirementNum=10;
else if previousWindowName='compute_station_numTrainsEnrouteToThis' then thisRequirementNum=11;
else if previousWindowName='compute_station_trainInStation' then thisRequirementNum=12;
else if previousWindowName='compute_station_waitTimeRollingAvg' then thisRequirementNum=13;
else if previousWindowName='compute_train_trainLatitude' then thisRequirementNum=14;
else if previousWindowName='compute_train_trainLongitude' then thisRequirementNum=15;
else                                                     thisRequirementNum=0;
 
/*** open this gate by setting gate info to triggerTimestamp ***/
openGate (gateNum, thisRequirementNum, triggerTimestamp);
 
/*** now check all gates to see that they are all equal to triggerTimestamp or if any are still closed ***/
allGatesOpenYN=checkAllGates(gateNum, numRequirements, triggerTimestamp);
 
/*** if all gates are open and equal to triggerTimestamp then let the record through and close the gates to prep for next trigger ***/
if allGatesOpenYN=1 then do;
_outOpcode='insert';
closeAllGates (gateNum, numRequirements);
end;
else _outOpcode='delete';
 
end;
 
endpackage;]]></code>
</mas-module>
    <mas-module module="outputRecords_stationModule" language="ds2" func-names="runOutputRecords_station">
      <code><![CDATA[ds2_options sas;
 
        package outputRecords_stationPackage / overwrite = yes;
 
          declare double    rc rc1 rc1s rc2 rc2s rcsleep _rcFoundAttribute_ _rcOutputColumnDefinitions_;
          declare integer   numAssets numOutputAssets numAttributes cpycnt cpycnt2 cntHier;
          declare integer   numHierarchies numParents numChildren numItems notLikely;
          declare integer   foundTHIS cntALL cntTHIS symUpdateNeeded hasSymlink numMaxFill foundValue;
          declare char(75)  thisAssetType outputAssetType thisColAssetType;
          declare char(300) thisAssetID newAssetID outputAssetID thisParentAssetID thisChildAssetID;
          declare char(300) tempItem thisOutputAssetID thisStartAssetID;
          declare char(100) thisAttributeID thisColAttributeID;
          declare char(100) thisValueString;
          declare double    thisValueDouble myDoubleValue;
          declare char(25)  thisHierarchy thisHierarchyName;
          declare char(50)  myStringValue;
          declare bigint    nextDeleteInQueue;
 
          declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
          declare char(500) symLink;
          declare integer   cntLevel maxTraversals numNextLevel numThisLevel traversalCnt;
          declare char(300) getAssetID nextAssetID whichAssetID;
          declare char(75)  getAssetType;
          declare char(100) getAttributeID getAttribIDKnownAsset;
          declare char(20)  getNavMethod getAttribMetric;
          declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
          declare integer   getMaxUpTrav getMaxDownTrav;
 
          declare package   masstate st();
          declare package   logger writeTo();
          declare char(200) loggerString;
 
          /* monitoring */
          declare double processedRecordCount processedRecordTime processStartTime;
          declare double processEndTime nextProcessTime avgProcessTime;
          declare char(200) thisModuleName;
          /* monitoring */
 
          declare char(12)  thisColType thisDataType;
          declare char(32)  thisColName;
          declare package hash  outputColumnDefinitions;
          declare package hash  outputColumnDefinitionsAttr;
          declare package hiter outputColumnDefinitionsHI;
          declare package hiter outputColumnDefinitionsAttrHI;
 
          declare package hash  thisNetworkList;
          declare package hiter thisNetworkListHI;
          declare package hash  nextNetworkList;
          declare package hiter nextNetworkListHI;
          declare package hash  previouslyVisitedList;
          declare package hiter previouslyVisitedListHI;
          declare package hash  symLinkList;
          declare package hiter symLinkListHI;
 
          declare char(1) outputRecordsToABT;
 
          method init();
 
            maxTraversals = 10;
 
            /* monitoring */
            thisModuleName='outputRecords_stationModule';
            processedRecordCount = 0;
            processedRecordTime = 0;
            processStartTime = .;
            processEndTime = .;
            nextProcessTime = .;
            avgProcessTime = .;
            /* monitoring */
 
            /* initialize the hash tables */
            thisNetworkList = _new_ hash(3,'');
            thisNetworkList.multidata('no');
            thisNetworkList.defineKey('thisAssetID');
            thisNetworkList.defineData('thisAssetID');
            thisNetworkList.defineDone();
 
            thisNetworkListHI = _new_ hiter('thisNetworkList');
 
            nextNetworkList = _new_ hash(3,'');
            nextNetworkList.multidata('no');
            nextNetworkList.defineKey('nextAssetID');
            nextNetworkList.defineData('nextAssetID');
            nextNetworkList.defineDone();
 
            nextNetworkListHI = _new_ hiter('nextNetworkList');
 
            previouslyVisitedList = _new_ hash(3,'');
            previouslyVisitedList.multidata('no');
            previouslyVisitedList.defineKey('thisAssetID');
            previouslyVisitedList.defineData('thisAssetID');
            previouslyVisitedList.defineDone();
 
            previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
            symLinkList = _new_ hash(3,'');
            symLinkList.multidata('no');
            symLinkList.defineKey('getAssetID');
            symLinkList.defineKey('getAssetType');
            symLinkList.defineKey('getAttributeID');
            symLinkList.defineKey('getAttribMetric');
            symLinkList.defineKey('getNavMethod');
            symLinkList.defineKey('getAttribIDKnownAsset');
            symLinkList.defineKey('getChkThisAssetYN');
            symLinkList.defineKey('getMaxUpTrav');
            symLinkList.defineKey('getExactUpYN');
            symLinkList.defineKey('getMaxDownTrav');
            symLinkList.defineKey('getExactDownYN');
            symLinkList.defineData('symLink');
            symLinkList.defineDone();
 
            symLinkListHI = _new_ hiter('symLinkList');
            /* initialize the hash tables */
 
            numMaxFill=10000;
 
            /* create a hash table with all the columns to populate */
            outputColumnDefinitions = _new_ hash(3,'');
            outputColumnDefinitions.multidata('no');
            outputColumnDefinitions.defineKey('thisColName');
            outputColumnDefinitions.defineData('thisColName');
            outputColumnDefinitions.defineData('thisColType');
            outputColumnDefinitions.defineData('thisColAssetType');
            outputColumnDefinitions.defineData('thisColAttributeID');
            outputColumnDefinitions.defineDone();
 
            outputColumnDefinitionsHI = _new_ hiter('outputColumnDefinitions');
 
            thisColName='expectedNextTrain1ID'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='expectedNextTrain1ID'; outputColumnDefinitions.add();
            thisColName='expectedNextTrain1Time'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='expectedNextTrain1Time'; outputColumnDefinitions.add();
            thisColName='expectedNextTrain2ID'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='expectedNextTrain2ID'; outputColumnDefinitions.add();
            thisColName='expectedNextTrain2Time'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='expectedNextTrain2Time'; outputColumnDefinitions.add();
            thisColName='lastDepartedTrain'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='lastDepartedTrain'; outputColumnDefinitions.add();
            thisColName='lastDepartedTrainStatus'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='lastDepartedTrainStatus'; outputColumnDefinitions.add();
            thisColName='nextStationTrain1'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='nextStationTrain1'; outputColumnDefinitions.add();
            thisColName='nextStationTrain2'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='nextStationTrain2'; outputColumnDefinitions.add();
            thisColName='nextTrackTrain1'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='nextTrackTrain1'; outputColumnDefinitions.add();
            thisColName='nextTrackTrain2'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='nextTrackTrain2'; outputColumnDefinitions.add();
            thisColName='numTrainsAtNextStation'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='numTrainsAtNextStation'; outputColumnDefinitions.add();
            thisColName='numTrainsAtPrevStation'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='numTrainsAtPrevStation'; outputColumnDefinitions.add();
            thisColName='numTrainsEnrouteFromThis'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='numTrainsEnrouteFromThis'; outputColumnDefinitions.add();
            thisColName='numTrainsEnrouteToThis'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='numTrainsEnrouteToThis'; outputColumnDefinitions.add();
            thisColName='prevStationTrain1'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='prevStationTrain1'; outputColumnDefinitions.add();
            thisColName='prevStationTrain2'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='prevStationTrain2'; outputColumnDefinitions.add();
            thisColName='prevTrackTrain1'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='prevTrackTrain1'; outputColumnDefinitions.add();
            thisColName='prevTrackTrain2'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='prevTrackTrain2'; outputColumnDefinitions.add();
            thisColName='prevTrackTravelTime'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='prevTrackTravelTime'; outputColumnDefinitions.add();
            thisColName='route'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='route'; outputColumnDefinitions.add();
            thisColName='stationLatitude'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='stationLatitude'; outputColumnDefinitions.add();
            thisColName='stationLongitude'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='stationLongitude'; outputColumnDefinitions.add();
            thisColName='trainArrival'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='trainArrival'; outputColumnDefinitions.add();
            thisColName='trainDepartureFrom'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='trainDepartureFrom'; outputColumnDefinitions.add();
            thisColName='trainDepartureTo'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='trainDepartureTo'; outputColumnDefinitions.add();
            thisColName='trainInStation'; thisColType='string'; thisColAssetType='station'; thisColAttributeID='trainInStation'; outputColumnDefinitions.add();
            thisColName='waitTime'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='waitTime'; outputColumnDefinitions.add();
            thisColName='waitTimeRollingAvg'; thisColType='double'; thisColAssetType='station'; thisColAttributeID='waitTimeRollingAvg'; outputColumnDefinitions.add();
 
          end;
 
 
          method startMonitoring();
 
            if strip('@performanceMonitoring@')='true' then do;
              processStartTime = datetime();
              if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
            end;
 
          end;
 
          method endMonitoring();
 
            if strip('@performanceMonitoring@')='true' then do;
 
              processEndTime = datetime();
              processedRecordCount = processedRecordCount + 1;
              processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
              if processStartTime gt nextProcessTime then do;
 
                avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
                loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
                               ' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
                               strip(put(processedRecordCount,12.0))||' at '||
                               strip(put(avgProcessTime,14.1))||' ms';
                writeTo.log('i', loggerString);
 
                processedRecordCount = 0;
                processedRecordTime = 0;
 
                nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
              end;
 
            end;
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
            mdv = .;
            msv = '';
 
            if strip(tsl)='' then do;
 
              /* nothing to do here */
 
            end;
            else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
              if checkIfVectorExists(strip(tsl)) = 1 then do;
 
                getVector (strip(tsl));
 
                if strip(st.getString(strip(tsl),0))='double' then do;
                  mdv = st.getDouble(strip(tsl),3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(tsl),3));
                end;
 
                deleteVector (tsl);
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
              if checkIfVectorExists(strip(tsl)) = 1 then do;
 
                getVector (strip(tsl));
 
                if strip(st.getString(strip(tsl),0))='double' then do;
                  mdv = st.getDouble(strip(tsl),3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(tsl),3));
                end;
 
                deleteVector (tsl);
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
                getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
                if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
                  mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
                end;
 
                if mdv=. and strip(msv)='' then do;
                  mdv = .;
                  msv = '';
                end;
                else do;
                  mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
                  msv = '';
                end;
 
                deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
                mdv = .;
                msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
                getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
                mdv = .;
                msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
                deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
              end;
 
            end;
 
          end;
 
          method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
                                    char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
                                    char(1) chkThisAsset,
                                    integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
                                    in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
            /* assign the search values to variables to facilitate checking previous searches */
            getAssetID        = strip(aID);
            getAssetType      = strip(aType);
            getAttributeID    = strip(attribID);
 
            getAttribMetric   = strip(attribMetric);
            if strip(getAttribMetric)='' then getAttribMetric='currentValue';
            getNavMethod      = strip(upcase(navMth));
            if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
            getAttribIDKnownAsset=strip(attribIDKnownAsset);
            if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
            getChkThisAssetYN = strip(upcase(chkThisAsset));
            if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
            getMaxUpTrav      = maxUp;
            if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
            getExactUpYN      = strip(upcase(exactUp));
            if strip(getExactUpYN)='' then getExactUpYN='N';
            getMaxDownTrav    = maxDown;
            if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
            getExactDownYN    = strip(upcase(exactDown));
            if strip(getExactDownYN)='' then getExactDownYN='N';
 
            /* initiate the return values */
            thisFoundDouble=.;
            thisFoundString='';
            foundValue=0;
 
            if symUpdateNeeded=0 then do;
            /* if the symlinks have already been established */
 
              symLink='';
              rcGetSymLink=symLinkList.find();
              getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
            end;
            else if getNavMethod='NAVIGATE' then do;
            /* if the symlinks need to be reestablished */
 
              /* get the assetType */
              thisAssetID=strip(getAssetID);
              thisAssetType='';
              getVector('asset|'||strip(thisAssetID));
              thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
              deleteVector('asset|'||strip(thisAssetID));
 
              if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
              /* if this asset is the same asset type, then only try to pull from there */
 
                if strip(getAttributeID)='assetID' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|assetID';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttributeID)='assetLabel' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='lastValue' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='lastTime' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
 
              end;
              else do;
              /* otherwise navigate as instructed to try to find the requested value */
 
                /* navigate all hierarchies until you find the asset-attribute */
                thisStartAssetID=strip(getAssetID);
                numHierarchies=0;
                getVector ('hierarchyList');
                numHierarchies=st.getInt('hierarchyList',0);
 
                /* if a specific hierarchy is selected, navigate only that one */
                if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
                do cntHier=1 to numHierarchies;
                  thisHierarchyName=st.getString('hierarchyList',cntHier);
 
                  /* if a specific hierarchy is selected, navigate only that one */
                  if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
                  /* walk up the hierarchy from that assetID */
                  if foundValue=0 and getMaxUpTrav gt 0 then do;
 
                    /* initialize the search */
                    thisNetworkListHI.delete();
                    nextNetworkListHI.delete();
                    previouslyVisitedListHI.delete();
                    rc=thisNetworkList.clear();
                    rc=nextNetworkList.clear();
                    rc=previouslyVisitedList.clear();
                    thisNetworkListHI = _new_ hiter('thisNetworkList');
                    nextNetworkListHI = _new_ hiter('nextNetworkList');
                    previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
                    thisAssetID=strip(thisStartAssetID);
                    getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
                    numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
                    do cntLevel=1 to numNextLevel;
                      nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
                      rcHasNext=nextNetworkList.find();
                      if rcHasNext ne 0 then do;
                        rc=nextNetworkList.add();
                      end;
                    end;
                    deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
                    /* store the number of items in the list of assets */
                    numThisLevel=nextNetworkList.num_items;
 
                    traversalCnt=1;
 
                    /* navigate up the hierarchy to try to find the information requested */
                    do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
                      /* copy nextNetworkList to thisNetworkList */
                      thisNetworkListHI.delete();
                      rc=thisNetworkList.clear();
                      thisNetworkListHI = _new_ hiter('thisNetworkList');
                      rcHasNext=nextNetworkListHI.first();
                      do while (rcHasNext=0);
 
                        thisAssetID=nextAssetID;
                        rc=thisNetworkList.add();
                        rcHasNext=nextNetworkListHI.next();
 
                      end;
                      nextNetworkListHI.delete();
                      rc=nextNetworkList.clear();
                      nextNetworkListHI = _new_ hiter('nextNetworkList');
 
                      /* iterate through the assets on this level */
                      rcHasThis=thisNetworkListHI.first();
                      do while (rcHasThis=0 and foundValue=0);
 
                        /* add parents for each asset to nextNetworkList as each gets processed */
                        numNextLevel=0;
                        getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
                        numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
                        do cntLevel=1 to numNextLevel;
                          nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
                          rcHasNext=nextNetworkList.find();
                          rcHasPrvVis=previouslyVisitedList.find();
                          if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
                            rc=nextNetworkList.add();
                          end;
                        end;
                        deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
                        /* get the asset type */
                        thisAssetType='';
                        getVector ('asset|'||strip(thisAssetID));
                        thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
                        deleteVector ('asset|'||strip(thisAssetID));
 
                        /* if the asset type matches then get the current value of the attribute */
                        if strip(getAssetType)=strip(thisAssetType) and
                            ( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
                                or
                              getExactUpYN='N'
                            ) then do;
 
                          if strip(getAttributeID)='assetID' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetID';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttributeID)='assetLabel' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastValue' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastTime' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
 
                        end;
 
                        /* add the asset to the list of previously visited assets so it is not checked again */
                        rcHasPrvVis=previouslyVisitedList.find();
                        if rcHasPrvVis ne 0 then do;
                          rc=previouslyVisitedList.add();
                        end;
 
                        /* go to the next asset in the list */
                        rcHasThis=thisNetworkListHI.next();
 
                      end;
 
                      traversalCnt=traversalCnt+1;
 
                      numThisLevel=nextNetworkList.num_items;
 
                    end;
 
                  end;
                  /* end of walk up the hierarchy */
 
                  /* walk down the hierarchy from that assetID */
                  if foundValue=0 and getMaxDownTrav gt 0 then do;
 
                    /* initialize the search */
                    thisNetworkListHI.delete();
                    nextNetworkListHI.delete();
                    previouslyVisitedListHI.delete();
                    rc=thisNetworkList.clear();
                    rc=nextNetworkList.clear();
                    rc=previouslyVisitedList.clear();
                    thisNetworkListHI = _new_ hiter('thisNetworkList');
                    nextNetworkListHI = _new_ hiter('nextNetworkList');
                    previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
                    thisAssetID=strip(thisStartAssetID);
                    getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
                    numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
                    do cntLevel=1 to numNextLevel;
                      nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
                      rcHasNext=nextNetworkList.find();
                      if rcHasNext ne 0 then do;
                        rc=nextNetworkList.add();
                      end;
                    end;
                    deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
                    /* store the number of items in the list of assets */
                    numThisLevel=nextNetworkList.num_items;
 
                    traversalCnt=1;
 
                    /* navigate down the hierarchy to try to find the information requested */
                    do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
                      /* copy nextNetworkList to thisNetworkList */
                      thisNetworkListHI.delete();
                      rc=thisNetworkList.clear();
                      thisNetworkListHI = _new_ hiter('thisNetworkList');
                      rcHasNext=nextNetworkListHI.first();
                      do while (rcHasNext=0);
 
                        thisAssetID=nextAssetID;
                        rc=thisNetworkList.add();
                        rcHasNext=nextNetworkListHI.next();
 
                      end;
                      nextNetworkListHI.delete();
                      rc=nextNetworkList.clear();
                      nextNetworkListHI = _new_ hiter('nextNetworkList');
 
                      /* iterate through the assets on this level */
                      rcHasThis=thisNetworkListHI.first();
                      do while (rcHasThis=0 and foundValue=0);
 
                        /* add children for each asset to nextNetworkList as each gets processed */
                        numNextLevel=0;
                        getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
                        numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
                        do cntLevel=1 to numNextLevel;
                          nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
                          rcHasNext=nextNetworkList.find();
                          rcHasPrvVis=previouslyVisitedList.find();
                          if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
                            rc=nextNetworkList.add();
                          end;
                        end;
                        deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
                        /* get the asset type */
                        thisAssetType='';
                        getVector ('asset|'||strip(thisAssetID));
                        thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
                        deleteVector ('asset|'||strip(thisAssetID));
 
                        /* if the asset type matches then get the current value of the attribute */
                        if strip(getAssetType)=strip(thisAssetType) and
                            ( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
                                or
                              getExactDownYN='N'
                            ) then do;
 
                          if strip(getAttributeID)='assetID' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetID';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttributeID)='assetLabel' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastValue' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastTime' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
 
                        end;
 
                        /* add the asset to the list of previously visited assets so it is not checked again */
                        rcHasPrvVis=previouslyVisitedList.find();
                        if rcHasPrvVis ne 0 then do;
                          rc=previouslyVisitedList.add();
                        end;
 
                        /* go to the next asset in the list */
                        rcHasThis=thisNetworkListHI.next();
 
                      end;
 
                      traversalCnt=traversalCnt+1;
 
                      numThisLevel=nextNetworkList.num_items;
 
                    end;
 
                  end;
                  /* end of walk down the hierarchy */
 
                end;
                /* iteration over hierarchies */
                deleteVector ('hierarchyList');
 
              end;
              /* end of navigation to find value */
 
            end;
            else if getNavMethod='KNOWNASSETID' then do;
            /* if the asset ID to pull the data from is known */
 
              /* get the assetType */
              thisAssetID=strip(getAssetID);
              thisAssetType='';
              getVector('asset|'||strip(thisAssetID));
              thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
              deleteVector('asset|'||strip(thisAssetID));
 
              whichAssetID = '';
 
              if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
                getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
                whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
                deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
              end;
 
              /* now pull the desired value */
              if strip(whichAssetID) ne '' then do;
 
                if strip(getAttribMetric)='lastValue' then do;
 
                  symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='currentValue' then do;
 
                  symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
 
              end;
 
            end;
 
          end;
 
          method runOutputRecords_station(bigint           key1,
                                              bigint           triggerTimestamp,
                                              in_out bigint    key2[10000],
                                              in_out char(75)  assetType[10000],
                                              in_out char(300) assetID[10000],
                                              in_out bigint    msr_timestamp[10000],
                                              in_out char(100)    expectedNextTrain1ID[10000],
                                              in_out char(20)    expectedNextTrain1Time[10000],
                                              in_out char(100)    expectedNextTrain2ID[10000],
                                              in_out char(20)    expectedNextTrain2Time[10000],
                                              in_out char(100)    lastDepartedTrain[10000],
                                              in_out char(50)    lastDepartedTrainStatus[10000],
                                              in_out char(100)    nextStationTrain1[10000],
                                              in_out char(100)    nextStationTrain2[10000],
                                              in_out char(100)    nextTrackTrain1[10000],
                                              in_out char(100)    nextTrackTrain2[10000],
                                              in_out double    numTrainsAtNextStation[10000],
                                              in_out double    numTrainsAtPrevStation[10000],
                                              in_out double    numTrainsEnrouteFromThis[10000],
                                              in_out double    numTrainsEnrouteToThis[10000],
                                              in_out char(100)    prevStationTrain1[10000],
                                              in_out char(100)    prevStationTrain2[10000],
                                              in_out char(100)    prevTrackTrain1[10000],
                                              in_out char(100)    prevTrackTrain2[10000],
                                              in_out double    prevTrackTravelTime[10000],
                                              in_out char(50)    route[10000],
                                              in_out double    stationLatitude[10000],
                                              in_out double    stationLongitude[10000],
                                              in_out char(50)    trainArrival[10000],
                                              in_out char(50)    trainDepartureFrom[10000],
                                              in_out char(50)    trainDepartureTo[10000],
                                              in_out char(50)    trainInStation[10000],
                                              in_out double    waitTime[10000],
                                              in_out double    waitTimeRollingAvg[10000],
                                              in_out char(10)  _outOpcodeArray[10000]);
 
 
            startMonitoring();
 
            getVector ('outputRecordsToABT');
            outputRecordsToABT = strip(st.getString('outputRecordsToABT',0));
            deleteVector ('outputRecordsToABT');
 
            outputAssetType='station';
            outputAssetType=tranwrd(outputAssetType,'|','^$*1*$^');
 
            /* see whether symlinks can be used or if navigation is needed */
            getVector ('symUpdateNeeded');
            symUpdateNeeded = st.getInt('symUpdateNeeded',0);
            deleteVector ('symUpdateNeeded');
            if symUpdateNeeded = 1 then rc=symLinkList.clear();
 
            if outputRecordsToABT='Y' then do;
 
              getVector('assetType|'||strip(outputAssetType)||'|outputAssetList');
 
              numAssets=st.getInt('assetType|'||strip(outputAssetType)||'|outputAssetList',0);
              do cpycnt=1 to numAssets;
 
                outputAssetID=strip(st.getString('assetType|'||strip(outputAssetType)||'|outputAssetList',cpycnt));
 
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=triggerTimestamp;
                assetType[cpycnt]=strip('station');
 
                thisOutputAssetID=tranwrd(outputAssetID,'^$*1*$^','|');
                assetID[cpycnt]=strip(thisOutputAssetID);
 
                _outOpcodeArray[cpycnt]='insert';
 
                /* now that symlinks are all established, simply pull the data into the columns */
                _rcOutputColumnDefinitions_ = outputColumnDefinitionsHI.first();
                do while (_rcOutputColumnDefinitions_ = 0);
 
                  getAttributeValue(outputAssetID,thisColAssetType,thisColAttributeID,'currentValue',
                                    'navigate','','','Y',maxTraversals,'N',maxTraversals,'N',
                                    myDoubleValue,myStringValue);
 
                  if 0=1 then notLikely=0;
                  else if thisColName='expectedNextTrain1ID' then expectedNextTrain1ID[cpycnt]    =strip(myStringValue);
                  else if thisColName='expectedNextTrain1Time' then expectedNextTrain1Time[cpycnt]    =strip(myStringValue);
                  else if thisColName='expectedNextTrain2ID' then expectedNextTrain2ID[cpycnt]    =strip(myStringValue);
                  else if thisColName='expectedNextTrain2Time' then expectedNextTrain2Time[cpycnt]    =strip(myStringValue);
                  else if thisColName='lastDepartedTrain' then lastDepartedTrain[cpycnt]    =strip(myStringValue);
                  else if thisColName='lastDepartedTrainStatus' then lastDepartedTrainStatus[cpycnt]    =strip(myStringValue);
                  else if thisColName='nextStationTrain1' then nextStationTrain1[cpycnt]    =strip(myStringValue);
                  else if thisColName='nextStationTrain2' then nextStationTrain2[cpycnt]    =strip(myStringValue);
                  else if thisColName='nextTrackTrain1' then nextTrackTrain1[cpycnt]    =strip(myStringValue);
                  else if thisColName='nextTrackTrain2' then nextTrackTrain2[cpycnt]    =strip(myStringValue);
                  else if thisColName='numTrainsAtNextStation' then numTrainsAtNextStation[cpycnt]    =myDoubleValue;
                  else if thisColName='numTrainsAtPrevStation' then numTrainsAtPrevStation[cpycnt]    =myDoubleValue;
                  else if thisColName='numTrainsEnrouteFromThis' then numTrainsEnrouteFromThis[cpycnt]    =myDoubleValue;
                  else if thisColName='numTrainsEnrouteToThis' then numTrainsEnrouteToThis[cpycnt]    =myDoubleValue;
                  else if thisColName='prevStationTrain1' then prevStationTrain1[cpycnt]    =strip(myStringValue);
                  else if thisColName='prevStationTrain2' then prevStationTrain2[cpycnt]    =strip(myStringValue);
                  else if thisColName='prevTrackTrain1' then prevTrackTrain1[cpycnt]    =strip(myStringValue);
                  else if thisColName='prevTrackTrain2' then prevTrackTrain2[cpycnt]    =strip(myStringValue);
                  else if thisColName='prevTrackTravelTime' then prevTrackTravelTime[cpycnt]    =myDoubleValue;
                  else if thisColName='route' then route[cpycnt]    =strip(myStringValue);
                  else if thisColName='stationLatitude' then stationLatitude[cpycnt]    =myDoubleValue;
                  else if thisColName='stationLongitude' then stationLongitude[cpycnt]    =myDoubleValue;
                  else if thisColName='trainArrival' then trainArrival[cpycnt]    =strip(myStringValue);
                  else if thisColName='trainDepartureFrom' then trainDepartureFrom[cpycnt]    =strip(myStringValue);
                  else if thisColName='trainDepartureTo' then trainDepartureTo[cpycnt]    =strip(myStringValue);
                  else if thisColName='trainInStation' then trainInStation[cpycnt]    =strip(myStringValue);
                  else if thisColName='waitTime' then waitTime[cpycnt]    =myDoubleValue;
                  else if thisColName='waitTimeRollingAvg' then waitTimeRollingAvg[cpycnt]    =myDoubleValue;
 
                  _rcOutputColumnDefinitions_ = outputColumnDefinitionsHI.next();
 
                end;
 
              end;
              deleteVector('assetType|'||strip(thisAssetType)||'|outputAssetList');
 
              do cpycnt=numAssets+1 to numMaxFill;
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=.;
                assetType[cpycnt]='';
                assetID[cpycnt]='';
                expectedNextTrain1ID[cpycnt]='';
                expectedNextTrain1Time[cpycnt]='';
                expectedNextTrain2ID[cpycnt]='';
                expectedNextTrain2Time[cpycnt]='';
                lastDepartedTrain[cpycnt]='';
                lastDepartedTrainStatus[cpycnt]='';
                nextStationTrain1[cpycnt]='';
                nextStationTrain2[cpycnt]='';
                nextTrackTrain1[cpycnt]='';
                nextTrackTrain2[cpycnt]='';
                numTrainsAtNextStation[cpycnt]=.;
                numTrainsAtPrevStation[cpycnt]=.;
                numTrainsEnrouteFromThis[cpycnt]=.;
                numTrainsEnrouteToThis[cpycnt]=.;
                prevStationTrain1[cpycnt]='';
                prevStationTrain2[cpycnt]='';
                prevTrackTrain1[cpycnt]='';
                prevTrackTrain2[cpycnt]='';
                prevTrackTravelTime[cpycnt]=.;
                route[cpycnt]='';
                stationLatitude[cpycnt]=.;
                stationLongitude[cpycnt]=.;
                trainArrival[cpycnt]='';
                trainDepartureFrom[cpycnt]='';
                trainDepartureTo[cpycnt]='';
                trainInStation[cpycnt]='';
                waitTime[cpycnt]=.;
                waitTimeRollingAvg[cpycnt]=.;
                _outOpcodeArray[cpycnt]='delete';
              end;
              numMaxFill=numAssets;
 
            end;
            else do;
 
              do cpycnt=1 to numMaxFill;
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=.;
                assetType[cpycnt]='';
                assetID[cpycnt]='';
                expectedNextTrain1ID[cpycnt]='';
                expectedNextTrain1Time[cpycnt]='';
                expectedNextTrain2ID[cpycnt]='';
                expectedNextTrain2Time[cpycnt]='';
                lastDepartedTrain[cpycnt]='';
                lastDepartedTrainStatus[cpycnt]='';
                nextStationTrain1[cpycnt]='';
                nextStationTrain2[cpycnt]='';
                nextTrackTrain1[cpycnt]='';
                nextTrackTrain2[cpycnt]='';
                numTrainsAtNextStation[cpycnt]=.;
                numTrainsAtPrevStation[cpycnt]=.;
                numTrainsEnrouteFromThis[cpycnt]=.;
                numTrainsEnrouteToThis[cpycnt]=.;
                prevStationTrain1[cpycnt]='';
                prevStationTrain2[cpycnt]='';
                prevTrackTrain1[cpycnt]='';
                prevTrackTrain2[cpycnt]='';
                prevTrackTravelTime[cpycnt]=.;
                route[cpycnt]='';
                stationLatitude[cpycnt]=.;
                stationLongitude[cpycnt]=.;
                trainArrival[cpycnt]='';
                trainDepartureFrom[cpycnt]='';
                trainDepartureTo[cpycnt]='';
                trainInStation[cpycnt]='';
                waitTime[cpycnt]=.;
                waitTimeRollingAvg[cpycnt]=.;
                _outOpcodeArray[cpycnt]='delete';
              end;
              numMaxFill=0;
 
            end;
 
            endMonitoring();
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="outputRecords_station_gateModule" language="ds2" func-names="runOutputRecords_station_gate">
      <code><![CDATA[ds2_options sas;
 
        package outputRecords_station_gatePackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep;
          declare integer   numAssets cpycnt;
          declare char(300) thisAssetID thisOutputAssetID;
 
          declare bigint  numRequirements thisRequirementNum;
          declare integer allGatesOpenYN;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method openGate (bigint tr, bigint tdtm);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
 
            getVector('outputGate_station_req'||strip(put(tr,z5.)));
            rc = st.setLong('outputGate_station_req'||strip(put(tr,z5.)),0,tdtm);
            replaceVector('outputGate_station_req'||strip(put(tr,z5.)));
            deleteVector('outputGate_station_req'||strip(put(tr,z5.)));
 
            loggerString = 'NOTE: Opened outputGate_station_req'||strip(put(tr,z5.));
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method checkAllGates (bigint nr, bigint tdtm) returns integer;
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i nrs;
            declare bigint thisTimestamp;
 
            nrs=0;
            do i=1 to nr;
 
              thisTimestamp=0;
              getVector('outputGate_station_req'||strip(put(i,z5.)));
              thisTimestamp=st.getLong('outputGate_station_req'||strip(put(i,z5.)),0);
              deleteVector('outputGate_station_req'||strip(put(i,z5.)));
 
              if thisTimestamp = tdtm then nrs = nrs + 1;
 
            end;
 
            loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for outputGate_station';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            if nrs=nr then return 1;
            else           return 0;
 
          end;
 
          method closeAllGates (bigint nr);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i;
 
            do i=1 to nr;
 
              getVector('outputGate_station_req'||strip(put(i,z5.)));
              rc = st.setLong('outputGate_station_req'||strip(put(i,z5.)),0,0);
              replaceVector('outputGate_station_req'||strip(put(i,z5.)));
              deleteVector('outputGate_station_req'||strip(put(i,z5.)));
 
            end;
 
            loggerString = 'NOTE: Reset outputGate_station';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method runOutputRecords_station_gate (bigint     key1,
                                                    bigint     key2,
                                                    char(75)   assetType,
                                                    char(300)  assetID,
                                                    bigint     msr_timestamp,
                                                    in_out char(10) _outOpcode);
 
            getVector('assetType|station|outputAssetList');
            numAssets=st.getInt('assetType|station|outputAssetList',0);
            thisRequirementNum=0;
            numRequirements=numAssets;
            do cpycnt=1 to numAssets;
              thisAssetID=strip(st.getString('assetType|station|outputAssetList',cpycnt));
              thisOutputAssetID=tranwrd(thisAssetID,'^$*1*$^','|');
              if strip(thisOutputAssetID)=strip(assetID) then thisRequirementNum=cpycnt;
            end;
            deleteVector('assetType|station|outputAssetList');
 
            /*** open this gate by setting gate info to triggerTimestamp ***/
            openGate (thisRequirementNum, msr_timestamp);
 
            /*** now check all gates to see that they are all equal to msr_timestamp or if any are still closed ***/
            allGatesOpenYN=checkAllGates(numRequirements, msr_timestamp);
 
            /*** if all gates are open and equal to msr_timestamp then let the record through and close the gates to prep for next trigger ***/
            if allGatesOpenYN=1 then do;
              _outOpcode='insert';
              closeAllGates (numRequirements);
            end;
            else _outOpcode='delete';
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="outputRecords_trackModule" language="ds2" func-names="runOutputRecords_track">
      <code><![CDATA[ds2_options sas;
 
        package outputRecords_trackPackage / overwrite = yes;
 
          declare double    rc rc1 rc1s rc2 rc2s rcsleep _rcFoundAttribute_ _rcOutputColumnDefinitions_;
          declare integer   numAssets numOutputAssets numAttributes cpycnt cpycnt2 cntHier;
          declare integer   numHierarchies numParents numChildren numItems notLikely;
          declare integer   foundTHIS cntALL cntTHIS symUpdateNeeded hasSymlink numMaxFill foundValue;
          declare char(75)  thisAssetType outputAssetType thisColAssetType;
          declare char(300) thisAssetID newAssetID outputAssetID thisParentAssetID thisChildAssetID;
          declare char(300) tempItem thisOutputAssetID thisStartAssetID;
          declare char(100) thisAttributeID thisColAttributeID;
          declare char(100) thisValueString;
          declare double    thisValueDouble myDoubleValue;
          declare char(25)  thisHierarchy thisHierarchyName;
          declare char(50)  myStringValue;
          declare bigint    nextDeleteInQueue;
 
          declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
          declare char(500) symLink;
          declare integer   cntLevel maxTraversals numNextLevel numThisLevel traversalCnt;
          declare char(300) getAssetID nextAssetID whichAssetID;
          declare char(75)  getAssetType;
          declare char(100) getAttributeID getAttribIDKnownAsset;
          declare char(20)  getNavMethod getAttribMetric;
          declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
          declare integer   getMaxUpTrav getMaxDownTrav;
 
          declare package   masstate st();
          declare package   logger writeTo();
          declare char(200) loggerString;
 
          /* monitoring */
          declare double processedRecordCount processedRecordTime processStartTime;
          declare double processEndTime nextProcessTime avgProcessTime;
          declare char(200) thisModuleName;
          /* monitoring */
 
          declare char(12)  thisColType thisDataType;
          declare char(32)  thisColName;
          declare package hash  outputColumnDefinitions;
          declare package hash  outputColumnDefinitionsAttr;
          declare package hiter outputColumnDefinitionsHI;
          declare package hiter outputColumnDefinitionsAttrHI;
 
          declare package hash  thisNetworkList;
          declare package hiter thisNetworkListHI;
          declare package hash  nextNetworkList;
          declare package hiter nextNetworkListHI;
          declare package hash  previouslyVisitedList;
          declare package hiter previouslyVisitedListHI;
          declare package hash  symLinkList;
          declare package hiter symLinkListHI;
 
          declare char(1) outputRecordsToABT;
 
          method init();
 
            maxTraversals = 10;
 
            /* monitoring */
            thisModuleName='outputRecords_trackModule';
            processedRecordCount = 0;
            processedRecordTime = 0;
            processStartTime = .;
            processEndTime = .;
            nextProcessTime = .;
            avgProcessTime = .;
            /* monitoring */
 
            /* initialize the hash tables */
            thisNetworkList = _new_ hash(3,'');
            thisNetworkList.multidata('no');
            thisNetworkList.defineKey('thisAssetID');
            thisNetworkList.defineData('thisAssetID');
            thisNetworkList.defineDone();
 
            thisNetworkListHI = _new_ hiter('thisNetworkList');
 
            nextNetworkList = _new_ hash(3,'');
            nextNetworkList.multidata('no');
            nextNetworkList.defineKey('nextAssetID');
            nextNetworkList.defineData('nextAssetID');
            nextNetworkList.defineDone();
 
            nextNetworkListHI = _new_ hiter('nextNetworkList');
 
            previouslyVisitedList = _new_ hash(3,'');
            previouslyVisitedList.multidata('no');
            previouslyVisitedList.defineKey('thisAssetID');
            previouslyVisitedList.defineData('thisAssetID');
            previouslyVisitedList.defineDone();
 
            previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
            symLinkList = _new_ hash(3,'');
            symLinkList.multidata('no');
            symLinkList.defineKey('getAssetID');
            symLinkList.defineKey('getAssetType');
            symLinkList.defineKey('getAttributeID');
            symLinkList.defineKey('getAttribMetric');
            symLinkList.defineKey('getNavMethod');
            symLinkList.defineKey('getAttribIDKnownAsset');
            symLinkList.defineKey('getChkThisAssetYN');
            symLinkList.defineKey('getMaxUpTrav');
            symLinkList.defineKey('getExactUpYN');
            symLinkList.defineKey('getMaxDownTrav');
            symLinkList.defineKey('getExactDownYN');
            symLinkList.defineData('symLink');
            symLinkList.defineDone();
 
            symLinkListHI = _new_ hiter('symLinkList');
            /* initialize the hash tables */
 
            numMaxFill=10000;
 
            /* create a hash table with all the columns to populate */
            outputColumnDefinitions = _new_ hash(3,'');
            outputColumnDefinitions.multidata('no');
            outputColumnDefinitions.defineKey('thisColName');
            outputColumnDefinitions.defineData('thisColName');
            outputColumnDefinitions.defineData('thisColType');
            outputColumnDefinitions.defineData('thisColAssetType');
            outputColumnDefinitions.defineData('thisColAttributeID');
            outputColumnDefinitions.defineDone();
 
            outputColumnDefinitionsHI = _new_ hiter('outputColumnDefinitions');
 
            thisColName='enrouteToEnd'; thisColType='string'; thisColAssetType='track'; thisColAttributeID='enrouteToEnd'; outputColumnDefinitions.add();
            thisColName='enrouteToStart'; thisColType='string'; thisColAssetType='track'; thisColAttributeID='enrouteToStart'; outputColumnDefinitions.add();
            thisColName='enrouteTrain1'; thisColType='string'; thisColAssetType='track'; thisColAttributeID='enrouteTrain1'; outputColumnDefinitions.add();
            thisColName='enrouteTrain2'; thisColType='string'; thisColAssetType='track'; thisColAttributeID='enrouteTrain2'; outputColumnDefinitions.add();
            thisColName='lastEnrouteTrain'; thisColType='string'; thisColAssetType='track'; thisColAttributeID='lastEnrouteTrain'; outputColumnDefinitions.add();
            thisColName='lastEnrouteTrainEnd'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='lastEnrouteTrainEnd'; outputColumnDefinitions.add();
            thisColName='lastEnrouteTrainStart'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='lastEnrouteTrainStart'; outputColumnDefinitions.add();
            thisColName='lastEnrouteTrainStatus'; thisColType='string'; thisColAssetType='track'; thisColAttributeID='lastEnrouteTrainStatus'; outputColumnDefinitions.add();
            thisColName='route'; thisColType='string'; thisColAssetType='track'; thisColAttributeID='route'; outputColumnDefinitions.add();
            thisColName='trackLatitude'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='trackLatitude'; outputColumnDefinitions.add();
            thisColName='trackLatitude1'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='trackLatitude1'; outputColumnDefinitions.add();
            thisColName='trackLongitude'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='trackLongitude'; outputColumnDefinitions.add();
            thisColName='trackLongitude1'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='trackLongitude1'; outputColumnDefinitions.add();
            thisColName='travelTime'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='travelTime'; outputColumnDefinitions.add();
            thisColName='travelTimeRollingAvg'; thisColType='double'; thisColAssetType='track'; thisColAttributeID='travelTimeRollingAvg'; outputColumnDefinitions.add();
 
          end;
 
 
          method startMonitoring();
 
            if strip('@performanceMonitoring@')='true' then do;
              processStartTime = datetime();
              if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
            end;
 
          end;
 
          method endMonitoring();
 
            if strip('@performanceMonitoring@')='true' then do;
 
              processEndTime = datetime();
              processedRecordCount = processedRecordCount + 1;
              processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
              if processStartTime gt nextProcessTime then do;
 
                avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
                loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
                               ' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
                               strip(put(processedRecordCount,12.0))||' at '||
                               strip(put(avgProcessTime,14.1))||' ms';
                writeTo.log('i', loggerString);
 
                processedRecordCount = 0;
                processedRecordTime = 0;
 
                nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
              end;
 
            end;
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
            mdv = .;
            msv = '';
 
            if strip(tsl)='' then do;
 
              /* nothing to do here */
 
            end;
            else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
              if checkIfVectorExists(strip(tsl)) = 1 then do;
 
                getVector (strip(tsl));
 
                if strip(st.getString(strip(tsl),0))='double' then do;
                  mdv = st.getDouble(strip(tsl),3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(tsl),3));
                end;
 
                deleteVector (tsl);
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
              if checkIfVectorExists(strip(tsl)) = 1 then do;
 
                getVector (strip(tsl));
 
                if strip(st.getString(strip(tsl),0))='double' then do;
                  mdv = st.getDouble(strip(tsl),3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(tsl),3));
                end;
 
                deleteVector (tsl);
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
                getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
                if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
                  mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
                end;
 
                if mdv=. and strip(msv)='' then do;
                  mdv = .;
                  msv = '';
                end;
                else do;
                  mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
                  msv = '';
                end;
 
                deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
                mdv = .;
                msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
                getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
                mdv = .;
                msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
                deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
              end;
 
            end;
 
          end;
 
          method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
                                    char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
                                    char(1) chkThisAsset,
                                    integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
                                    in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
            /* assign the search values to variables to facilitate checking previous searches */
            getAssetID        = strip(aID);
            getAssetType      = strip(aType);
            getAttributeID    = strip(attribID);
 
            getAttribMetric   = strip(attribMetric);
            if strip(getAttribMetric)='' then getAttribMetric='currentValue';
            getNavMethod      = strip(upcase(navMth));
            if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
            getAttribIDKnownAsset=strip(attribIDKnownAsset);
            if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
            getChkThisAssetYN = strip(upcase(chkThisAsset));
            if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
            getMaxUpTrav      = maxUp;
            if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
            getExactUpYN      = strip(upcase(exactUp));
            if strip(getExactUpYN)='' then getExactUpYN='N';
            getMaxDownTrav    = maxDown;
            if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
            getExactDownYN    = strip(upcase(exactDown));
            if strip(getExactDownYN)='' then getExactDownYN='N';
 
            /* initiate the return values */
            thisFoundDouble=.;
            thisFoundString='';
            foundValue=0;
 
            if symUpdateNeeded=0 then do;
            /* if the symlinks have already been established */
 
              symLink='';
              rcGetSymLink=symLinkList.find();
              getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
            end;
            else if getNavMethod='NAVIGATE' then do;
            /* if the symlinks need to be reestablished */
 
              /* get the assetType */
              thisAssetID=strip(getAssetID);
              thisAssetType='';
              getVector('asset|'||strip(thisAssetID));
              thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
              deleteVector('asset|'||strip(thisAssetID));
 
              if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
              /* if this asset is the same asset type, then only try to pull from there */
 
                if strip(getAttributeID)='assetID' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|assetID';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttributeID)='assetLabel' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='lastValue' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='lastTime' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
 
              end;
              else do;
              /* otherwise navigate as instructed to try to find the requested value */
 
                /* navigate all hierarchies until you find the asset-attribute */
                thisStartAssetID=strip(getAssetID);
                numHierarchies=0;
                getVector ('hierarchyList');
                numHierarchies=st.getInt('hierarchyList',0);
 
                /* if a specific hierarchy is selected, navigate only that one */
                if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
                do cntHier=1 to numHierarchies;
                  thisHierarchyName=st.getString('hierarchyList',cntHier);
 
                  /* if a specific hierarchy is selected, navigate only that one */
                  if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
                  /* walk up the hierarchy from that assetID */
                  if foundValue=0 and getMaxUpTrav gt 0 then do;
 
                    /* initialize the search */
                    thisNetworkListHI.delete();
                    nextNetworkListHI.delete();
                    previouslyVisitedListHI.delete();
                    rc=thisNetworkList.clear();
                    rc=nextNetworkList.clear();
                    rc=previouslyVisitedList.clear();
                    thisNetworkListHI = _new_ hiter('thisNetworkList');
                    nextNetworkListHI = _new_ hiter('nextNetworkList');
                    previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
                    thisAssetID=strip(thisStartAssetID);
                    getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
                    numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
                    do cntLevel=1 to numNextLevel;
                      nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
                      rcHasNext=nextNetworkList.find();
                      if rcHasNext ne 0 then do;
                        rc=nextNetworkList.add();
                      end;
                    end;
                    deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
                    /* store the number of items in the list of assets */
                    numThisLevel=nextNetworkList.num_items;
 
                    traversalCnt=1;
 
                    /* navigate up the hierarchy to try to find the information requested */
                    do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
                      /* copy nextNetworkList to thisNetworkList */
                      thisNetworkListHI.delete();
                      rc=thisNetworkList.clear();
                      thisNetworkListHI = _new_ hiter('thisNetworkList');
                      rcHasNext=nextNetworkListHI.first();
                      do while (rcHasNext=0);
 
                        thisAssetID=nextAssetID;
                        rc=thisNetworkList.add();
                        rcHasNext=nextNetworkListHI.next();
 
                      end;
                      nextNetworkListHI.delete();
                      rc=nextNetworkList.clear();
                      nextNetworkListHI = _new_ hiter('nextNetworkList');
 
                      /* iterate through the assets on this level */
                      rcHasThis=thisNetworkListHI.first();
                      do while (rcHasThis=0 and foundValue=0);
 
                        /* add parents for each asset to nextNetworkList as each gets processed */
                        numNextLevel=0;
                        getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
                        numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
                        do cntLevel=1 to numNextLevel;
                          nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
                          rcHasNext=nextNetworkList.find();
                          rcHasPrvVis=previouslyVisitedList.find();
                          if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
                            rc=nextNetworkList.add();
                          end;
                        end;
                        deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
                        /* get the asset type */
                        thisAssetType='';
                        getVector ('asset|'||strip(thisAssetID));
                        thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
                        deleteVector ('asset|'||strip(thisAssetID));
 
                        /* if the asset type matches then get the current value of the attribute */
                        if strip(getAssetType)=strip(thisAssetType) and
                            ( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
                                or
                              getExactUpYN='N'
                            ) then do;
 
                          if strip(getAttributeID)='assetID' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetID';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttributeID)='assetLabel' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastValue' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastTime' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
 
                        end;
 
                        /* add the asset to the list of previously visited assets so it is not checked again */
                        rcHasPrvVis=previouslyVisitedList.find();
                        if rcHasPrvVis ne 0 then do;
                          rc=previouslyVisitedList.add();
                        end;
 
                        /* go to the next asset in the list */
                        rcHasThis=thisNetworkListHI.next();
 
                      end;
 
                      traversalCnt=traversalCnt+1;
 
                      numThisLevel=nextNetworkList.num_items;
 
                    end;
 
                  end;
                  /* end of walk up the hierarchy */
 
                  /* walk down the hierarchy from that assetID */
                  if foundValue=0 and getMaxDownTrav gt 0 then do;
 
                    /* initialize the search */
                    thisNetworkListHI.delete();
                    nextNetworkListHI.delete();
                    previouslyVisitedListHI.delete();
                    rc=thisNetworkList.clear();
                    rc=nextNetworkList.clear();
                    rc=previouslyVisitedList.clear();
                    thisNetworkListHI = _new_ hiter('thisNetworkList');
                    nextNetworkListHI = _new_ hiter('nextNetworkList');
                    previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
                    thisAssetID=strip(thisStartAssetID);
                    getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
                    numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
                    do cntLevel=1 to numNextLevel;
                      nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
                      rcHasNext=nextNetworkList.find();
                      if rcHasNext ne 0 then do;
                        rc=nextNetworkList.add();
                      end;
                    end;
                    deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
                    /* store the number of items in the list of assets */
                    numThisLevel=nextNetworkList.num_items;
 
                    traversalCnt=1;
 
                    /* navigate down the hierarchy to try to find the information requested */
                    do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
                      /* copy nextNetworkList to thisNetworkList */
                      thisNetworkListHI.delete();
                      rc=thisNetworkList.clear();
                      thisNetworkListHI = _new_ hiter('thisNetworkList');
                      rcHasNext=nextNetworkListHI.first();
                      do while (rcHasNext=0);
 
                        thisAssetID=nextAssetID;
                        rc=thisNetworkList.add();
                        rcHasNext=nextNetworkListHI.next();
 
                      end;
                      nextNetworkListHI.delete();
                      rc=nextNetworkList.clear();
                      nextNetworkListHI = _new_ hiter('nextNetworkList');
 
                      /* iterate through the assets on this level */
                      rcHasThis=thisNetworkListHI.first();
                      do while (rcHasThis=0 and foundValue=0);
 
                        /* add children for each asset to nextNetworkList as each gets processed */
                        numNextLevel=0;
                        getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
                        numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
                        do cntLevel=1 to numNextLevel;
                          nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
                          rcHasNext=nextNetworkList.find();
                          rcHasPrvVis=previouslyVisitedList.find();
                          if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
                            rc=nextNetworkList.add();
                          end;
                        end;
                        deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
                        /* get the asset type */
                        thisAssetType='';
                        getVector ('asset|'||strip(thisAssetID));
                        thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
                        deleteVector ('asset|'||strip(thisAssetID));
 
                        /* if the asset type matches then get the current value of the attribute */
                        if strip(getAssetType)=strip(thisAssetType) and
                            ( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
                                or
                              getExactDownYN='N'
                            ) then do;
 
                          if strip(getAttributeID)='assetID' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetID';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttributeID)='assetLabel' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastValue' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastTime' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
 
                        end;
 
                        /* add the asset to the list of previously visited assets so it is not checked again */
                        rcHasPrvVis=previouslyVisitedList.find();
                        if rcHasPrvVis ne 0 then do;
                          rc=previouslyVisitedList.add();
                        end;
 
                        /* go to the next asset in the list */
                        rcHasThis=thisNetworkListHI.next();
 
                      end;
 
                      traversalCnt=traversalCnt+1;
 
                      numThisLevel=nextNetworkList.num_items;
 
                    end;
 
                  end;
                  /* end of walk down the hierarchy */
 
                end;
                /* iteration over hierarchies */
                deleteVector ('hierarchyList');
 
              end;
              /* end of navigation to find value */
 
            end;
            else if getNavMethod='KNOWNASSETID' then do;
            /* if the asset ID to pull the data from is known */
 
              /* get the assetType */
              thisAssetID=strip(getAssetID);
              thisAssetType='';
              getVector('asset|'||strip(thisAssetID));
              thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
              deleteVector('asset|'||strip(thisAssetID));
 
              whichAssetID = '';
 
              if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
                getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
                whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
                deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
              end;
 
              /* now pull the desired value */
              if strip(whichAssetID) ne '' then do;
 
                if strip(getAttribMetric)='lastValue' then do;
 
                  symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='currentValue' then do;
 
                  symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
 
              end;
 
            end;
 
          end;
 
          method runOutputRecords_track(bigint           key1,
                                              bigint           triggerTimestamp,
                                              in_out bigint    key2[10000],
                                              in_out char(75)  assetType[10000],
                                              in_out char(300) assetID[10000],
                                              in_out bigint    msr_timestamp[10000],
                                              in_out char(50)    enrouteToEnd[10000],
                                              in_out char(50)    enrouteToStart[10000],
                                              in_out char(100)    enrouteTrain1[10000],
                                              in_out char(100)    enrouteTrain2[10000],
                                              in_out char(100)    lastEnrouteTrain[10000],
                                              in_out double    lastEnrouteTrainEnd[10000],
                                              in_out double    lastEnrouteTrainStart[10000],
                                              in_out char(50)    lastEnrouteTrainStatus[10000],
                                              in_out char(50)    route[10000],
                                              in_out double    trackLatitude[10000],
                                              in_out double    trackLatitude1[10000],
                                              in_out double    trackLongitude[10000],
                                              in_out double    trackLongitude1[10000],
                                              in_out double    travelTime[10000],
                                              in_out double    travelTimeRollingAvg[10000],
                                              in_out char(10)  _outOpcodeArray[10000]);
 
 
            startMonitoring();
 
            getVector ('outputRecordsToABT');
            outputRecordsToABT = strip(st.getString('outputRecordsToABT',0));
            deleteVector ('outputRecordsToABT');
 
            outputAssetType='track';
            outputAssetType=tranwrd(outputAssetType,'|','^$*1*$^');
 
            /* see whether symlinks can be used or if navigation is needed */
            getVector ('symUpdateNeeded');
            symUpdateNeeded = st.getInt('symUpdateNeeded',0);
            deleteVector ('symUpdateNeeded');
            if symUpdateNeeded = 1 then rc=symLinkList.clear();
 
            if outputRecordsToABT='Y' then do;
 
              getVector('assetType|'||strip(outputAssetType)||'|outputAssetList');
 
              numAssets=st.getInt('assetType|'||strip(outputAssetType)||'|outputAssetList',0);
              do cpycnt=1 to numAssets;
 
                outputAssetID=strip(st.getString('assetType|'||strip(outputAssetType)||'|outputAssetList',cpycnt));
 
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=triggerTimestamp;
                assetType[cpycnt]=strip('track');
 
                thisOutputAssetID=tranwrd(outputAssetID,'^$*1*$^','|');
                assetID[cpycnt]=strip(thisOutputAssetID);
 
                _outOpcodeArray[cpycnt]='insert';
 
                /* now that symlinks are all established, simply pull the data into the columns */
                _rcOutputColumnDefinitions_ = outputColumnDefinitionsHI.first();
                do while (_rcOutputColumnDefinitions_ = 0);
 
                  getAttributeValue(outputAssetID,thisColAssetType,thisColAttributeID,'currentValue',
                                    'navigate','','','Y',maxTraversals,'N',maxTraversals,'N',
                                    myDoubleValue,myStringValue);
 
                  if 0=1 then notLikely=0;
                  else if thisColName='enrouteToEnd' then enrouteToEnd[cpycnt]    =strip(myStringValue);
                  else if thisColName='enrouteToStart' then enrouteToStart[cpycnt]    =strip(myStringValue);
                  else if thisColName='enrouteTrain1' then enrouteTrain1[cpycnt]    =strip(myStringValue);
                  else if thisColName='enrouteTrain2' then enrouteTrain2[cpycnt]    =strip(myStringValue);
                  else if thisColName='lastEnrouteTrain' then lastEnrouteTrain[cpycnt]    =strip(myStringValue);
                  else if thisColName='lastEnrouteTrainEnd' then lastEnrouteTrainEnd[cpycnt]    =myDoubleValue;
                  else if thisColName='lastEnrouteTrainStart' then lastEnrouteTrainStart[cpycnt]    =myDoubleValue;
                  else if thisColName='lastEnrouteTrainStatus' then lastEnrouteTrainStatus[cpycnt]    =strip(myStringValue);
                  else if thisColName='route' then route[cpycnt]    =strip(myStringValue);
                  else if thisColName='trackLatitude' then trackLatitude[cpycnt]    =myDoubleValue;
                  else if thisColName='trackLatitude1' then trackLatitude1[cpycnt]    =myDoubleValue;
                  else if thisColName='trackLongitude' then trackLongitude[cpycnt]    =myDoubleValue;
                  else if thisColName='trackLongitude1' then trackLongitude1[cpycnt]    =myDoubleValue;
                  else if thisColName='travelTime' then travelTime[cpycnt]    =myDoubleValue;
                  else if thisColName='travelTimeRollingAvg' then travelTimeRollingAvg[cpycnt]    =myDoubleValue;
 
                  _rcOutputColumnDefinitions_ = outputColumnDefinitionsHI.next();
 
                end;
 
              end;
              deleteVector('assetType|'||strip(thisAssetType)||'|outputAssetList');
 
              do cpycnt=numAssets+1 to numMaxFill;
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=.;
                assetType[cpycnt]='';
                assetID[cpycnt]='';
                enrouteToEnd[cpycnt]='';
                enrouteToStart[cpycnt]='';
                enrouteTrain1[cpycnt]='';
                enrouteTrain2[cpycnt]='';
                lastEnrouteTrain[cpycnt]='';
                lastEnrouteTrainEnd[cpycnt]=.;
                lastEnrouteTrainStart[cpycnt]=.;
                lastEnrouteTrainStatus[cpycnt]='';
                route[cpycnt]='';
                trackLatitude[cpycnt]=.;
                trackLatitude1[cpycnt]=.;
                trackLongitude[cpycnt]=.;
                trackLongitude1[cpycnt]=.;
                travelTime[cpycnt]=.;
                travelTimeRollingAvg[cpycnt]=.;
                _outOpcodeArray[cpycnt]='delete';
              end;
              numMaxFill=numAssets;
 
            end;
            else do;
 
              do cpycnt=1 to numMaxFill;
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=.;
                assetType[cpycnt]='';
                assetID[cpycnt]='';
                enrouteToEnd[cpycnt]='';
                enrouteToStart[cpycnt]='';
                enrouteTrain1[cpycnt]='';
                enrouteTrain2[cpycnt]='';
                lastEnrouteTrain[cpycnt]='';
                lastEnrouteTrainEnd[cpycnt]=.;
                lastEnrouteTrainStart[cpycnt]=.;
                lastEnrouteTrainStatus[cpycnt]='';
                route[cpycnt]='';
                trackLatitude[cpycnt]=.;
                trackLatitude1[cpycnt]=.;
                trackLongitude[cpycnt]=.;
                trackLongitude1[cpycnt]=.;
                travelTime[cpycnt]=.;
                travelTimeRollingAvg[cpycnt]=.;
                _outOpcodeArray[cpycnt]='delete';
              end;
              numMaxFill=0;
 
            end;
 
            endMonitoring();
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="outputRecords_track_gateModule" language="ds2" func-names="runOutputRecords_track_gate">
      <code><![CDATA[ds2_options sas;
 
        package outputRecords_track_gatePackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep;
          declare integer   numAssets cpycnt;
          declare char(300) thisAssetID thisOutputAssetID;
 
          declare bigint  numRequirements thisRequirementNum;
          declare integer allGatesOpenYN;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method openGate (bigint tr, bigint tdtm);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
 
            getVector('outputGate_track_req'||strip(put(tr,z5.)));
            rc = st.setLong('outputGate_track_req'||strip(put(tr,z5.)),0,tdtm);
            replaceVector('outputGate_track_req'||strip(put(tr,z5.)));
            deleteVector('outputGate_track_req'||strip(put(tr,z5.)));
 
            loggerString = 'NOTE: Opened outputGate_track_req'||strip(put(tr,z5.));
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method checkAllGates (bigint nr, bigint tdtm) returns integer;
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i nrs;
            declare bigint thisTimestamp;
 
            nrs=0;
            do i=1 to nr;
 
              thisTimestamp=0;
              getVector('outputGate_track_req'||strip(put(i,z5.)));
              thisTimestamp=st.getLong('outputGate_track_req'||strip(put(i,z5.)),0);
              deleteVector('outputGate_track_req'||strip(put(i,z5.)));
 
              if thisTimestamp = tdtm then nrs = nrs + 1;
 
            end;
 
            loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for outputGate_track';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            if nrs=nr then return 1;
            else           return 0;
 
          end;
 
          method closeAllGates (bigint nr);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i;
 
            do i=1 to nr;
 
              getVector('outputGate_track_req'||strip(put(i,z5.)));
              rc = st.setLong('outputGate_track_req'||strip(put(i,z5.)),0,0);
              replaceVector('outputGate_track_req'||strip(put(i,z5.)));
              deleteVector('outputGate_track_req'||strip(put(i,z5.)));
 
            end;
 
            loggerString = 'NOTE: Reset outputGate_track';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method runOutputRecords_track_gate (bigint     key1,
                                                    bigint     key2,
                                                    char(75)   assetType,
                                                    char(300)  assetID,
                                                    bigint     msr_timestamp,
                                                    in_out char(10) _outOpcode);
 
            getVector('assetType|track|outputAssetList');
            numAssets=st.getInt('assetType|track|outputAssetList',0);
            thisRequirementNum=0;
            numRequirements=numAssets;
            do cpycnt=1 to numAssets;
              thisAssetID=strip(st.getString('assetType|track|outputAssetList',cpycnt));
              thisOutputAssetID=tranwrd(thisAssetID,'^$*1*$^','|');
              if strip(thisOutputAssetID)=strip(assetID) then thisRequirementNum=cpycnt;
            end;
            deleteVector('assetType|track|outputAssetList');
 
            /*** open this gate by setting gate info to triggerTimestamp ***/
            openGate (thisRequirementNum, msr_timestamp);
 
            /*** now check all gates to see that they are all equal to msr_timestamp or if any are still closed ***/
            allGatesOpenYN=checkAllGates(numRequirements, msr_timestamp);
 
            /*** if all gates are open and equal to msr_timestamp then let the record through and close the gates to prep for next trigger ***/
            if allGatesOpenYN=1 then do;
              _outOpcode='insert';
              closeAllGates (numRequirements);
            end;
            else _outOpcode='delete';
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="outputRecords_trainModule" language="ds2" func-names="runOutputRecords_train">
      <code><![CDATA[ds2_options sas;
 
        package outputRecords_trainPackage / overwrite = yes;
 
          declare double    rc rc1 rc1s rc2 rc2s rcsleep _rcFoundAttribute_ _rcOutputColumnDefinitions_;
          declare integer   numAssets numOutputAssets numAttributes cpycnt cpycnt2 cntHier;
          declare integer   numHierarchies numParents numChildren numItems notLikely;
          declare integer   foundTHIS cntALL cntTHIS symUpdateNeeded hasSymlink numMaxFill foundValue;
          declare char(75)  thisAssetType outputAssetType thisColAssetType;
          declare char(300) thisAssetID newAssetID outputAssetID thisParentAssetID thisChildAssetID;
          declare char(300) tempItem thisOutputAssetID thisStartAssetID;
          declare char(100) thisAttributeID thisColAttributeID;
          declare char(100) thisValueString;
          declare double    thisValueDouble myDoubleValue;
          declare char(25)  thisHierarchy thisHierarchyName;
          declare char(50)  myStringValue;
          declare bigint    nextDeleteInQueue;
 
          declare double    rcGetSymLink rcHasNext rcHasThis rcHasPrvVis;
          declare char(500) symLink;
          declare integer   cntLevel maxTraversals numNextLevel numThisLevel traversalCnt;
          declare char(300) getAssetID nextAssetID whichAssetID;
          declare char(75)  getAssetType;
          declare char(100) getAttributeID getAttribIDKnownAsset;
          declare char(20)  getNavMethod getAttribMetric;
          declare char(1)   getChkThisAssetYN getExactUpYN getExactDownYN;
          declare integer   getMaxUpTrav getMaxDownTrav;
 
          declare package   masstate st();
          declare package   logger writeTo();
          declare char(200) loggerString;
 
          /* monitoring */
          declare double processedRecordCount processedRecordTime processStartTime;
          declare double processEndTime nextProcessTime avgProcessTime;
          declare char(200) thisModuleName;
          /* monitoring */
 
          declare char(12)  thisColType thisDataType;
          declare char(32)  thisColName;
          declare package hash  outputColumnDefinitions;
          declare package hash  outputColumnDefinitionsAttr;
          declare package hiter outputColumnDefinitionsHI;
          declare package hiter outputColumnDefinitionsAttrHI;
 
          declare package hash  thisNetworkList;
          declare package hiter thisNetworkListHI;
          declare package hash  nextNetworkList;
          declare package hiter nextNetworkListHI;
          declare package hash  previouslyVisitedList;
          declare package hiter previouslyVisitedListHI;
          declare package hash  symLinkList;
          declare package hiter symLinkListHI;
 
          declare char(1) outputRecordsToABT;
 
          method init();
 
            maxTraversals = 10;
 
            /* monitoring */
            thisModuleName='outputRecords_trainModule';
            processedRecordCount = 0;
            processedRecordTime = 0;
            processStartTime = .;
            processEndTime = .;
            nextProcessTime = .;
            avgProcessTime = .;
            /* monitoring */
 
            /* initialize the hash tables */
            thisNetworkList = _new_ hash(3,'');
            thisNetworkList.multidata('no');
            thisNetworkList.defineKey('thisAssetID');
            thisNetworkList.defineData('thisAssetID');
            thisNetworkList.defineDone();
 
            thisNetworkListHI = _new_ hiter('thisNetworkList');
 
            nextNetworkList = _new_ hash(3,'');
            nextNetworkList.multidata('no');
            nextNetworkList.defineKey('nextAssetID');
            nextNetworkList.defineData('nextAssetID');
            nextNetworkList.defineDone();
 
            nextNetworkListHI = _new_ hiter('nextNetworkList');
 
            previouslyVisitedList = _new_ hash(3,'');
            previouslyVisitedList.multidata('no');
            previouslyVisitedList.defineKey('thisAssetID');
            previouslyVisitedList.defineData('thisAssetID');
            previouslyVisitedList.defineDone();
 
            previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
 
            symLinkList = _new_ hash(3,'');
            symLinkList.multidata('no');
            symLinkList.defineKey('getAssetID');
            symLinkList.defineKey('getAssetType');
            symLinkList.defineKey('getAttributeID');
            symLinkList.defineKey('getAttribMetric');
            symLinkList.defineKey('getNavMethod');
            symLinkList.defineKey('getAttribIDKnownAsset');
            symLinkList.defineKey('getChkThisAssetYN');
            symLinkList.defineKey('getMaxUpTrav');
            symLinkList.defineKey('getExactUpYN');
            symLinkList.defineKey('getMaxDownTrav');
            symLinkList.defineKey('getExactDownYN');
            symLinkList.defineData('symLink');
            symLinkList.defineDone();
 
            symLinkListHI = _new_ hiter('symLinkList');
            /* initialize the hash tables */
 
            numMaxFill=10000;
 
            /* create a hash table with all the columns to populate */
            outputColumnDefinitions = _new_ hash(3,'');
            outputColumnDefinitions.multidata('no');
            outputColumnDefinitions.defineKey('thisColName');
            outputColumnDefinitions.defineData('thisColName');
            outputColumnDefinitions.defineData('thisColType');
            outputColumnDefinitions.defineData('thisColAssetType');
            outputColumnDefinitions.defineData('thisColAttributeID');
            outputColumnDefinitions.defineDone();
 
            outputColumnDefinitionsHI = _new_ hiter('outputColumnDefinitions');
 
            thisColName='currentLocation'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='currentLocation'; outputColumnDefinitions.add();
            thisColName='currentStatus'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='currentStatus'; outputColumnDefinitions.add();
            thisColName='currentStatusRaw'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='currentStatusRaw'; outputColumnDefinitions.add();
            thisColName='remainingStops'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='remainingStops'; outputColumnDefinitions.add();
            thisColName='route'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='route'; outputColumnDefinitions.add();
            thisColName='stationArrival'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='stationArrival'; outputColumnDefinitions.add();
            thisColName='stationDepartureFrom'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='stationDepartureFrom'; outputColumnDefinitions.add();
            thisColName='stationDepartureTo'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='stationDepartureTo'; outputColumnDefinitions.add();
            thisColName='stopIndex'; thisColType='double'; thisColAssetType='train'; thisColAttributeID='stopIndex'; outputColumnDefinitions.add();
            thisColName='trackEnrouteToEnd'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='trackEnrouteToEnd'; outputColumnDefinitions.add();
            thisColName='trackEnrouteToStart'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='trackEnrouteToStart'; outputColumnDefinitions.add();
            thisColName='trainDepartureTimestamp'; thisColType='double'; thisColAssetType='train'; thisColAttributeID='trainDepartureTimestamp'; outputColumnDefinitions.add();
            thisColName='trainDestination'; thisColType='string'; thisColAssetType='train'; thisColAttributeID='trainDestination'; outputColumnDefinitions.add();
            thisColName='trainExpArrivalTimestamp'; thisColType='double'; thisColAssetType='train'; thisColAttributeID='trainExpArrivalTimestamp'; outputColumnDefinitions.add();
            thisColName='trainLatitude'; thisColType='double'; thisColAssetType='train'; thisColAttributeID='trainLatitude'; outputColumnDefinitions.add();
            thisColName='trainLongitude'; thisColType='double'; thisColAssetType='train'; thisColAttributeID='trainLongitude'; outputColumnDefinitions.add();
 
          end;
 
 
          method startMonitoring();
 
            if strip('@performanceMonitoring@')='true' then do;
              processStartTime = datetime();
              if nextProcessTime=. then nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
            end;
 
          end;
 
          method endMonitoring();
 
            if strip('@performanceMonitoring@')='true' then do;
 
              processEndTime = datetime();
              processedRecordCount = processedRecordCount + 1;
              processedRecordTime = processedRecordTime + (processEndTime - processStartTime)*1000.0;
 
              if processStartTime gt nextProcessTime then do;
 
                avgProcessTime = round(processedRecordTime / processedRecordCount,0.1);
 
                loggerString = 'AUTOML: '||strip(put(processEndTime,datetime20.))||
                               ' - PERFORMANCE - '|| strip(thisModuleName) ||' - '||
                               strip(put(processedRecordCount,12.0))||' at '||
                               strip(put(avgProcessTime,14.1))||' ms';
                writeTo.log('i', loggerString);
 
                processedRecordCount = 0;
                processedRecordTime = 0;
 
                nextProcessTime = 1.0 * int( (ceil((processStartTime*1.0)/600.0)*1.0) * 600.0 );
 
              end;
 
            end;
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method getSymlinkValue (char(500) tsl, in_out double mdv, in_out char msv);
 
            mdv = .;
            msv = '';
 
            if strip(tsl)='' then do;
 
              /* nothing to do here */
 
            end;
            else if strip(scan(tsl,-1,'|'))='currentValue' then do;
 
              if checkIfVectorExists(strip(tsl)) = 1 then do;
 
                getVector (strip(tsl));
 
                if strip(st.getString(strip(tsl),0))='double' then do;
                  mdv = st.getDouble(strip(tsl),3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(tsl),3));
                end;
 
                deleteVector (tsl);
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='lastValue' then do;
 
              if checkIfVectorExists(strip(tsl)) = 1 then do;
 
                getVector (strip(tsl));
 
                if strip(st.getString(strip(tsl),0))='double' then do;
                  mdv = st.getDouble(strip(tsl),3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(tsl),3));
                end;
 
                deleteVector (tsl);
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='lastTime' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue') = 1 then do;
 
                getVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
                if strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',0))='double' then do;
                  mdv = st.getDouble(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3);
                  msv='';
                end;
                else do;
                  mdv = .;
                  msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',3));
                end;
 
                if mdv=. and strip(msv)='' then do;
                  mdv = .;
                  msv = '';
                end;
                else do;
                  mdv=1.0 * st.getLong(strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue',2);
                  msv = '';
                end;
 
                deleteVector (strip(substr(strip(tsl),1,length(strip(tsl))-9))||'|lastValue');
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='assetID' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-8))) = 1 then do;
 
                mdv = .;
                msv = strip(substr(substr(strip(tsl),1,length(strip(tsl))-8),7));
 
              end;
 
            end;
            else if strip(scan(tsl,-1,'|'))='assetLabel' then do;
 
              if checkIfVectorExists(strip(substr(strip(tsl),1,length(strip(tsl))-11))) = 1 then do;
 
                getVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
                mdv = .;
                msv = strip(st.getString(strip(substr(strip(tsl),1,length(strip(tsl))-11)),1));
 
                deleteVector (substr(strip(tsl),1,length(strip(tsl))-11));
 
              end;
 
            end;
 
          end;
 
          method getAttributeValue (char(300) aID, char(75) aType, char(100) attribID, char(20) attribMetric,
                                    char(20) navMth, char(75) attribIDKnownAsset, char(25) useThisHier,
                                    char(1) chkThisAsset,
                                    integer maxUp, char(1) exactUp, integer maxDown, char(1) exactDown,
                                    in_out double thisFoundDouble, in_out char(50) thisFoundString);
 
            /* assign the search values to variables to facilitate checking previous searches */
            getAssetID        = strip(aID);
            getAssetType      = strip(aType);
            getAttributeID    = strip(attribID);
 
            getAttribMetric   = strip(attribMetric);
            if strip(getAttribMetric)='' then getAttribMetric='currentValue';
            getNavMethod      = strip(upcase(navMth));
            if strip(getNavMethod)='' then getNavMethod='NAVIGATE';
            getAttribIDKnownAsset=strip(attribIDKnownAsset);
            if strip(getAttribIDKnownAsset)='' then getAttribIDKnownAsset='NA';
            getChkThisAssetYN = strip(upcase(chkThisAsset));
            if strip(getChkThisAssetYN)='' then getChkThisAssetYN='Y';
            getMaxUpTrav      = maxUp;
            if getMaxUpTrav=. then getMaxUpTrav=maxTraversals;
            getExactUpYN      = strip(upcase(exactUp));
            if strip(getExactUpYN)='' then getExactUpYN='N';
            getMaxDownTrav    = maxDown;
            if getMaxDownTrav=. then getMaxDownTrav=maxTraversals;
            getExactDownYN    = strip(upcase(exactDown));
            if strip(getExactDownYN)='' then getExactDownYN='N';
 
            /* initiate the return values */
            thisFoundDouble=.;
            thisFoundString='';
            foundValue=0;
 
            if symUpdateNeeded=0 then do;
            /* if the symlinks have already been established */
 
              symLink='';
              rcGetSymLink=symLinkList.find();
              getSymlinkValue(symLink,thisFoundDouble,thisFoundString);
 
            end;
            else if getNavMethod='NAVIGATE' then do;
            /* if the symlinks need to be reestablished */
 
              /* get the assetType */
              thisAssetID=strip(getAssetID);
              thisAssetType='';
              getVector('asset|'||strip(thisAssetID));
              thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
              deleteVector('asset|'||strip(thisAssetID));
 
              if getChkThisAssetYN='Y' and strip(getAssetType)=strip(thisAssetType) then do;
              /* if this asset is the same asset type, then only try to pull from there */
 
                if strip(getAttributeID)='assetID' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|assetID';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttributeID)='assetLabel' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='lastValue' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='lastTime' then do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else do;
 
                  foundValue=1;
                  symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
 
              end;
              else do;
              /* otherwise navigate as instructed to try to find the requested value */
 
                /* navigate all hierarchies until you find the asset-attribute */
                thisStartAssetID=strip(getAssetID);
                numHierarchies=0;
                getVector ('hierarchyList');
                numHierarchies=st.getInt('hierarchyList',0);
 
                /* if a specific hierarchy is selected, navigate only that one */
                if numHierarchies gt 0 and strip(useThisHier) ne '' then numHierarchies=1;
 
                do cntHier=1 to numHierarchies;
                  thisHierarchyName=st.getString('hierarchyList',cntHier);
 
                  /* if a specific hierarchy is selected, navigate only that one */
                  if numHierarchies gt 0 and strip(useThisHier) ne '' then thisHierarchyName=strip(useThisHier);
 
                  /* walk up the hierarchy from that assetID */
                  if foundValue=0 and getMaxUpTrav gt 0 then do;
 
                    /* initialize the search */
                    thisNetworkListHI.delete();
                    nextNetworkListHI.delete();
                    previouslyVisitedListHI.delete();
                    rc=thisNetworkList.clear();
                    rc=nextNetworkList.clear();
                    rc=previouslyVisitedList.clear();
                    thisNetworkListHI = _new_ hiter('thisNetworkList');
                    nextNetworkListHI = _new_ hiter('nextNetworkList');
                    previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
                    thisAssetID=strip(thisStartAssetID);
                    getVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
                    numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
                    do cntLevel=1 to numNextLevel;
                      nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
                      rcHasNext=nextNetworkList.find();
                      if rcHasNext ne 0 then do;
                        rc=nextNetworkList.add();
                      end;
                    end;
                    deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
                    /* store the number of items in the list of assets */
                    numThisLevel=nextNetworkList.num_items;
 
                    traversalCnt=1;
 
                    /* navigate up the hierarchy to try to find the information requested */
                    do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxUpTrav);
 
                      /* copy nextNetworkList to thisNetworkList */
                      thisNetworkListHI.delete();
                      rc=thisNetworkList.clear();
                      thisNetworkListHI = _new_ hiter('thisNetworkList');
                      rcHasNext=nextNetworkListHI.first();
                      do while (rcHasNext=0);
 
                        thisAssetID=nextAssetID;
                        rc=thisNetworkList.add();
                        rcHasNext=nextNetworkListHI.next();
 
                      end;
                      nextNetworkListHI.delete();
                      rc=nextNetworkList.clear();
                      nextNetworkListHI = _new_ hiter('nextNetworkList');
 
                      /* iterate through the assets on this level */
                      rcHasThis=thisNetworkListHI.first();
                      do while (rcHasThis=0 and foundValue=0);
 
                        /* add parents for each asset to nextNetworkList as each gets processed */
                        numNextLevel=0;
                        getVector ('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
                        numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),0);
                        do cntLevel=1 to numNextLevel;
                          nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName),cntLevel);
                          rcHasNext=nextNetworkList.find();
                          rcHasPrvVis=previouslyVisitedList.find();
                          if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
                            rc=nextNetworkList.add();
                          end;
                        end;
                        deleteVector('asset|'||strip(thisAssetID)||'|parents|'||strip(thisHierarchyName));
 
                        /* get the asset type */
                        thisAssetType='';
                        getVector ('asset|'||strip(thisAssetID));
                        thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
                        deleteVector ('asset|'||strip(thisAssetID));
 
                        /* if the asset type matches then get the current value of the attribute */
                        if strip(getAssetType)=strip(thisAssetType) and
                            ( (getExactUpYN='Y' and traversalCnt eq getMaxUpTrav)
                                or
                              getExactUpYN='N'
                            ) then do;
 
                          if strip(getAttributeID)='assetID' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetID';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttributeID)='assetLabel' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastValue' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastTime' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
 
                        end;
 
                        /* add the asset to the list of previously visited assets so it is not checked again */
                        rcHasPrvVis=previouslyVisitedList.find();
                        if rcHasPrvVis ne 0 then do;
                          rc=previouslyVisitedList.add();
                        end;
 
                        /* go to the next asset in the list */
                        rcHasThis=thisNetworkListHI.next();
 
                      end;
 
                      traversalCnt=traversalCnt+1;
 
                      numThisLevel=nextNetworkList.num_items;
 
                    end;
 
                  end;
                  /* end of walk up the hierarchy */
 
                  /* walk down the hierarchy from that assetID */
                  if foundValue=0 and getMaxDownTrav gt 0 then do;
 
                    /* initialize the search */
                    thisNetworkListHI.delete();
                    nextNetworkListHI.delete();
                    previouslyVisitedListHI.delete();
                    rc=thisNetworkList.clear();
                    rc=nextNetworkList.clear();
                    rc=previouslyVisitedList.clear();
                    thisNetworkListHI = _new_ hiter('thisNetworkList');
                    nextNetworkListHI = _new_ hiter('nextNetworkList');
                    previouslyVisitedListHI = _new_ hiter('previouslyVisitedList');
                    thisAssetID=strip(thisStartAssetID);
                    getVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
                    numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
                    do cntLevel=1 to numNextLevel;
                      nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
                      rcHasNext=nextNetworkList.find();
                      if rcHasNext ne 0 then do;
                        rc=nextNetworkList.add();
                      end;
                    end;
                    deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
                    /* store the number of items in the list of assets */
                    numThisLevel=nextNetworkList.num_items;
 
                    traversalCnt=1;
 
                    /* navigate down the hierarchy to try to find the information requested */
                    do while (numThisLevel gt 0 and foundValue=0 and traversalCnt le getMaxDownTrav);
 
                      /* copy nextNetworkList to thisNetworkList */
                      thisNetworkListHI.delete();
                      rc=thisNetworkList.clear();
                      thisNetworkListHI = _new_ hiter('thisNetworkList');
                      rcHasNext=nextNetworkListHI.first();
                      do while (rcHasNext=0);
 
                        thisAssetID=nextAssetID;
                        rc=thisNetworkList.add();
                        rcHasNext=nextNetworkListHI.next();
 
                      end;
                      nextNetworkListHI.delete();
                      rc=nextNetworkList.clear();
                      nextNetworkListHI = _new_ hiter('nextNetworkList');
 
                      /* iterate through the assets on this level */
                      rcHasThis=thisNetworkListHI.first();
                      do while (rcHasThis=0 and foundValue=0);
 
                        /* add children for each asset to nextNetworkList as each gets processed */
                        numNextLevel=0;
                        getVector ('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
                        numNextLevel=st.getInt('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),0);
                        do cntLevel=1 to numNextLevel;
                          nextAssetID=st.getString('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName),cntLevel);
                          rcHasNext=nextNetworkList.find();
                          rcHasPrvVis=previouslyVisitedList.find();
                          if rcHasNext ne 0 and rcHasPrvVis ne 0 and nextAssetID ne thisAssetID then do;
                            rc=nextNetworkList.add();
                          end;
                        end;
                        deleteVector('asset|'||strip(thisAssetID)||'|children|'||strip(thisHierarchyName));
 
                        /* get the asset type */
                        thisAssetType='';
                        getVector ('asset|'||strip(thisAssetID));
                        thisAssetType = st.getString('asset|'||strip(thisAssetID),0);
                        deleteVector ('asset|'||strip(thisAssetID));
 
                        /* if the asset type matches then get the current value of the attribute */
                        if strip(getAssetType)=strip(thisAssetType) and
                            ( (getExactDownYN='Y' and traversalCnt eq getMaxDownTrav)
                                or
                              getExactDownYN='N'
                            ) then do;
 
                          if strip(getAttributeID)='assetID' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetID';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttributeID)='assetLabel' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|assetLabel';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastValue' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else if strip(getAttribMetric)='lastTime' then do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|lastTime';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
                          else do;
 
                            foundValue=1;
                            symLink='asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                            rc=symLinkList.add();
 
                            getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                          end;
 
                        end;
 
                        /* add the asset to the list of previously visited assets so it is not checked again */
                        rcHasPrvVis=previouslyVisitedList.find();
                        if rcHasPrvVis ne 0 then do;
                          rc=previouslyVisitedList.add();
                        end;
 
                        /* go to the next asset in the list */
                        rcHasThis=thisNetworkListHI.next();
 
                      end;
 
                      traversalCnt=traversalCnt+1;
 
                      numThisLevel=nextNetworkList.num_items;
 
                    end;
 
                  end;
                  /* end of walk down the hierarchy */
 
                end;
                /* iteration over hierarchies */
                deleteVector ('hierarchyList');
 
              end;
              /* end of navigation to find value */
 
            end;
            else if getNavMethod='KNOWNASSETID' then do;
            /* if the asset ID to pull the data from is known */
 
              /* get the assetType */
              thisAssetID=strip(getAssetID);
              thisAssetType='';
              getVector('asset|'||strip(thisAssetID));
              thisAssetType=strip(st.getString('asset|'||strip(thisAssetID),0));
              deleteVector('asset|'||strip(thisAssetID));
 
              whichAssetID = '';
 
              if checkIfVectorExists(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue')) = 1 then do;
 
                getVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
                whichAssetID = strip(st.getString(strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'),3));
                deleteVector (strip('asset|'||strip(thisAssetID)||'|attribute|'||strip(getAttribIDKnownAsset)||'|currentValue'));
 
              end;
 
              /* now pull the desired value */
              if strip(whichAssetID) ne '' then do;
 
                if strip(getAttribMetric)='lastValue' then do;
 
                  symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|lastValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
                else if strip(getAttribMetric)='currentValue' then do;
 
                  symLink='asset|'||strip(whichAssetID)||'|attribute|'||strip(getAttributeID)||'|currentValue';
                  rc=symLinkList.add();
 
                  getSymlinkValue (symLink, thisFoundDouble, thisFoundString);
 
                end;
 
              end;
 
            end;
 
          end;
 
          method runOutputRecords_train(bigint           key1,
                                              bigint           triggerTimestamp,
                                              in_out bigint    key2[10000],
                                              in_out char(75)  assetType[10000],
                                              in_out char(300) assetID[10000],
                                              in_out bigint    msr_timestamp[10000],
                                              in_out char(50)    currentLocation[10000],
                                              in_out char(50)    currentStatus[10000],
                                              in_out char(50)    currentStatusRaw[10000],
                                              in_out char(200)    remainingStops[10000],
                                              in_out char(50)    route[10000],
                                              in_out char(50)    stationArrival[10000],
                                              in_out char(50)    stationDepartureFrom[10000],
                                              in_out char(50)    stationDepartureTo[10000],
                                              in_out double    stopIndex[10000],
                                              in_out char(50)    trackEnrouteToEnd[10000],
                                              in_out char(50)    trackEnrouteToStart[10000],
                                              in_out double    trainDepartureTimestamp[10000],
                                              in_out char(50)    trainDestination[10000],
                                              in_out double    trainExpArrivalTimestamp[10000],
                                              in_out double    trainLatitude[10000],
                                              in_out double    trainLongitude[10000],
                                              in_out char(10)  _outOpcodeArray[10000]);
 
 
            startMonitoring();
 
            getVector ('outputRecordsToABT');
            outputRecordsToABT = strip(st.getString('outputRecordsToABT',0));
            deleteVector ('outputRecordsToABT');
 
            outputAssetType='train';
            outputAssetType=tranwrd(outputAssetType,'|','^$*1*$^');
 
            /* see whether symlinks can be used or if navigation is needed */
            getVector ('symUpdateNeeded');
            symUpdateNeeded = st.getInt('symUpdateNeeded',0);
            deleteVector ('symUpdateNeeded');
            if symUpdateNeeded = 1 then rc=symLinkList.clear();
 
            if outputRecordsToABT='Y' then do;
 
              getVector('assetType|'||strip(outputAssetType)||'|outputAssetList');
 
              numAssets=st.getInt('assetType|'||strip(outputAssetType)||'|outputAssetList',0);
              do cpycnt=1 to numAssets;
 
                outputAssetID=strip(st.getString('assetType|'||strip(outputAssetType)||'|outputAssetList',cpycnt));
 
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=triggerTimestamp;
                assetType[cpycnt]=strip('train');
 
                thisOutputAssetID=tranwrd(outputAssetID,'^$*1*$^','|');
                assetID[cpycnt]=strip(thisOutputAssetID);
 
                _outOpcodeArray[cpycnt]='insert';
 
                /* now that symlinks are all established, simply pull the data into the columns */
                _rcOutputColumnDefinitions_ = outputColumnDefinitionsHI.first();
                do while (_rcOutputColumnDefinitions_ = 0);
 
                  getAttributeValue(outputAssetID,thisColAssetType,thisColAttributeID,'currentValue',
                                    'navigate','','','Y',maxTraversals,'N',maxTraversals,'N',
                                    myDoubleValue,myStringValue);
 
                  if 0=1 then notLikely=0;
                  else if thisColName='currentLocation' then currentLocation[cpycnt]    =strip(myStringValue);
                  else if thisColName='currentStatus' then currentStatus[cpycnt]    =strip(myStringValue);
                  else if thisColName='currentStatusRaw' then currentStatusRaw[cpycnt]    =strip(myStringValue);
                  else if thisColName='remainingStops' then remainingStops[cpycnt]    =strip(myStringValue);
                  else if thisColName='route' then route[cpycnt]    =strip(myStringValue);
                  else if thisColName='stationArrival' then stationArrival[cpycnt]    =strip(myStringValue);
                  else if thisColName='stationDepartureFrom' then stationDepartureFrom[cpycnt]    =strip(myStringValue);
                  else if thisColName='stationDepartureTo' then stationDepartureTo[cpycnt]    =strip(myStringValue);
                  else if thisColName='stopIndex' then stopIndex[cpycnt]    =myDoubleValue;
                  else if thisColName='trackEnrouteToEnd' then trackEnrouteToEnd[cpycnt]    =strip(myStringValue);
                  else if thisColName='trackEnrouteToStart' then trackEnrouteToStart[cpycnt]    =strip(myStringValue);
                  else if thisColName='trainDepartureTimestamp' then trainDepartureTimestamp[cpycnt]    =myDoubleValue;
                  else if thisColName='trainDestination' then trainDestination[cpycnt]    =strip(myStringValue);
                  else if thisColName='trainExpArrivalTimestamp' then trainExpArrivalTimestamp[cpycnt]    =myDoubleValue;
                  else if thisColName='trainLatitude' then trainLatitude[cpycnt]    =myDoubleValue;
                  else if thisColName='trainLongitude' then trainLongitude[cpycnt]    =myDoubleValue;
 
                  _rcOutputColumnDefinitions_ = outputColumnDefinitionsHI.next();
 
                end;
 
              end;
              deleteVector('assetType|'||strip(thisAssetType)||'|outputAssetList');
 
              do cpycnt=numAssets+1 to numMaxFill;
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=.;
                assetType[cpycnt]='';
                assetID[cpycnt]='';
                currentLocation[cpycnt]='';
                currentStatus[cpycnt]='';
                currentStatusRaw[cpycnt]='';
                remainingStops[cpycnt]='';
                route[cpycnt]='';
                stationArrival[cpycnt]='';
                stationDepartureFrom[cpycnt]='';
                stationDepartureTo[cpycnt]='';
                stopIndex[cpycnt]=.;
                trackEnrouteToEnd[cpycnt]='';
                trackEnrouteToStart[cpycnt]='';
                trainDepartureTimestamp[cpycnt]=.;
                trainDestination[cpycnt]='';
                trainExpArrivalTimestamp[cpycnt]=.;
                trainLatitude[cpycnt]=.;
                trainLongitude[cpycnt]=.;
                _outOpcodeArray[cpycnt]='delete';
              end;
              numMaxFill=numAssets;
 
            end;
            else do;
 
              do cpycnt=1 to numMaxFill;
                key2[cpycnt]=cpycnt;
                msr_timestamp[cpycnt]=.;
                assetType[cpycnt]='';
                assetID[cpycnt]='';
                currentLocation[cpycnt]='';
                currentStatus[cpycnt]='';
                currentStatusRaw[cpycnt]='';
                remainingStops[cpycnt]='';
                route[cpycnt]='';
                stationArrival[cpycnt]='';
                stationDepartureFrom[cpycnt]='';
                stationDepartureTo[cpycnt]='';
                stopIndex[cpycnt]=.;
                trackEnrouteToEnd[cpycnt]='';
                trackEnrouteToStart[cpycnt]='';
                trainDepartureTimestamp[cpycnt]=.;
                trainDestination[cpycnt]='';
                trainExpArrivalTimestamp[cpycnt]=.;
                trainLatitude[cpycnt]=.;
                trainLongitude[cpycnt]=.;
                _outOpcodeArray[cpycnt]='delete';
              end;
              numMaxFill=0;
 
            end;
 
            endMonitoring();
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="outputRecords_train_gateModule" language="ds2" func-names="runOutputRecords_train_gate">
      <code><![CDATA[ds2_options sas;
 
        package outputRecords_train_gatePackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep;
          declare integer   numAssets cpycnt;
          declare char(300) thisAssetID thisOutputAssetID;
 
          declare bigint  numRequirements thisRequirementNum;
          declare integer allGatesOpenYN;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method openGate (bigint tr, bigint tdtm);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
 
            getVector('outputGate_train_req'||strip(put(tr,z5.)));
            rc = st.setLong('outputGate_train_req'||strip(put(tr,z5.)),0,tdtm);
            replaceVector('outputGate_train_req'||strip(put(tr,z5.)));
            deleteVector('outputGate_train_req'||strip(put(tr,z5.)));
 
            loggerString = 'NOTE: Opened outputGate_train_req'||strip(put(tr,z5.));
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method checkAllGates (bigint nr, bigint tdtm) returns integer;
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i nrs;
            declare bigint thisTimestamp;
 
            nrs=0;
            do i=1 to nr;
 
              thisTimestamp=0;
              getVector('outputGate_train_req'||strip(put(i,z5.)));
              thisTimestamp=st.getLong('outputGate_train_req'||strip(put(i,z5.)),0);
              deleteVector('outputGate_train_req'||strip(put(i,z5.)));
 
              if thisTimestamp = tdtm then nrs = nrs + 1;
 
            end;
 
            loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for outputGate_train';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            if nrs=nr then return 1;
            else           return 0;
 
          end;
 
          method closeAllGates (bigint nr);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i;
 
            do i=1 to nr;
 
              getVector('outputGate_train_req'||strip(put(i,z5.)));
              rc = st.setLong('outputGate_train_req'||strip(put(i,z5.)),0,0);
              replaceVector('outputGate_train_req'||strip(put(i,z5.)));
              deleteVector('outputGate_train_req'||strip(put(i,z5.)));
 
            end;
 
            loggerString = 'NOTE: Reset outputGate_train';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method runOutputRecords_train_gate (bigint     key1,
                                                    bigint     key2,
                                                    char(75)   assetType,
                                                    char(300)  assetID,
                                                    bigint     msr_timestamp,
                                                    in_out char(10) _outOpcode);
 
            getVector('assetType|train|outputAssetList');
            numAssets=st.getInt('assetType|train|outputAssetList',0);
            thisRequirementNum=0;
            numRequirements=numAssets;
            do cpycnt=1 to numAssets;
              thisAssetID=strip(st.getString('assetType|train|outputAssetList',cpycnt));
              thisOutputAssetID=tranwrd(thisAssetID,'^$*1*$^','|');
              if strip(thisOutputAssetID)=strip(assetID) then thisRequirementNum=cpycnt;
            end;
            deleteVector('assetType|train|outputAssetList');
 
            /*** open this gate by setting gate info to triggerTimestamp ***/
            openGate (thisRequirementNum, msr_timestamp);
 
            /*** now check all gates to see that they are all equal to msr_timestamp or if any are still closed ***/
            allGatesOpenYN=checkAllGates(numRequirements, msr_timestamp);
 
            /*** if all gates are open and equal to msr_timestamp then let the record through and close the gates to prep for next trigger ***/
            if allGatesOpenYN=1 then do;
              _outOpcode='insert';
              closeAllGates (numRequirements);
            end;
            else _outOpcode='delete';
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="outputRecords_gateModule" language="ds2" func-names="runOutputRecords_gate">
      <code><![CDATA[ds2_options sas;
 
        package outputRecords_gatePackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep;
          declare integer   numAssetTypes cpycnt;
          declare char(75)  thisAssetType;
 
          declare bigint  numRequirements thisRequirementNum;
          declare integer allGatesOpenYN;
 
          declare integer   numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          declare char(1) outputRecordsToABT;
 
          method init();
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method openGate (bigint tr, bigint tdtm);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
 
            getVector ('outputGate_req'||strip(put(tr,z4.)));
 
            rc = st.setLong('outputGate_req'||strip(put(tr,z4.)),0,tdtm);
 
            replaceVector ('outputGate_req'||strip(put(tr,z4.)));
            deleteVector ('outputGate_req'||strip(put(tr,z4.)));
 
            if rc1=0 then do;
              loggerString = 'NOTE: Opened outputGate_req'||strip(put(tr,z4.));
              if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
            end;
 
          end;
 
          method checkAllGates (bigint nr, bigint tdtm) returns integer;
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i nrs;
            declare bigint thisTimestamp;
 
            nrs=0;
            do i=1 to nr;
 
              thisTimestamp=0;
              getVector ('outputGate_req'||strip(put(i,z4.)));
              thisTimestamp=st.getLong('outputGate_req'||strip(put(i,z4.)),0);
              deleteVector ('outputGate_req'||strip(put(i,z4.)));
 
              if thisTimestamp = tdtm then nrs = nrs + 1;
 
            end;
 
            loggerString = 'NOTE: '||strip(put(nrs,8.0))||'/'||strip(put(nr,8.0))||' requirements satisfied for outputGate';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            if nrs=nr then return 1;
            else           return 0;
 
          end;
 
          method closeAllGates (bigint nr);
 
            declare double rc rc1 rc1s rc2 rc2s rcsleep;
            declare integer i;
 
            do i=1 to nr;
 
              getVector ('outputGate_req'||strip(put(i,z4.)));
 
              rc = st.setLong('outputGate_req'||strip(put(i,z4.)),0,0);
 
              replaceVector ('outputGate_req'||strip(put(i,z4.)));
              deleteVector ('outputGate_req'||strip(put(i,z4.)));
 
            end;
 
            loggerString = 'NOTE: Reset outputGate';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
          end;
 
          method runOutputRecords_gate (bigint     key1,
                                        bigint     key2,
                                        bigint     msr_timestamp,
                                        char(75)   assetType,
                                        in_out char(10) _outOpcode);
 
            /*** replace special characters ***/
            assetType=tranwrd(assetType,'|','^$*1*$^');
 
            getVector ('outputRecordsToABT');
            outputRecordsToABT = strip(st.getString('outputRecordsToABT',0));
            deleteVector ('outputRecordsToABT');
 
            if outputRecordsToABT='Y' then do;
 
              getVector ('outputAssetTypeListTHIS');
 
              numAssetTypes=st.getInt('outputAssetTypeListTHIS',0);
              thisRequirementNum=0;
              numRequirements=numAssetTypes+1;
              do cpycnt=1 to numAssetTypes;
                thisAssetType=strip(st.getString('outputAssetTypeListTHIS',cpycnt));
                if strip(assetType)=strip(thisAssetType) then thisRequirementNum=cpycnt;
              end;
              if strip(assetType)='heartBeat' then thisRequirementNum=numAssetTypes+1;
 
              deleteVector ('outputAssetTypeListTHIS');
 
            end;
            else do;
 
              numAssetTypes=0;
              numRequirements=1;
 
              thisRequirementNum=0;
              if strip(assetType)='heartBeat' then thisRequirementNum=1;
 
            end;
 
            /*** open this gate by setting gate info to triggerTimestamp ***/
            openGate (thisRequirementNum, msr_timestamp);
 
            /*** now check all gates to see that they are all equal to msr_timestamp or if any are still closed ***/
            allGatesOpenYN=checkAllGates(numRequirements, msr_timestamp);
 
            /*** if all gates are open and equal to msr_timestamp then let the record through and close the gates to prep for next trigger ***/
            if allGatesOpenYN=1 then do;
              _outOpcode='insert';
              closeAllGates (numRequirements);
            end;
            else _outOpcode='delete';
 
          end;
 
        endpackage;]]></code>
    </mas-module>
    <mas-module module="outputCompletionModule" language="ds2" func-names="runOutputCompletion">
      <code><![CDATA[ds2_options sas;
 
        package outputCompletionPackage / overwrite = yes;
 
          declare double rc rc1 rc1s rc2 rc2s rcsleep;
 
          declare package masstate st();
          declare package logger writeTo();
          declare char(200) loggerString;
 
          declare integer   numItems foundTHIS cntALL cntTHIS;
          declare char(300) tempItem;
          declare bigint    rawRecordCount outputRecordCount printRawQueueCount;
          declare bigint    thisOutputRecords thisRawRecords lastOutputRecords lastRawRecords;
          declare double    thisTime startTime nextOutputTime;
          declare bigint    nextDeleteInQueue;
 
          declare integer   cnt cnt2 cnt3;
          declare integer   numAssetTypes numAttributes numHierarchies;
          declare char(100) thisAttributeID;
          declare char(75)  thisAssetType;
          declare char(25)  thisHierarchyName;
          declare integer   numParents numChildren;
          declare char(300) thisParentAssetID thisChildAssetID;
 
          method init();
 
            startTime=datetime();
            nextOutputTime = 1.0 * int( (ceil((startTime*1.0)/60.0)*1.0) * 60 );
            outputRecordCount = 0;
 
            lastOutputRecords = 0;
            lastRawRecords    = 0;
 
          end;
 
method deleteVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.deleteVector(strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not delete '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.02*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method checkIfVectorExists (char(500) vectorName) returns integer;
 
/* declare double rcEX;    */
declare integer _vectorExists;
 
/* _vectorExists=0;   */
/* rcEX = st.hashTblGet(0,vectorName);  */
/* if rcEX=0 then do;    */
/*    _vectorExists=1;     */
/*   deleteVector(vectorName);     */
/* end; */
 
_vectorExists = st.hashTblContainsKey(0,strip(vectorName));
 
return _vectorExists;
 
end;
 
method createVector (char(500) vectorName, integer vectorLength);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.createVector(strip(vectorName),vectorLength);
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not create '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method getVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
rc1 = st.hashTblGet(0,strip(vectorName));
if rc1 ne 0 then do;
rc1s=1;
loggerString = 'WARNING: Could not retrieve '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
end;
else do;
if rc1s=1 then do;
loggerString = 'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method putVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method replaceVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 1 then do;
rc1 = st.hashTblReplace(0,strip(vectorName));
end;
else do;
rc1 = st.hashTblPut(0,strip(vectorName));
end;
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not put/replace '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method removeVector (char(500) vectorName);
 
rc1=1;
rc1s=0;
do while (rc1 ne 0);
if checkIfVectorExists(strip(vectorName)) = 0 then rc1=0;
else rc1 = st.hashTblRemove(0,strip(vectorName));
if rc1 ne 0 then do;
loggerString = 'WARNING: Could not remove '||strip(vectorName)||' - waiting 0.01 seconds to try again...';
writeTo.log('i', loggerString);
rcsleep=sleep(1,0.1*RAND('UNIForm'));
rc1s=1;
end;
else do;
if rc1s=1 then do;
loggerString = compress(rc1)||'WARNING: ...succeeded';
writeTo.log('i', loggerString);
end;
end;
end;
 
end;
 
method addItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
foundTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(tempItem) = strip(itemName) then do;
foundTHIS=1;
end;
end;
 
if foundTHIS=0 then do;
 
numItems=numItems+1;
rc = st.setInt(strip(vectorName),0,numItems);
rc = st.setString(strip(vectorName),numItems,strip(itemName));
replaceVector (vectorName);
 
end;
 
deleteVector (vectorName);
 
end;
 
end;
 
method removeItem (char(500) vectorName, char(300) itemName);
 
if checkIfVectorExists(strip(vectorName)) = 1 then do;
 
getVector (vectorName);
 
numItems=st.getInt(strip(vectorName),0);
 
cntTHIS=0;
do cntALL=1 to numItems;
tempItem=strip(st.getString(strip(vectorName),cntALL));
if strip(st.getString(strip(vectorName),cntALL)) ne strip(itemName) then do;
cntTHIS=cntTHIS+1;
rc = st.setString(strip(vectorName),cntTHIS,strip(tempItem));
end;
end;
rc = st.setInt(strip(vectorName),0,cntTHIS);
do cntALL=cntTHIS+1 to numItems;
rc = st.setString(strip(vectorName),cntALL,'');
end;
 
replaceVector (vectorName);
deleteVector (vectorName);
 
end;
 
end;
 
 
          method deleteAsset (char(300) di);
 
            if checkIfVectorExists('asset|'||strip(di)) = 1 then do;
 
              /* find the asset type */
              getVector ('asset|'||strip(di));
              thisAssetType = st.getString('asset|'||strip(di),0);
              deleteVector ('asset|'||strip(di));
 
              /* remove assetID from */
              /* 'assetType|'||strip(thisAssetType)||'|assetList' */
              /* 'assetType|'||strip(thisAssetType)||'|outputAssetList' */
              removeItem ('assetType|'||strip(thisAssetType)||'|assetList',strip(di));
              removeItem ('assetType|'||strip(thisAssetType)||'|outputAssetList',strip(di));
 
              /* iterate over hierarchies and delete the asset anywhere it is a child */
              /* 'asset|'||strip(di)||'|parents|'||strip(thisHierarchyName) */
              numHierarchies=0;
              getVector ('hierarchyList');
              numHierarchies=st.getInt('hierarchyList',0);
              do cnt=1 to numHierarchies;
                thisHierarchyName=st.getString('hierarchyList',cnt);
                getVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
                numParents=st.getInt('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),0);
                do cnt2=1 to numParents;
                  thisParentAssetID=st.getString('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName),cnt2);
 
                  if checkIfVectorExists('asset|'||strip(thisParentAssetID)) = 1 then do;
 
                    numChildren=0;
                    foundChild=0;
                    getVector ('asset|'||strip(thisParentAssetID)||'|children|'||strip(thisHierarchyName));
                    numChildren=st.getInt('asset|'||strip(thisParentAssetID)||'|children|'||strip(thisHierarchyName),0);
                    foundChild=0;
                    do cnt3=1 to numChildren;
                      if strip(st.getString('asset|'||strip(thisParentAssetID)||'|children|'||strip(thisHierarchyName),cnt3))=strip(di) then foundChild=1;
                    end;
                    deleteVector ('asset|'||strip(thisParentAssetID)||'|children|'||strip(thisHierarchyName));
 
                    if foundChild=1 then do;
                      removeItem ('asset|'||strip(thisParentAssetID)||'|children|'||strip(thisHierarchyName),strip(di));
                    end;
 
                  end;
                end;
                deleteVector ('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
              end;
 
              /* iterate over hierarchies and delete the asset anywhere it is a parent */
              /* 'asset|'||strip(di)||'|children|'||strip(thisHierarchyName) */
              do cnt=1 to numHierarchies;
                thisHierarchyName=st.getString('hierarchyList',cnt);
                getVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
                numChildren=st.getInt('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),0);
                do cnt2=1 to numChildren;
                  thisChildAssetID=st.getString('asset|'||strip(di)||'|children|'||strip(thisHierarchyName),cnt2);
 
                  if checkIfVectorExists('asset|'||strip(thisChildAssetID)) = 1 then do;
 
                    /*** add the parent to childs list and increment the counter ***/
                    /*** add the child to parents list and increment the counter ***/
                    numParents=0;
                    foundParent=0;
                    getVector ('asset|'||strip(thisChildAssetID)||'|parents|'||strip(thisHierarchyName));
                    numParents=st.getInt('asset|'||strip(thisChildAssetID)||'|parents|'||strip(thisHierarchyName),0);
                    foundParent=0;
                    do cnt3=1 to numParents;
                      if strip(st.getString('asset|'||strip(thisChildAssetID)||'|parents|'||strip(thisHierarchyName),cnt3))=strip(di) then foundParent=1;
                    end;
                    deleteVector ('asset|'||strip(thisChildAssetID)||'|parents|'||strip(thisHierarchyName));
 
                    if foundParent=1 then do;
                      removeItem ('asset|'||strip(thisChildAssetID)||'|parents|'||strip(thisHierarchyName),strip(di));
                    end;
 
                  end;
                end;
                deleteVector ('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
              end;
 
              /* delete vector named */
              /* 'asset|'||strip(di) */
              /* 'asset|'||strip(di)||'|attributeList' */
              /* 'asset|'||strip(di)||'|rawAttributeList' */
              removeVector('asset|'||strip(di));
              removeVector('asset|'||strip(di)||'|attributeList');
              removeVector('asset|'||strip(di)||'|rawAttributeList');
 
              /* iterate over hierarchies and delete vectors named */
              /* 'asset|'||strip(di)||'|parents|'||strip(thisHierarchyName) */
              /* 'asset|'||strip(di)||'|children|'||strip(thisHierarchyName) */
              do cnt=1 to numHierarchies;
                thisHierarchyName=st.getString('hierarchyList',cnt);
                removeVector('asset|'||strip(di)||'|parents|'||strip(thisHierarchyName));
                removeVector('asset|'||strip(di)||'|children|'||strip(thisHierarchyName));
              end;
              deleteVector ('hierarchyList');
 
              /* iterate over attributes and delete vectors named */
              /* 'asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue' */
              /* 'asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue' */
              /* 'asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA' */
              /* 'asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB' */
              /* 'asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history' */
              /* 'asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events' */
              numAttributes=0;
              getVector ('assetType|'||strip(thisAssetType)||'|attributeList');
              numAttributes=st.getInt('assetType|'||strip(thisAssetType)||'|attributeList',0);
              do cnt=1 to numAttributes;
                thisAttributeID=st.getString('assetType|'||strip(thisAssetType)||'|attributeList',cnt);
                removeVector('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValue');
                removeVector('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|lastValue');
                removeVector('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageA');
                removeVector('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|currentValueStorageB');
                removeVector('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|history');
                removeVector('asset|'||strip(di)||'|attribute|'||strip(thisAttributeID)||'|events');
              end;
              deleteVector ('assetType|'||strip(thisAssetType)||'|attributeList');
 
            end;
 
            loggerString = 'NOTE: Deleted assetID '||strip(di)||' (output completion).';
            writeTo.log('i', loggerString);
 
          end;
 
          method getDeleteRecordQueueDetail(in_out bigint _deleteRecordQueueSize,
                                            in_out bigint _deleteRecordQueueLast);
 
            _deleteRecordQueueSize=0;
            _deleteRecordQueueLast=0;
 
            getVector ('deleteRecordQueue');
            _deleteRecordQueueSize=st.getLong('deleteRecordQueue',0);
            deleteVector ('deleteRecordQueue');
 
            getVector ('deleteRecordQueueL');
            _deleteRecordQueueLast=st.getLong('deleteRecordQueueL',0);
            deleteVector ('deleteRecordQueueL');
 
          end;
 
          method checkNextDeleteInQueue() returns bigint;
 
            declare bigint _DeleteRecordQueueSize _DeleteRecordQueueLast;
            declare bigint _NextDeleteInQueue;
 
            getDeleteRecordQueueDetail(_DeleteRecordQueueSize,
                                       _DeleteRecordQueueLast);
 
            if _DeleteRecordQueueSize=_DeleteRecordQueueLast then do;
 
              _NextDeleteInQueue=.;
 
            end;
            else do;
 
              _NextDeleteInQueue=.;
 
              thisloc = mod(_DeleteRecordQueueLast,10000);
 
              getVector ('deleteRecordQueue'||strip(put(thisloc,z4.)));
 
              _NextDeleteInQueue = st.getLong('deleteRecordQueue'||strip(put(thisloc,z4.)),0);
 
              deleteVector ('deleteRecordQueue'||strip(put(thisloc,z4.)));
 
            end;
 
            return _NextDeleteInQueue;
 
          end;
 
          method updateDeleteRecordQueueDetail(bigint _deleteRecordQueueLast);
 
            getVector ('deleteRecordQueueL');
 
            rc = st.setLong('deleteRecordQueueL',0,_deleteRecordQueueLast);
 
            replaceVector ('deleteRecordQueueL');
            deleteVector ('deleteRecordQueueL');
 
          end;
 
          method processDeleteQueueThrough(
            bigint _NextDeleteInQueue
          );
 
            declare bigint     _DeleteRecordQueueSize _DeleteRecordQueueLast;
            declare bigint     _Msr_timestamp;
            declare char(50)   _Action;
            declare char(300)  _AssetID;
            declare char(75)   _AssetType;
            declare char(300)  _AssetLabel;
            declare char(1)    _OutputAssetRequired;
            declare integer    i thisloc;
 
            getDeleteRecordQueueDetail(_DeleteRecordQueueSize,
                                       _DeleteRecordQueueLast);
 
            if _DeleteRecordQueueSize gt _DeleteRecordQueueLast then do;
 
              i=_DeleteRecordQueueLast+1;
              do while (i le _DeleteRecordQueueSize);
 
                thisloc = mod(i-1,10000);
 
                getVector ('deleteRecordQueue'||strip(put(thisloc,z4.)));
 
                _Msr_timestamp       = st.getLong('deleteRecordQueue'||strip(put(thisloc,z4.)),0);
                _Action              = strip(st.getString('deleteRecordQueue'||strip(put(thisloc,z4.)),1));
                _AssetID             = strip(st.getString('deleteRecordQueue'||strip(put(thisloc,z4.)),2));
                _AssetType           = strip(st.getString('deleteRecordQueue'||strip(put(thisloc,z4.)),3));
                _AssetLabel          = strip(st.getString('deleteRecordQueue'||strip(put(thisloc,z4.)),4));
                _OutputAssetRequired = strip(st.getString('deleteRecordQueue'||strip(put(thisloc,z4.)),5));
 
                deleteVector ('deleteRecordQueue'||strip(put(thisloc,z4.)));
 
                if _Msr_timestamp le _NextDeleteInQueue or _NextDeleteInQueue=. then do;
 
                  deleteAsset (_AssetID);
 
                  removeVector('deleteRecordQueue'||strip(put(thisloc,z4.)));
 
                  updateDeleteRecordQueueDetail(i);
 
                end;
                else i=9999999999999;
 
                i = i + 1;
 
              end;
 
            end;
 
          end;
 
          method runOutputCompletion(bigint          key1,
                                     bigint          key2,
                                     bigint          msr_timestamp,
                                     in_out bigint   printTriggerQueueCount,
                                     in_out char(10) _outOpcode);
 
            /* delete assets that were requested during this time period */
            nextDeleteInQueue = checkNextDeleteInQueue();
            if 0 lt nextDeleteInQueue le msr_timestamp then do;
              processDeleteQueueThrough(msr_timestamp);
              getVector ('symUpdateNeeded');
              rc = st.setInt('symUpdateNeeded',0,1);
              replaceVector ('symUpdateNeeded');
              deleteVector ('symUpdateNeeded');
            end;
            else do;
              getVector ('symUpdateNeeded');
              rc = st.setInt('symUpdateNeeded',0,0);
              replaceVector ('symUpdateNeeded');
              deleteVector ('symUpdateNeeded');
            end;
 
            outputRecordCount = outputRecordCount + 1;
 
            getVector ('printTriggerQueueCount');
            printTriggerQueueCount = st.getLong('printTriggerQueueCount',0);
            deleteVector ('printTriggerQueueCount');
 
            thisTime = datetime();
            if thisTime gt nextOutputTime then do;
 
              getVector ('rawRecordCount');
              rawRecordCount = st.getLong('rawRecordCount',0);
              deleteVector ('rawRecordCount');
 
              getVector ('printRawQueueCount');
              printRawQueueCount = st.getLong('printRawQueueCount',0);
              deleteVector ('printRawQueueCount');
 
              thisOutputRecords = outputRecordCount - lastOutputRecords;
              thisRawRecords    = rawRecordCount    - lastRawRecords;
 
              lastOutputRecords = outputRecordCount;
              lastRawRecords    = rawRecordCount;
 
              nextOutputTime = 1.0 * int( (ceil((thisTime*1.0)/60.0)*1.0) * 60 );
 
              loggerString = 'AUTOML: '||strip(put(thisTime,datetime20.))||
                             ' - LAST - '||strip(put(dhms(0,0,0,msr_timestamp/1000000.0),datetime20.))||
                             ' - PROCESSED - Out '||strip(put(thisOutputRecords,24.))||' / Raw '||strip(put(thisRawRecords,24.))||
                             ' - QUEUE - Out '||strip(put(printTriggerQueueCount,24.))||' / Raw '||strip(put(printRawQueueCount,24.))||
                             ' - VECTORS - '||strip(put(st.hashTblSize(0),24.0));
              writeTo.log('i', loggerString);
 
            end;
 
            /*** set outputInProgress to false ***/
            getVector ('outputInProgress');
 
            rc = st.setString('outputInProgress',0,'false');
 
            replaceVector ('outputInProgress');
            deleteVector ('outputInProgress');
 
            loggerString = 'NOTE: '||strip(put(datetime(),24.6))||' - Output record(s) processed for '||put((msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0)||'.';
            if '@logLevel@' in ('debug') then writeTo.log('i', loggerString);
 
            loggerString = 'NOTE: Output processing complete for '||strip(put((msr_timestamp/1000000.0) - (dhms(mdy(1,1,1970),0,0,0)*1.0),24.0));
            if '@logLevel@' in ('luaDebug') then writeTo.log('i', loggerString);
 
            _outOpcode='insert';
 
          end;
 
        endpackage;]]></code>
    </mas-module>
 
    <mas-module language="ds2" func-names="runScoredRecords" module="station_scoredRecords">
      <code><![CDATA[
        ds2_options sas;
 
        package station_scoredRecords / overwrite = yes;
 
          method init();
 
          end;
 
          method runScoredRecords(
                                  bigint     key1,
                                  bigint     key2,
                                  char(75)   assetType,
                                  char(300)  assetID,
                                  bigint     msr_timestamp,
            char(100) expectedNextTrain1ID,
            char(20) expectedNextTrain1Time,
            char(100) expectedNextTrain2ID,
            char(20) expectedNextTrain2Time,
            char(100) lastDepartedTrain,
            char(50) lastDepartedTrainStatus,
            char(100) nextStationTrain1,
            char(100) nextStationTrain2,
            char(100) nextTrackTrain1,
            char(100) nextTrackTrain2,
            double numTrainsAtNextStation,
            double numTrainsAtPrevStation,
            double numTrainsEnrouteFromThis,
            double numTrainsEnrouteToThis,
            char(100) prevStationTrain1,
            char(100) prevStationTrain2,
            char(100) prevTrackTrain1,
            char(100) prevTrackTrain2,
            double prevTrackTravelTime,
            char(50) route,
            double stationLatitude,
            double stationLongitude,
            char(50) trainArrival,
            char(50) trainDepartureFrom,
            char(50) trainDepartureTo,
            char(50) trainInStation,
            double waitTime,
            double waitTimeRollingAvg,
            in_out char _outOpcode
            );
 
 
 
            _outOpcode='insert';
 
          end;
 
        endpackage;
      ]]></code>
    </mas-module>
    <mas-module language="ds2" func-names="runScoredRecords" module="track_scoredRecords">
      <code><![CDATA[
        ds2_options sas;
 
        package track_scoredRecords / overwrite = yes;
 
          method init();
 
          end;
 
          method runScoredRecords(
                                  bigint     key1,
                                  bigint     key2,
                                  char(75)   assetType,
                                  char(300)  assetID,
                                  bigint     msr_timestamp,
            char(50) enrouteToEnd,
            char(50) enrouteToStart,
            char(100) enrouteTrain1,
            char(100) enrouteTrain2,
            char(100) lastEnrouteTrain,
            double lastEnrouteTrainEnd,
            double lastEnrouteTrainStart,
            char(50) lastEnrouteTrainStatus,
            char(50) route,
            double trackLatitude,
            double trackLatitude1,
            double trackLongitude,
            double trackLongitude1,
            double travelTime,
            double travelTimeRollingAvg,
            in_out char _outOpcode
            );
 
 
 
            _outOpcode='insert';
 
          end;
 
        endpackage;
      ]]></code>
    </mas-module>
    <mas-module language="ds2" func-names="runScoredRecords" module="train_scoredRecords">
      <code><![CDATA[
        ds2_options sas;
 
        package train_scoredRecords / overwrite = yes;
 
          method init();
 
          end;
 
          method runScoredRecords(
                                  bigint     key1,
                                  bigint     key2,
                                  char(75)   assetType,
                                  char(300)  assetID,
                                  bigint     msr_timestamp,
            char(50) currentLocation,
            char(50) currentStatus,
            char(50) currentStatusRaw,
            char(200) remainingStops,
            char(50) route,
            char(50) stationArrival,
            char(50) stationDepartureFrom,
            char(50) stationDepartureTo,
            double stopIndex,
            char(50) trackEnrouteToEnd,
            char(50) trackEnrouteToStart,
            double trainDepartureTimestamp,
            char(50) trainDestination,
            double trainExpArrivalTimestamp,
            double trainLatitude,
            double trainLongitude,
            in_out char _outOpcode
            );
 
 
 
            _outOpcode='insert';
 
          end;
 
        endpackage;
      ]]></code>
    </mas-module>
 
 
  </mas-modules>
  <contqueries>
    <contquery name="cq1" index="pi_EMPTY">
      <windows>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="readAssetTypeDefinitions">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetTypeLabel" type="string"/>
              <field name="outputFileRequired" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="fs" name="assetTypeDefinitionsConnector">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="fsname"><![CDATA[@ESP_PROJECT_HOME@/files/assetTypes.csv]]></property>
                <property name="fstype"><![CDATA[csv]]></property>
                <property name="blocksize"><![CDATA[1]]></property>
                <property name="header"><![CDATA[1]]></property>
                <property name="growinginputfile"><![CDATA[false]]></property>
                <property name="addcsvflags"><![CDATA[normal]]></property>
                <property name="addcsvopcode"><![CDATA[true]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-calculate index="pi_EMPTY" collapse-updates="false" output-insert-only="true" name="defineAssetTypes" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetTypeLabel" type="string"/>
              <field name="outputFileRequired" type="string"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="defineAssetTypesModule" function="runDefineAssetTypes" revision="0" source="readAssetTypeDefinitions"/>
          </mas-map>
        </window-calculate>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="readAttributeDefinitions">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="attributeType" type="string"/>
              <field name="attributeID" type="string"/>
              <field name="attributeLabel" type="string"/>
              <field name="SASAttributeID" type="string"/>
              <field name="dataType" type="string"/>
              <field name="dataLength" type="int32"/>
              <field name="dataFormat" type="string"/>
              <field name="retentionPeriod" type="int32"/>
              <field name="acceptableMin" type="double"/>
              <field name="acceptableMinLogic" type="string"/>
              <field name="acceptableMax" type="double"/>
              <field name="acceptableMaxLogic" type="string"/>
              <field name="historyMaxEvents" type="int32"/>
              <field name="historyMaxTime" type="int32"/>
            </fields>
          </schema>
          <connectors>
            <connector class="fs" name="attributeDefinitionsConnector">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="fsname"><![CDATA[@ESP_PROJECT_HOME@/files/attributes.csv]]></property>
                <property name="fstype"><![CDATA[csv]]></property>
                <property name="blocksize"><![CDATA[1]]></property>
                <property name="header"><![CDATA[1]]></property>
                <property name="growinginputfile"><![CDATA[false]]></property>
                <property name="addcsvflags"><![CDATA[normal]]></property>
                <property name="addcsvopcode"><![CDATA[true]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-calculate index="pi_EMPTY" collapse-updates="false" output-insert-only="true" name="defineAttributes" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="attributeType" type="string"/>
              <field name="attributeID" type="string"/>
              <field name="attributeLabel" type="string"/>
              <field name="SASAttributeID" type="string"/>
              <field name="dataType" type="string"/>
              <field name="dataLength" type="int32"/>
              <field name="dataFormat" type="string"/>
              <field name="retentionPeriod" type="int32"/>
              <field name="acceptableMin" type="double"/>
              <field name="acceptableMinLogic" type="string"/>
              <field name="acceptableMax" type="double"/>
              <field name="acceptableMaxLogic" type="string"/>
              <field name="historyMaxEvents" type="int32"/>
              <field name="historyMaxTime" type="int32"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="defineAttributesModule" function="runDefineAttributes" revision="0" source="readAttributeDefinitions"/>
          </mas-map>
        </window-calculate>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="readHierarchyDefinitions">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="hierarchyName" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="fs" name="hierarchyDefinitionsConnector">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="fsname"><![CDATA[@ESP_PROJECT_HOME@/files/hierarchyList.csv]]></property>
                <property name="fstype"><![CDATA[csv]]></property>
                <property name="blocksize"><![CDATA[1]]></property>
                <property name="header"><![CDATA[1]]></property>
                <property name="growinginputfile"><![CDATA[false]]></property>
                <property name="addcsvflags"><![CDATA[normal]]></property>
                <property name="addcsvopcode"><![CDATA[true]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-calculate index="pi_EMPTY" collapse-updates="false" output-insert-only="true" name="defineHierarchies" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="hierarchyName" type="string"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="defineHierarchiesModule" function="runDefineHierarchies" revision="0" source="readHierarchyDefinitions"/>
          </mas-map>
        </window-calculate>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="initialAssetUpdates">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="assetID" type="string"/>
              <field name="assetType" type="string"/>
              <field name="assetLabel" type="string"/>
              <field name="outputAssetRequired" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="fs" name="initialAssetUpdatesConnector">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="fsname"><![CDATA[@ESP_PROJECT_HOME@/files/assets.csv]]></property>
                <property name="fstype"><![CDATA[csv]]></property>
                <property name="blocksize"><![CDATA[1]]></property>
                <property name="header"><![CDATA[1]]></property>
                <property name="growinginputfile"><![CDATA[false]]></property>
                <property name="addcsvflags"><![CDATA[normal]]></property>
                <property name="addcsvopcode"><![CDATA[true]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-functional pubsub="true" index="pi_EMPTY" name="initialAssetUpdatesForUnion">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="assetID" type="string"/>
              <field name="assetType" type="string"/>
              <field name="assetLabel" type="string"/>
              <field name="outputAssetRequired" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <function-context>
            <functions>
              <function name="msr_timestamp"><![CDATA[0]]></function>
            </functions>
          </function-context>
        </window-functional>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="ongoingAssetUpdates">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="assetID" type="string"/>
              <field name="assetType" type="string"/>
              <field name="assetLabel" type="string"/>
              <field name="outputAssetRequired" type="string"/>
            </fields>
          </schema>
        </window-source>
        <window-functional pubsub="true" index="pi_EMPTY" name="ongoingAssetUpdatesForUnion">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="assetID" type="string"/>
              <field name="assetType" type="string"/>
              <field name="assetLabel" type="string"/>
              <field name="outputAssetRequired" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <function-context>
            <functions>
              <function name="msr_timestamp"><![CDATA[systemMicro()]]></function>
            </functions>
          </function-context>
        </window-functional>
         <window-functional pubsub="true" index="pi_EMPTY" name="historicalAssetUpdates">
           <schema>
             <fields>
               <field name="key1" type="int64" key="true"/>
               <field name="action" type="string"/>
               <field name="assetID" type="string"/>
               <field name="assetType" type="string"/>
               <field name="assetLabel" type="string"/>
               <field name="outputAssetRequired" type="string"/>
               <field name="msr_timestamp" type="stamp"/>
             </fields>
           </schema>
           <function-context>
             <functions>
               <function name="action"><![CDATA[$updateAssetAction]]></function>
               <function name="assetID"><![CDATA[$updateAssetID]]></function>
               <function name="assetType"><![CDATA[$updateAssetType]]></function>
               <function name="assetLabel"><![CDATA[$updateAssetLabel]]></function>
               <function name="outputAssetRequired"><![CDATA[$updateAssetOutputRequired]]></function>
             </functions>
           </function-context>
         </window-functional>
        <window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="unionAssetUpdates"/>
        <window-calculate index="pi_EMPTY" collapse-updates="false" output-insert-only="true" name="updateAssets" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="assetID" type="string"/>
              <field name="assetType" type="string"/>
              <field name="assetLabel" type="string"/>
              <field name="outputAssetRequired" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="updateAssetsModule" function="runUpdateAssets" revision="0" source="unionAssetUpdates"/>
          </mas-map>
        </window-calculate>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="initialHierarchyUpdates">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="hierarchyName" type="string"/>
              <field name="parentAssetID" type="string"/>
              <field name="direction" type="string"/>
              <field name="childAssetID" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="fs" name="initialHierarchyUpdatesConnector">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="fsname"><![CDATA[@ESP_PROJECT_HOME@/files/hierarchyMap.csv]]></property>
                <property name="fstype"><![CDATA[csv]]></property>
                <property name="blocksize"><![CDATA[1]]></property>
                <property name="header"><![CDATA[1]]></property>
                <property name="growinginputfile"><![CDATA[false]]></property>
                <property name="addcsvflags"><![CDATA[normal]]></property>
                <property name="addcsvopcode"><![CDATA[true]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-functional pubsub="true" index="pi_EMPTY" name="initialHierarchyUpdatesForUnion">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="hierarchyName" type="string"/>
              <field name="parentAssetID" type="string"/>
              <field name="direction" type="string"/>
              <field name="childAssetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <function-context>
            <functions>
              <function name="msr_timestamp"><![CDATA[0]]></function>
            </functions>
          </function-context>
        </window-functional>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="ongoingHierarchyUpdates">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="hierarchyName" type="string"/>
              <field name="parentAssetID" type="string"/>
              <field name="direction" type="string"/>
              <field name="childAssetID" type="string"/>
            </fields>
          </schema>
        </window-source>
        <window-functional pubsub="true" index="pi_EMPTY" name="ongoingHierarchyUpdatesForUnion">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="hierarchyName" type="string"/>
              <field name="parentAssetID" type="string"/>
              <field name="direction" type="string"/>
              <field name="childAssetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <function-context>
            <functions>
              <function name="msr_timestamp"><![CDATA[systemMicro()]]></function>
            </functions>
          </function-context>
        </window-functional>
         <window-functional pubsub="true" index="pi_EMPTY" name="historicalHierarchyUpdates">
           <schema>
             <fields>
               <field name="key1" type="int64" key="true"/>
               <field name="action" type="string"/>
               <field name="hierarchyName" type="string"/>
               <field name="parentAssetID" type="string"/>
               <field name="direction" type="string"/>
               <field name="childAssetID" type="string"/>
               <field name="msr_timestamp" type="stamp"/>
             </fields>
           </schema>
           <function-context>
             <functions>
               <function name="action"><![CDATA[$updateConnectionAction]]></function>
               <function name="hierarchyName"><![CDATA[$updateHierarchyName]]></function>
               <function name="parentAssetID"><![CDATA[$updateParentAssetID]]></function>
               <function name="direction"><![CDATA[$updateDirection]]></function>
               <function name="childAssetID"><![CDATA[$updateChildAssetID]]></function>
             </functions>
           </function-context>
         </window-functional>
        <window-union name="unionHierarchyUpdates" collapse-updates="true" strict="true" index="pi_EMPTY" output-insert-only="true"/>
        <window-calculate index="pi_EMPTY" collapse-updates="false" output-insert-only="true" name="updateHierarchies" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="action" type="string"/>
              <field name="hierarchyName" type="string"/>
              <field name="parentAssetID" type="string"/>
              <field name="direction" type="string"/>
              <field name="childAssetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="updateHierarchiesModule" function="runUpdateHierarchies" revision="0" source="unionHierarchyUpdates"/>
          </mas-map>
        </window-calculate>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="staticAttributesDataSource">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="assetID" type="string"/>
              <field name="attributeID" type="string"/>
              <field name="value" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="fs" name="staticAttributesConnector">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="fsname"><![CDATA[@ESP_PROJECT_HOME@/files/staticAttributes.csv]]></property>
                <property name="fstype"><![CDATA[csv]]></property>
                <property name="blocksize"><![CDATA[1]]></property>
                <property name="header"><![CDATA[1]]></property>
                <property name="growinginputfile"><![CDATA[false]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="historicalDataSource">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="dataType" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="assetID" type="string"/>
              <field name="attributeID" type="string"/>
              <field name="value" type="string"/>
               <field name="updateAssetAction" type="string"/>
               <field name="updateAssetID" type="string"/>
               <field name="updateAssetType" type="string"/>
               <field name="updateAssetLabel" type="string"/>
               <field name="updateAssetOutputRequired" type="string"/>
               <field name="updateConnectionAction" type="string"/>
               <field name="updateHierarchyName" type="string"/>
               <field name="updateParentAssetID" type="string"/>
               <field name="updateDirection" type="string"/>
               <field name="updateChildAssetID" type="string"/>
            </fields>
          </schema>
        </window-source>
        <window-functional pubsub="true" index="pi_EMPTY" name="historicalDataSourceSplitter">
           <splitter-expr>
             <expression>
               <![CDATA[
                   if(dataType == "data") return 1
                   else if(dataType == "updateAssets") return 2
                   else if(dataType == "updateConnections") return 3
                   else return 1
                 ]]>
             </expression>
           </splitter-expr>
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="dataType" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="assetID" type="string"/>
              <field name="attributeID" type="string"/>
              <field name="value" type="string"/>
               <field name="updateAssetAction" type="string"/>
               <field name="updateAssetID" type="string"/>
               <field name="updateAssetType" type="string"/>
               <field name="updateAssetLabel" type="string"/>
               <field name="updateAssetOutputRequired" type="string"/>
               <field name="updateConnectionAction" type="string"/>
               <field name="updateHierarchyName" type="string"/>
               <field name="updateParentAssetID" type="string"/>
               <field name="updateDirection" type="string"/>
               <field name="updateChildAssetID" type="string"/>
            </fields>
          </schema>
        </window-functional>
        <window-functional pubsub="true" index="pi_EMPTY" name="historicalData">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="assetID" type="string"/>
              <field name="attributeID" type="string"/>
              <field name="value" type="string"/>
            </fields>
          </schema>
        </window-functional>
        <window-source index="pi_EMPTY" insert-only="true" autogen-key="true" name="realtimeTriggerRaw">
          <schema>
            <fields>
              <field name="id" type="int64" key="true"/>
              <field name="time" type="stamp"/>
              <field name="label" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="timer" name="realtimeTriggerConnector">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="basetime"><![CDATA[2022-01-01 00:00:00]]></property>
                <property name="interval"><![CDATA[100]]></property>
                <property name="unit"><![CDATA[millisecond]]></property>
                <property name="label"><![CDATA[realtime]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-functional pubsub="true" index="pi_EMPTY" name="realtimeTrigger">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="assetID" type="string"/>
              <field name="attributeID" type="string"/>
              <field name="value" type="string"/>
            </fields>
          </schema>
          <function-context>
            <functions>
              <function name="msr_timestamp"><![CDATA[time]]></function>
              <function name="assetID"><![CDATA["outputTrigger"]]></function>
              <function name="attributeID"><![CDATA["outputTrigger"]]></function>
              <function name="value"><![CDATA["notApplicable"]]></function>
              <function name="key1"><![CDATA[id]]></function>
            </functions>
          </function-context>
        </window-functional>
 
<window-source autogen-key="true" index="pi_EMPTY" insert-only="true" output-insert-only="true" name="gtfs_pulse">
  <schema>
    <fields>
      <field key="true" name="id" type="int64"/>
      <field name="time" type="stamp"/>
      <field name="label" type="string"/>
    </fields>
  </schema>
  <connectors>
    <connector class="timer" name="gtfs_connector">
      <properties>
        <property name="type"><![CDATA[pub]]></property>
        <property name="basetime"><![CDATA[2020-06-08 00:50:00]]></property>
        <property name="interval"><![CDATA[10]]></property>
        <property name="unit"><![CDATA[second]]></property>
        <property name="label"><![CDATA[minutely]]></property>
      </properties>
    </connector>
  </connectors>
</window-source>
 
<window-python events="create" index="pi_EMPTY" output-insert-only="true" name="gtfs_read">
  <schema>
    <fields>
      <field name="key1" type="int64" key="true"/>
      <field name="msr_timestamp" type="stamp"/>
      <field name="assetID" type="string"/>
      <field name="attributeID" type="string"/>
      <field name="value" type="string"/>
      <field name="action" type="string"/>
      <field name="updateAssetAction" type="string"/>
      <field name="updateAssetID" type="string"/>
      <field name="updateAssetType" type="string"/>
      <field name="updateAssetLabel" type="string"/>
      <field name="updateAssetOutputRequired" type="string"/>
      <field name="updateConnectionAction" type="string"/>
      <field name="updateHierarchyName" type="string"/>
      <field name="updateParentAssetID" type="string"/>
      <field name="updateDirection" type="string"/>
      <field name="updateChildAssetID" type="string"/>
    </fields>
  </schema>
  <code><![CDATA[
 
import esp
 
train_list = {}
 
class Train:
    """
    Represents a subway train being tracked in the system.
    - Initializes trains & train attributes when first detected
    - Updates train status and location based on new data
 
    Attributes:
        id (str): Unique train identifier (assetID)
        route (str): Route the train is assigned to
        destination (str): Final destination of the train
        curr_status (str): Current status ('stopped' or 'moving')
        curr_loc (str): Current location
        curr_conn (str): Connection descriptor used for routing logic
        msr_timestamp (int): Timestamp of the last update
    """
 
    def __init__(self, id, route, trainDestination, location_status, location, msr_timestamp):
        """
        Initializes a Train object.
 
        Args:
            id (str): Unique train identifier (assetID)
            route (str): Assigned route
            trainDestination (str): Final destination
            location_status (str): Status from GTFS (STOPPED_AT, INCOMING_AT, IN_TRANSIT_TO)
            location (str): Current location
            msr_timestamp (int): Timestamp of the update
 
        Notes:
            For this system, INCOMING_AT is treated the same as IN_TRANSIT_TO.
        """
        self.id = id
 
        # Set route and destination if provided
        if route != "":
            self.route = route
        if trainDestination != "":
            self.destination = trainDestination
 
        # Determine initial status and connection based on GTFS location_status
        if location_status == 'STOPPED_AT':
            self.curr_status = 'stopped'
            self.curr_loc    = location
            self.curr_conn   = location
        elif location_status != "":
            self.curr_status = 'moving'
            self.curr_loc    = location
            self.curr_conn   = 'enrouteTo'+location
        else:
            self.curr_status = ''
            self.curr_loc    = ''
            self.curr_conn   = ''
 
        self.msr_timestamp = msr_timestamp
 
    def __str__(self):
        """
        String representation of the train for logging/debugging.
        """
        return f"Train(id={self.id}, route={self.route}, trainDestination={self.destination}, curr_status={self.curr_status}, curr_loc={self.curr_loc}, curr_conn={self.curr_conn}, msr_timestamp={self.msr_timestamp})"
 
    def update(self, route, trainDestination, location_status, location, msr_timestamp):
        """
        Updates the train's status and location based on new incoming data.
 
        Args:
            route (str): Updated route
            trainDestination (str): Updated destination
            location_status (str): Updated GTFS status
            location (str): Updated location
            msr_timestamp (str): Timestamp of the update
 
        Returns:
            updates: A list of structured update records
        """
        updates = []
 
        # Update route and destination if new values are provided
        if route != "":
            self.route = route
        if trainDestination != "":
            self.destination = trainDestination
 
        # Determine new status and connection
        if location_status == "STOPPED_AT":
            this_status = 'stopped'
            this_loc    = location
            this_conn   = location
        else:
            this_status = 'moving'
            this_loc    = location
            this_conn   = 'enrouteTo'+location
 
        # First-time update: no current connection exists
        # Updates status and connections
        if self.curr_conn == "":
            if this_status == "stopped":
                updates.append([msr_timestamp,self.id,'currentStatus','stoppedAt '+this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
            else:
                updates.append([msr_timestamp,self.id,'currentStatus','enrouteTo '+this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
 
        # No change in connection — train remains at same location with the same status
        # Updates only status
        elif self.curr_conn == this_conn:
            if self.curr_status == 'stopped':
                # Updating status from recently arrived to stoppedAt
                updates.append([msr_timestamp,self.id,'currentStatus','stoppedAt '+this_loc,'data','','','','','','','','','',''])
            else:
                # Updating status from departedTo to enrouteTo
                updates.append([msr_timestamp,self.id,'currentStatus','enrouteTo '+this_loc,'data','','','','','','','','','',''])
 
        # Status unchanged but location changed — implies skipped event
        # Updates status and connections
        elif self.curr_status == this_status and self.curr_loc != this_loc:
            if this_status == 'stopped':
                if self.destination == this_loc:
                    updates.append([msr_timestamp,self.id,'currentStatus','stoppedAt '+this_loc,'data','','','','','','','','','',''])
                    updates.append([msr_timestamp,'','','','updateAssets','delete',self.id,'train',self.id,'N','','','','',''])
                else:
                    updates.append([msr_timestamp,self.id,'currentStatus','stoppedAt '+this_loc,'data','','','','','','','','','',''])
                    updates.append([msr_timestamp,'','','','updateConnections','','','','','','delete',self.route,self.curr_conn,'<->',self.id])
                    updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
            else:
                updates.append([msr_timestamp,self.id,'currentStatus','enrouteTo '+this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','delete',self.route,self.curr_conn,'<->',self.id])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
 
        # Status change — e.g., moving → stopped or stopped → moving
        elif self.curr_status != this_status:
            if this_status == 'stopped':
                # Train has arrived at a station
                updates.append([msr_timestamp,self.id,'stationArrival',this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,this_loc,'trainArrival',self.id,'data','','','','','','','','','',''])
 
                updates.append([msr_timestamp,self.id,'trackEnrouteToEnd','enrouteTo'+this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,'enrouteTo'+this_loc,'enrouteToEnd',self.id,'data','','','','','','','','','',''])
 
                if self.destination == this_loc:
                    # Train has completed its route
                    updates.append([msr_timestamp,self.id,'currentStatus','completedRouteAt '+this_loc,'data','','','','','','','','','',''])
                    updates.append([msr_timestamp,'','','','updateAssets','delete',self.id,'train',self.id,'N','','','','',''])
                else:
                    # Train arrived at a non-destination station
                    updates.append([msr_timestamp,self.id,'currentStatus','arrivedAt '+this_loc,'data','','','','','','','','','',''])
                    updates.append([msr_timestamp,'','','','updateConnections','','','','','','delete',self.route,self.curr_conn,'<->',self.id])
                    updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
 
            else:
                # Train has departed a station and is now moving
                updates.append([msr_timestamp,self.id,'stationDepartureFrom',self.curr_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,self.curr_loc,'trainDepartureFrom',self.id,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,self.id,'stationDepartureTo',this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,this_loc,'trainDepartureTo',self.id,'data','','','','','','','','','',''])
 
                updates.append([msr_timestamp,self.id,'trackEnrouteToStart','enrouteTo'+this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,'enrouteTo'+this_loc,'enrouteToStart',self.id,'data','','','','','','','','','',''])
 
                updates.append([msr_timestamp,self.id,'currentStatus','departedTo '+this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','delete',self.route,self.curr_conn,'<->',self.id])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
 
        else:
            # Catch-all for edge cases not covered above
            if this_status == "stopped":
                if self.trainDestination == this_loc:
                    # Train has stopped at its destination
                    updates.append([msr_timestamp,self.id,'currentStatus','stoppedAt '+this_loc,'data','','','','','','','','','',''])
                    updates.append([msr_timestamp,'','','','updateAssets','delete',self.id,'train',self.id,'N','','','','',''])
                else:
                    # Train stopped at a non-destination location
                    updates.append([msr_timestamp,self.id,'currentStatus','stoppedAt '+this_loc,'data','','','','','','','','','',''])
                    updates.append([msr_timestamp,'','','','updateConnections','','','','','','delete',self.route,self.curr_conn,'<->',self.id])
                    updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
            else:
                # Train is moving to a new location
                updates.append([msr_timestamp,self.id,'currentStatus','enrouteTo '+this_loc,'data','','','','','','','','','',''])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','delete',self.route,self.curr_conn,'<->',self.id])
                updates.append([msr_timestamp,'','','','updateConnections','','','','','','add',self.route,this_conn,'<->',self.id])
 
        # Updating train information for the next processing
        self.curr_status      = this_status
        self.curr_loc         = this_loc
        self.curr_conn        = this_conn
 
        # Sending all update records from this update block
        return updates
 
def find_route(long_route):
    """
    Parses a full route identifier and returns the abbreviated route name.
 
    Expected input formats:
        - "1..S03R" → returns "1..S"
        - "SI.S03R" → returns "SI.S"
        - "FS.N02R" → returns "FS.N"
        - Special case: "SI.NXXX" → returns "SI.." (not "SI..N")
    """
    dot_index = long_route.find("..")
 
    if dot_index != -1:
        # Route contains ".." — return prefix plus next character (e.g., "1..S")
        return long_route[:dot_index + 3]
    else:
        dot_index = long_route.find(".")
        if long_route[:2] == 'SI':
            # Special handling for Staten Island routes
            if dot_index != -1 and len(long_route) > dot_index + 1:
                if long_route[dot_index + 1] == 'S':
                    return 'SI..S'
                elif long_route[dot_index + 1] == 'N':
                    return 'SI..'
        else:
            # General case: return prefix plus next character (e.g., "FS.N")
            if dot_index != -1:
                return long_route[:dot_index + 2]
 
    # Fallback: return original string if no known pattern matched
    return long_route
 
def gtfs_read_function(events,thisroute):
    global key1
    import time
    import urllib
    import urllib.request
    import getpass
    import string
    import datetime as dt
    import json
    from nyct_gtfs import NYCTFeed # Library for accessing MTA GTFS data
    import re
    from datetime import datetime, timezone, timedelta
 
    # Initialize counters and storage containers
    numrecs = 0           # Number of records processed
    alltrips = []         # List to store parsed train trip data
    failedquery = 0       # Flag for API query failure
    failedread = 0        # Flag for data parsing failure
 
    try:
        # Query the GTFS API for current trips on a specified subway route
        feed=NYCTFeed(thisroute)
        trains = feed.filter_trips(line_id=[thisroute],underway=True)
    except:
        failedquery=1
 
    if failedquery==0:
        for train in trains:
 
            # Attempt to extract the train's unique asset ID
            try:
                assetID = train.nyc_train_id
            except:
                failedread = 1
 
            # Attempt to parse and simplify the route identifier
            try:
                route = find_route(train.shape_id)
            except:
                failedread = 1
 
            # Use the current UTC time as the timestamp
            try:
                utc_now = datetime.now(timezone.utc)
                curr_timestamp=int(utc_now.timestamp()*1000000)
                msr_timestamp = curr_timestamp
 
                # Old code extracting the timestamp from the last position update
                # Faced issues with the timestamp
                # msr_timestamp=int(train.last_position_update.timestamp()*1000000)
            except:
                failedread = 1
 
            # Attempt to extract the train's current location
            try:
                location = train.location
            except:
                failedread = 1
 
            # Attempt to extract the train's location status
            try:
                location_status = train.location_status
            except:
                failedread = 1
 
            # Attempt to extract the stop index in the train's route sequence
            try:
                stopIndex = str(train.current_stop_sequence_index)
            except:
                # Non-issue if the stop index is not found
                stopIndex=""
                doNothing = 1
 
            # Attempt to extract and format the train's scheduled departure time
            try:
                departure_timestamp=int(train.departure_time.timestamp()*1000000)
 
                departure_datetime = train.departure_time
                departureDateString = departure_datetime.strftime("%Y-%m-%d %H:%M:%S")
                departureDateString = departureDateString[0:10]
            except:
                failedread = 1
 
            # Attempt to extract the list of upcoming stops and final destination
            try:
                # Extracting the list of upcoming stops for the train
                remainingStops=train.stop_time_updates
 
                # Converting the stop data to a string for manual formatting
                asString=str(remainingStops)
 
                # Perform a series of string replacements to convert the raw stop data into valid JSON format
                # These replacements add quotes and colons to make the data parsable by json.loads()
                asString=asString.replace('ID: ', 'ID: "')
                asString=asString.replace('Arr: ', 'Arr: "')
                asString=asString.replace('Dep: ', 'Dep: "')
                asString=asString.replace('Sched: ', 'Sched: "')
                asString=asString.replace('Act: ', 'Act: "')
                asString=asString.replace(', Arr', '", Arr')
                asString=asString.replace(', Dep', '", Dep')
                asString=asString.replace(', Sched', '", Sched')
                asString=asString.replace(', Act', '", Act')
                asString=asString.replace('ID:', '"ID":')
                asString=asString.replace('Arr:', '"Arr":')
                asString=asString.replace('Dep:', '"Dep":')
                asString=asString.replace('Sched:', '"Sched":')
                asString=asString.replace('Act:', '"Act":')
                asString=asString.replace('},', '"},')
                asString=asString.replace(', }', '", }')
                asString=asString.replace(', }', '}')
                asString=asString.replace('}]', '"}]')
 
                # Create JSON object
                asJson=json.loads(asString)
 
                # Count the number of stops in the route
                numStops=len(asJson)
 
                # Determine the train's destination based on the number of stops
                if numStops<3:
                    # If there are fewer than 3 stops, use the first stop as the destination
                    trainDestination=asJson[0]['ID']
                else:
                    # Otherwise, use the second-to-last stop as the destination
                    trainDestination=asJson[numStops-2]['ID']
            except:
                # If parsing fails, log a warning and set default values
                print('WARNING: Could not get trainDestination')
                trainDestination=""
                nothingNeeded = 1
 
            # Attempt to create a list of upcoming stops
            # And parse out the expected route completion time
            try:
                # Repeat the stop parsing process to build a list of all stop IDs
                remainingStops=train.stop_time_updates
                asString=str(remainingStops)
 
                # Apply the same string replacements as above to format the data
                asString=asString.replace('ID: ', 'ID: "')
                asString=asString.replace('Arr: ', 'Arr: "')
                asString=asString.replace('Dep: ', 'Dep: "')
                asString=asString.replace('Sched: ', 'Sched: "')
                asString=asString.replace('Act: ', 'Act: "')
                asString=asString.replace(', Arr', '", Arr')
                asString=asString.replace(', Dep', '", Dep')
                asString=asString.replace(', Sched', '", Sched')
                asString=asString.replace(', Act', '", Act')
                asString=asString.replace('ID:', '"ID":')
                asString=asString.replace('Arr:', '"Arr":')
                asString=asString.replace('Dep:', '"Dep":')
                asString=asString.replace('Sched:', '"Sched":')
                asString=asString.replace('Act:', '"Act":')
                asString=asString.replace('},', '"},')
                asString=asString.replace(', }', '", }')
                asString=asString.replace(', }', '}')
                asString=asString.replace('}]', '"}]')
 
                # Parse the formatted string into JSON
                asJson=json.loads(asString)
                numStops=len(asJson)
 
                # Build a dash-separated string of all stop IDs in the route
                allStopsList=""
                for thisStopNum in range(numStops):
                    thisStopID=asJson[thisStopNum]['ID']
                    if allStopsList=="":
                        allStopsList=thisStopID
                    else:
                        allStopsList=allStopsList+'-'+thisStopID
 
                # If the train is at the beginning of its route, estimate its completion time
                if stopIndex=="0" or stopIndex=="1":
                    expectedCompletion=str(asJson[numStops-1]['Arr'])
                    currentDate=str(train.start_date)
 
                    # Parse date and time components
                    year=int(currentDate[0:4])
                    month=int(currentDate[5:7])
                    day=int(currentDate[8:10])
                    hour=int(expectedCompletion[0:2])
                    minute=int(expectedCompletion[3:5])
                    second=int(expectedCompletion[6:8])
 
                    # Construct a datetime object for expected completion
                    expcompl = datetime(year, month, day, hour, minute, second)
 
                    # Convert to microsecond timestamp
                    expcompl_timestamp = str(int(expcompl.timestamp())* 1000000)
                else:
                    expcompl_timestamp=""
 
            except:
                # If parsing fails, log a note and set default values
                nothingNeeded = 1
                print('NOTE: Could not get all stops list')
                allStopsList = ""
                expcompl_timestamp=""
 
            # Send in all updates only if data was successfully read
            if failedread == 0:
 
                # Generate a unique train ID by sanitizing the assetID and prefixing with departure date
                # Example: "0L 1402+8AV/RPY" → "t_0L_1402_8AV_RPY"
                t_id = "t_"+re.sub('[^A-Za-z0-9]', '_', assetID)
                t_id = departureDateString+t_id
 
                # If this train has been seen before, send updates
                if t_id in train_list:
 
                    # Raw location status update
                    key1 = key1 + 1
                    temprecord = [key1, msr_timestamp, str(assetID), 'currentStatusRaw', str(location_status+"---"+location), 'data','','','','','','','','','','']
                    alltrips.append(tuple(temprecord))
                    numrecs = numrecs + 1
 
                    # Route update
                    key1 = key1 + 1
                    temprecord = [key1, msr_timestamp, str(assetID), 'route', str(route), 'data','','','','','','','','','','']
                    alltrips.append(tuple(temprecord))
                    numrecs = numrecs + 1
 
                    # Destination update, if available
                    if trainDestination != "":
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp,str(assetID),'trainDestination',trainDestination,'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
 
                    # Departure time update, if available
                    if departure_timestamp != "":
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp, str(assetID), 'trainDepartureTimestamp', str(departure_timestamp), 'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
 
                    # Expected completion time update, if just starting and available
                    if (stopIndex=="0" or stopIndex=="1") and expcompl_timestamp != "":
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp, str(assetID), 'trainExpArrivalTimestamp', str(expcompl_timestamp), 'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
 
                    # Remaining stops update, if available
                    if allStopsList != "":
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp, str(assetID), 'remainingStops', str(allStopsList), 'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
 
                    # Stop index update, if available
                    if stopIndex != "":
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp,str(assetID),'stopIndex',stopIndex,'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
 
                    # Location status update, based on status
                    if location_status == "STOPPED_AT":
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp,str(assetID),'currentLocation',location,'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
                    else:
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp,str(assetID),'currentLocation','enrouteTo'+location,'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
 
                    # Expected completion time update, if available
                    if expcompl_timestamp != "":
                        key1 = key1 + 1
                        temprecord = [key1, msr_timestamp, str(assetID), 'trainExpArrivalTimestamp', str(expcompl_timestamp), 'data','','','','','','','','','','']
                        alltrips.append(tuple(temprecord))
                        numrecs = numrecs + 1
 
                    # Update the train object in train_list with new data
                    t = train_list.get(t_id)
                    updates = t.update(route, trainDestination, location_status, location, msr_timestamp)
 
                    # Append each update from the Train class to alltrips
                    for x in updates:
                        key1 = key1 + 1
                        x.insert(0,key1)
                        alltrips.append(tuple(x))
                        numrecs = numrecs + 1
 
                # If train is new and not yet at its destination, create a new train object
                elif (location!="" and trainDestination!="" and location!=trainDestination):
                    key1 = key1 + 1
                    temprecord = [key1, msr_timestamp,'','','','updateAssets','add',str(assetID),'train', str(assetID),'Y','','','','','']
                    alltrips.append(tuple(temprecord))
                    numrecs = numrecs + 1
 
                    # Add new train object to train_list
                    train_list[t_id] = Train(assetID, route, trainDestination, location_status, location, msr_timestamp)
 
                # If train is at its destination or missing key data, skip processing
 
                # Print statements for debugging/logging
                """
                print('assetID:', assetID)
                print('location:', location)
                print('location_status:', location_status)
                print('len(remainingStops):', len(remainingStops))
                print('destination: ', trainDestination)
                """
 
            # If data read failed, log an error and record it
            else:
                print('WARNING: Missing information')
                key1 = key1 + 1
                temprecord = [key1, msr_timestamp,'readError','readError','readError','data','','','','','','','','','','']
                alltrips.append(tuple(temprecord))
                numrecs = numrecs + 1
 
    # Convert each tuple in alltrips into a structured dictionary and append to events
    for value in alltrips:
       e = {}
       e['key1'] = value[0]
       e['msr_timestamp'] = value[1]
       e['assetID'] = value[2]
       e['attributeID'] = value[3]
       e['value'] = value[4]
       e['action'] = value[5]
       e['updateAssetAction'] = value[6]
       e['updateAssetID'] = value[7]
       e['updateAssetType'] = value[8]
       e['updateAssetLabel'] = value[9]
       e['updateAssetOutputRequired'] = value[10]
       e['updateConnectionAction'] = value[11]
       e['updateHierarchyName'] = value[12]
       e['updateParentAssetID'] = value[13]
       e['updateDirection'] = value[14]
       e['updateChildAssetID'] = value[15]
       events.append(e)
 
    # Return the full list of structured event dictionaries
    return (events)
 
def create(data,context):
    """
    Entry point function for generating train tracking data.
 
    Args:
        data (dict): Contains metadata including the 'id' used for key generation.
        context (dict): Additional runtime context.
 
    Returns:
        events: A list of structured event dictionaries for the specified routes.
    """
    events = [] # Empty list to hold event records
 
    global key1
    key1=int(data["id"] * 100000.0) # Generate a base key using the input ID
 
    countCalls=int(data["id"]+1) # Used to determine when to trigger data collection
 
    # Only run GTFS data collection on specific cycles
    if (countCalls % 6) == 2 or (countCalls % 6) == 5:
 
        # List of subway routes to query
        routeList = [
                     ('L'),
                     ('1'),
                     ('6'),
                     ('7'),
                     ('E'),
                     ('Q')
                    ]
 
        # For each route, call the GTFS reader to collect and parse train data
        for route in routeList:
            gtfs_read_function(events,route)
 
    else:
        # Skip data collection on other cycles
        doNothing = 1
 
    # Return the compiled list of events
    return events]]></code>
</window-python>
 
<window-functional index="pi_EMPTY" pubsub="true" name="gtfs_split">
  <splitter-expr>
    <expression><![CDATA[if(action == "data") return 1
                   else if(action == "updateAssets") return 2
                   else if(action == "updateConnections") return 3
                   else return 1]]></expression>
  </splitter-expr>
  <schema>
    <fields>
      <field key="true" name="key1" type="int64"/>
      <field name="action" type="string"/>
      <field name="msr_timestamp" type="stamp"/>
      <field name="assetID" type="string"/>
      <field name="attributeID" type="string"/>
      <field name="value" type="string"/>
      <field name="updateAssetAction" type="string"/>
      <field name="updateAssetID" type="string"/>
      <field name="updateAssetType" type="string"/>
      <field name="updateAssetLabel" type="string"/>
      <field name="updateAssetOutputRequired" type="string"/>
      <field name="updateConnectionAction" type="string"/>
      <field name="updateHierarchyName" type="string"/>
      <field name="updateParentAssetID" type="string"/>
      <field name="updateDirection" type="string"/>
      <field name="updateChildAssetID" type="string"/>
    </fields>
  </schema>
</window-functional>
 
<window-functional index="pi_EMPTY" name="gtfs_updateAssets" pubsub="true">
  <schema>
    <fields>
      <field key="true" name="key1" type="int64"/>
      <field name="action" type="string"/>
      <field name="assetID" type="string"/>
      <field name="assetType" type="string"/>
      <field name="assetLabel" type="string"/>
      <field name="outputAssetRequired" type="string"/>
      <field name="msr_timestamp" type="stamp"/>
    </fields>
  </schema>
  <function-context>
    <functions>
      <function name="action"><![CDATA[$updateAssetAction]]></function>
      <function name="assetID"><![CDATA[$updateAssetID]]></function>
      <function name="assetType"><![CDATA[$updateAssetType]]></function>
      <function name="assetLabel"><![CDATA[$updateAssetLabel]]></function>
      <function name="outputAssetRequired"><![CDATA[$updateAssetOutputRequired]]></function>
    </functions>
  </function-context>
</window-functional>
 
<window-functional index="pi_EMPTY" name="gtfs_updateConnections" pubsub="true">
  <schema>
    <fields>
      <field key="true" name="key1" type="int64"/>
      <field name="action" type="string"/>
      <field name="hierarchyName" type="string"/>
      <field name="parentAssetID" type="string"/>
      <field name="direction" type="string"/>
      <field name="childAssetID" type="string"/>
      <field name="msr_timestamp" type="stamp"/>
    </fields>
  </schema>
  <function-context>
    <functions>
      <function name="action"><![CDATA[$updateConnectionAction]]></function>
      <function name="hierarchyName"><![CDATA[$updateHierarchyName]]></function>
      <function name="parentAssetID"><![CDATA[$updateParentAssetID]]></function>
      <function name="direction"><![CDATA[$updateDirection]]></function>
      <function name="childAssetID"><![CDATA[$updateChildAssetID]]></function>
    </functions>
  </function-context>
</window-functional>
 
<window-functional index="pi_EMPTY" name="gtfs_data" pubsub="true">
  <schema>
    <fields>
      <field key="true" name="key1" type="int64"/>
      <field name="msr_timestamp" type="stamp"/>
      <field name="assetID" type="string"/>
      <field name="attributeID" type="string"/>
      <field name="value" type="string"/>
    </fields>
  </schema>
</window-functional>
 
        <window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="unionDataSources"/>
        <window-filter name="unionDataFilter" func="filter">
          <code><![CDATA[
def filter(event,window):
    thisTimestamp=event["msr_timestamp"]
    thisAssetID=event["assetID"]
 
    if (thisTimestamp==0):
        return True
    elif (thisAssetID=='outputTrigger'):
        return True
    elif '@initialOutputTimestampUTC@'=='@'+'initialOutputTimestampUTC'+'@':
        return True
    elif (thisTimestamp > (float('@initialOutputTimestampUTC@') - (1000000.0 * @secondsNeededToMaintainState@))):
        return True
    else:
        return False
]]>
          </code>
        </window-filter>
        <window-calculate index="pi_EMPTY" collapse-updates="false" output-insert-only="true" name="updateCurrentValue" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="triggerTimestamp" type="stamp"/>
              <field name="consolidateStatusAB" type="string"/>
              <field name="rawRecordCount" type="int64"/>
              <field name="printRawQueueCount" type="int64"/>
              <field name="printTriggerQueueCount" type="int64"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="updateCurrentValueModule" function="runUpdateCurrentValue" revision="0" source="unionDataFilter"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="updateHistory" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="triggerTimestamp" type="stamp"/>
              <field name="consolidateStatusAB" type="string"/>
              <field name="rawRecordCount" type="int64"/>
              <field name="printRawQueueCount" type="int64"/>
              <field name="printTriggerQueueCount" type="int64"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="updateHistoryModule" function="runUpdateHistory" revision="0" source="updateCurrentValue"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="consolidateCurrentValue" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="triggerTimestamp" type="stamp"/>
              <field name="rawRecordCount" type="int64"/>
              <field name="printRawQueueCount" type="int64"/>
              <field name="printTriggerQueueCount" type="int64"/>
              <field name="processRecordType" type="string"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="consolidateCurrentValueModule" function="runConsolidateCurrentValue" revision="0" source="updateHistory"/>
          </mas-map>
        </window-calculate>
        <window-lua pubsub="true" index="pi_EMPTY" name="updateReadTimestampHistory" events="create">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="triggerTimestamp" type="stamp"/>
              <field name="next_timestamp" type="stamp"/>
              <field name="outputYN" type="int64"/>
              <field name="printTriggerQueueCount" type="int64"/>
              <field name="processRecordType" type="string"/>
            </fields>
          </schema>
          <use><![CDATA[key1,triggerTimestamp,printTriggerQueueCount,processRecordType]]></use>
          <code><![CDATA[
 
          function create(data,context)
            local next_timestamp = 0
            local chk1 = 0
            local chk2 = 0
            local outputYN = 0
            local events = {}
 
            local event = {}
            event["key1"] = data.key1
            event["triggerTimestamp"] = data.triggerTimestamp
 
            next_timestamp = data.triggerTimestamp
            event["next_timestamp"] = next_timestamp
 
            event["processRecordType"] = data.processRecordType
 
            if data.processRecordType == "output" then
              outputYN=0
            else
              local updateSucceeded = 0
              repeat
                local status , errormessage = esp_setProperty({name="nexttimestamp",value=next_timestamp})
                if not (status == true) then
                  print ("ERROR IN LUA SETPROPERTY HISTORY: ", errormessage)
 
                  local ntime = os.clock() + 0.023
                  repeat
                    local justWait = 1
                  until( os.clock() > ntime )
                else
                  updateSucceeded = 1
                end
              until( updateSucceeded == 1 )
 
              print ("HISTORY processing complete for ", tostring(data.triggerTimestamp/1000000.0))
              outputYN=1
            end
 
            event["outputYN"] = outputYN
 
            event["printTriggerQueueCount"] = data.printTriggerQueueCount
 
            events[1] = event
 
            return events
          end
 
          ]]></code>
        </window-lua>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="enrichDataModelStart" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="triggerTimestamp" type="stamp"/>
              <field name="rawRecordCount" type="int64"/>
              <field name="printRawQueueCount" type="int64"/>
              <field name="printTriggerQueueCount" type="int64"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="enrichDataModelStartModule" function="runEnrichDataModelStart" revision="0" source="consolidateCurrentValue"/>
          </mas-map>
        </window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_trainInStation" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_trainInStation" function="runCompute_station_trainInStation" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_nextStation" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_nextStation" function="runCompute_station_nextStation" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_nextTrack" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_nextTrack" function="runCompute_station_nextTrack" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_enrouteTrain1" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_enrouteTrain1" function="runCompute_track_enrouteTrain1" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_enrouteTrain2" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_enrouteTrain2" function="runCompute_track_enrouteTrain2" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_prevStation" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_prevStation" function="runCompute_station_prevStation" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_prevTrack" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_prevTrack" function="runCompute_station_prevTrack" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_lastDepartedTrainTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_lastDepartedTrainTime" function="runCompute_station_lastDepartedTrainTime" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_lastEnrouteTrainEnd" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_lastEnrouteTrainEnd" function="runCompute_track_lastEnrouteTrainEnd" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_lastDepartedTrain" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_lastDepartedTrain" function="runCompute_station_lastDepartedTrain" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_lastEnrouteTrain" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_lastEnrouteTrain" function="runCompute_track_lastEnrouteTrain" revision="0" source="enrichDataModelStart"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_nextStationTrain1" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_nextStationTrain1" function="runCompute_station_nextStationTrain1" revision="0" source="compute_station_nextStation"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_nextStationTrain2" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_nextStationTrain2" function="runCompute_station_nextStationTrain2" revision="0" source="compute_station_nextStation"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_nextTrackTrain1" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_nextTrackTrain1" function="runCompute_station_nextTrackTrain1" revision="0" source="compute_station_nextTrack"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_nextTrackTrain2" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_nextTrackTrain2" function="runCompute_station_nextTrackTrain2" revision="0" source="compute_station_nextTrack"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_numTrainsAtNextStation" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_numTrainsAtNextStation" function="runCompute_station_numTrainsAtNextStation" revision="0" source="compute_station_nextStation"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_numTrainsAtPrevStation" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_numTrainsAtPrevStation" function="runCompute_station_numTrainsAtPrevStation" revision="0" source="compute_station_prevStation"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_numTrainsEnrouteFromThis" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_numTrainsEnrouteFromThis" function="runCompute_station_numTrainsEnrouteFromThis" revision="0" source="compute_station_nextTrack"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_numTrainsEnrouteToThis" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_numTrainsEnrouteToThis" function="runCompute_station_numTrainsEnrouteToThis" revision="0" source="compute_station_prevTrack"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_train_trainLatitude" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_train_trainLatitude" function="runCompute_train_trainLatitude" revision="0" source="gate_train_trainLatitude"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_train_trainLongitude" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_train_trainLongitude" function="runCompute_train_trainLongitude" revision="0" source="gate_train_trainLongitude"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_prevStationTrain1" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_prevStationTrain1" function="runCompute_station_prevStationTrain1" revision="0" source="compute_station_prevStation"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_prevTrackTrain1" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_prevTrackTrain1" function="runCompute_station_prevTrackTrain1" revision="0" source="compute_station_prevTrack"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_prevStationTrain2" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_prevStationTrain2" function="runCompute_station_prevStationTrain2" revision="0" source="compute_station_prevStation"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_prevTrackTrain2" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_prevTrackTrain2" function="runCompute_station_prevTrackTrain2" revision="0" source="compute_station_prevTrack"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_lastDepartedTrainArrivalTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_lastDepartedTrainArrivalTime" function="runCompute_station_lastDepartedTrainArrivalTime" revision="0" source="compute_station_lastDepartedTrain"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_lastDepartedTrainStatus" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_lastDepartedTrainStatus" function="runCompute_station_lastDepartedTrainStatus" revision="0" source="compute_station_lastDepartedTrain"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_lastEnrouteTrainStart" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_lastEnrouteTrainStart" function="runCompute_track_lastEnrouteTrainStart" revision="0" source="compute_track_lastEnrouteTrain"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_lastEnrouteTrainStatus" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_lastEnrouteTrainStatus" function="runCompute_track_lastEnrouteTrainStatus" revision="0" source="compute_track_lastEnrouteTrain"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_expectedNextTrain1ID" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_expectedNextTrain1ID" function="runCompute_station_expectedNextTrain1ID" revision="0" source="gate_station_expectedNextTrain1ID"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_expectedNextTrain2ID" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_expectedNextTrain2ID" function="runCompute_station_expectedNextTrain2ID" revision="0" source="gate_station_expectedNextTrain2ID"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_waitTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_waitTime" function="runCompute_station_waitTime" revision="0" source="gate_station_waitTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_travelTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_travelTime" function="runCompute_track_travelTime" revision="0" source="gate_track_travelTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_waitTimeRollingAvg" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_waitTimeRollingAvg" function="runCompute_station_waitTimeRollingAvg" revision="0" source="compute_station_waitTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_track_travelTimeRollingAvg" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_track_travelTimeRollingAvg" function="runCompute_track_travelTimeRollingAvg" revision="0" source="compute_track_travelTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_prevTrackTravelTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_prevTrackTravelTime" function="runCompute_station_prevTrackTravelTime" revision="0" source="gate_station_prevTrackTravelTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_expectedNextTrain1Time" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_expectedNextTrain1Time" function="runCompute_station_expectedNextTrain1Time" revision="0" source="gate_station_expectedNextTrain1Time"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="compute_station_expectedNextTrain2Time" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="computeModule_station_expectedNextTrain2Time" function="runCompute_station_expectedNextTrain2Time" revision="0" source="gate_station_expectedNextTrain2Time"/>
</mas-map>
</window-calculate>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_train_trainLatitude"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_train_trainLongitude"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_station_expectedNextTrain1ID"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_station_expectedNextTrain2ID"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_station_waitTime"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_track_travelTime"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_station_prevTrackTravelTime"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_station_expectedNextTrain1Time"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_station_expectedNextTrain2Time"/>
<window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="gateUnion_endEnrichment"/>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_train_trainLatitude" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_train_trainLatitude" function="runGate_train_trainLatitude" revision="0" source="gateUnion_train_trainLatitude"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_train_trainLongitude" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_train_trainLongitude" function="runGate_train_trainLongitude" revision="0" source="gateUnion_train_trainLongitude"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_station_expectedNextTrain1ID" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_station_expectedNextTrain1ID" function="runGate_station_expectedNextTrain1ID" revision="0" source="gateUnion_station_expectedNextTrain1ID"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_station_expectedNextTrain2ID" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_station_expectedNextTrain2ID" function="runGate_station_expectedNextTrain2ID" revision="0" source="gateUnion_station_expectedNextTrain2ID"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_station_waitTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_station_waitTime" function="runGate_station_waitTime" revision="0" source="gateUnion_station_waitTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_track_travelTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_track_travelTime" function="runGate_track_travelTime" revision="0" source="gateUnion_track_travelTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_station_prevTrackTravelTime" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_station_prevTrackTravelTime" function="runGate_station_prevTrackTravelTime" revision="0" source="gateUnion_station_prevTrackTravelTime"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_station_expectedNextTrain1Time" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_station_expectedNextTrain1Time" function="runGate_station_expectedNextTrain1Time" revision="0" source="gateUnion_station_expectedNextTrain1Time"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="gate_station_expectedNextTrain2Time" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
<field name="previousWindowName" type="string"/>
</fields>
</schema>
<mas-map>
<window-map module="gateModule_station_expectedNextTrain2Time" function="runGate_station_expectedNextTrain2Time" revision="0" source="gateUnion_station_expectedNextTrain2Time"/>
</mas-map>
</window-calculate>
<window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="enrichDataModelEnd" algorithm="MAS">
<schema>
<fields>
<field name="key1" type="int64" key="true"/>
<field name="triggerTimestamp" type="stamp"/>
</fields>
</schema>
<mas-map>
<window-map module="enrichDataModelEndModule" function="runEnrichDataModelEnd" revision="0" source="gateUnion_endEnrichment"/>
</mas-map>
</window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputRecords_station" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="expectedNextTrain1ID" type="string"/>
              <field name="expectedNextTrain1Time" type="string"/>
              <field name="expectedNextTrain2ID" type="string"/>
              <field name="expectedNextTrain2Time" type="string"/>
              <field name="lastDepartedTrain" type="string"/>
              <field name="lastDepartedTrainStatus" type="string"/>
              <field name="nextStationTrain1" type="string"/>
              <field name="nextStationTrain2" type="string"/>
              <field name="nextTrackTrain1" type="string"/>
              <field name="nextTrackTrain2" type="string"/>
              <field name="numTrainsAtNextStation" type="double"/>
              <field name="numTrainsAtPrevStation" type="double"/>
              <field name="numTrainsEnrouteFromThis" type="double"/>
              <field name="numTrainsEnrouteToThis" type="double"/>
              <field name="prevStationTrain1" type="string"/>
              <field name="prevStationTrain2" type="string"/>
              <field name="prevTrackTrain1" type="string"/>
              <field name="prevTrackTrain2" type="string"/>
              <field name="prevTrackTravelTime" type="double"/>
              <field name="route" type="string"/>
              <field name="stationLatitude" type="double"/>
              <field name="stationLongitude" type="double"/>
              <field name="trainArrival" type="string"/>
              <field name="trainDepartureFrom" type="string"/>
              <field name="trainDepartureTo" type="string"/>
              <field name="trainInStation" type="string"/>
              <field name="waitTime" type="double"/>
              <field name="waitTimeRollingAvg" type="double"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputRecords_stationModule" function="runOutputRecords_station" revision="0" source="enrichDataModelEnd"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputRecords_station_gate" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputRecords_station_gateModule" function="runOutputRecords_station_gate" revision="0" source="outputRecords_station"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputRecords_track" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="enrouteToEnd" type="string"/>
              <field name="enrouteToStart" type="string"/>
              <field name="enrouteTrain1" type="string"/>
              <field name="enrouteTrain2" type="string"/>
              <field name="lastEnrouteTrain" type="string"/>
              <field name="lastEnrouteTrainEnd" type="double"/>
              <field name="lastEnrouteTrainStart" type="double"/>
              <field name="lastEnrouteTrainStatus" type="string"/>
              <field name="route" type="string"/>
              <field name="trackLatitude" type="double"/>
              <field name="trackLatitude1" type="double"/>
              <field name="trackLongitude" type="double"/>
              <field name="trackLongitude1" type="double"/>
              <field name="travelTime" type="double"/>
              <field name="travelTimeRollingAvg" type="double"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputRecords_trackModule" function="runOutputRecords_track" revision="0" source="enrichDataModelEnd"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputRecords_track_gate" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputRecords_track_gateModule" function="runOutputRecords_track_gate" revision="0" source="outputRecords_track"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputRecords_train" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="currentLocation" type="string"/>
              <field name="currentStatus" type="string"/>
              <field name="currentStatusRaw" type="string"/>
              <field name="remainingStops" type="string"/>
              <field name="route" type="string"/>
              <field name="stationArrival" type="string"/>
              <field name="stationDepartureFrom" type="string"/>
              <field name="stationDepartureTo" type="string"/>
              <field name="stopIndex" type="double"/>
              <field name="trackEnrouteToEnd" type="string"/>
              <field name="trackEnrouteToStart" type="string"/>
              <field name="trainDepartureTimestamp" type="double"/>
              <field name="trainDestination" type="string"/>
              <field name="trainExpArrivalTimestamp" type="double"/>
              <field name="trainLatitude" type="double"/>
              <field name="trainLongitude" type="double"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputRecords_trainModule" function="runOutputRecords_train" revision="0" source="enrichDataModelEnd"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputRecords_train_gate" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputRecords_train_gateModule" function="runOutputRecords_train_gate" revision="0" source="outputRecords_train"/>
          </mas-map>
        </window-calculate>
        <window-union strict="true" index="pi_EMPTY" output-insert-only="true" name="outputRecords_union" collapse-updates="true"/>
        <window-functional pubsub="true" index="pi_EMPTY" name="outputRecords_heartBeat">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <function-context>
            <functions>
              <function name="key2"><![CDATA[1]]></function>
              <function name="assetType"><![CDATA['heartBeat']]></function>
              <function name="msr_timestamp"><![CDATA[triggerTimestamp]]></function>
            </functions>
          </function-context>
        </window-functional>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputRecords_gate" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="msr_timestamp" type="stamp"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputRecords_gateModule" function="runOutputRecords_gate" revision="0" source="outputRecords_union"/>
          </mas-map>
        </window-calculate>
        <window-calculate index="pi_EMPTY" collapse-updates="true" output-insert-only="true" name="outputCompletion" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="printTriggerQueueCount" type="int64"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="outputCompletionModule" function="runOutputCompletion" revision="0" source="outputRecords_gate"/>
          </mas-map>
        </window-calculate>
        <window-lua pubsub="true" index="pi_EMPTY" name="updateReadTimestamp" events="create">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="next_timestamp" type="stamp"/>
              <field name="outputYN" type="int64"/>
              <field name="printTriggerQueueCount" type="int64"/>
            </fields>
          </schema>
          <use><![CDATA[key1,key2,msr_timestamp,printTriggerQueueCount]]></use>
          <code><![CDATA[
 
          function create(data,context)
            local next_timestamp = 0
            local events = {}
 
            local event = {}
            event["key1"] = data.key1
            event["key2"] = data.key2
            event["msr_timestamp"] = data.msr_timestamp
 
            next_timestamp = data.msr_timestamp
            event["next_timestamp"] = next_timestamp
 
            outputYN=1
            local updateSucceeded = 0
            repeat
              local status , errormessage = esp_setProperty({name="nexttimestamp",value=next_timestamp})
              if not (status == true) then
                print ("ERROR IN LUA SETPROPERTY OUTPUT: ", errormessage)
 
                local ntime = os.clock() + 0.023
                repeat
                  local justWait = 1
                until( os.clock() > ntime )
              else
                updateSucceeded = 1
              end
            until( updateSucceeded == 1 )
 
            print ("OUTPUT processing complete for ", tostring(data.msr_timestamp/1000000.0))
            event["outputYN"] = outputYN
 
            event["printTriggerQueueCount"] = data.printTriggerQueueCount
 
            events[1] = event
 
            return events
          end
 
          ]]></code>
        </window-lua>
        <window-functional pubsub="true" index="pi_EMPTY" name="scoredRecordsUnion_station">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="expectedNextTrain1ID" type="string"/>
              <field name="expectedNextTrain1Time" type="string"/>
              <field name="expectedNextTrain2ID" type="string"/>
              <field name="expectedNextTrain2Time" type="string"/>
              <field name="lastDepartedTrain" type="string"/>
              <field name="lastDepartedTrainStatus" type="string"/>
              <field name="nextStationTrain1" type="string"/>
              <field name="nextStationTrain2" type="string"/>
              <field name="nextTrackTrain1" type="string"/>
              <field name="nextTrackTrain2" type="string"/>
              <field name="numTrainsAtNextStation" type="double"/>
              <field name="numTrainsAtPrevStation" type="double"/>
              <field name="numTrainsEnrouteFromThis" type="double"/>
              <field name="numTrainsEnrouteToThis" type="double"/>
              <field name="prevStationTrain1" type="string"/>
              <field name="prevStationTrain2" type="string"/>
              <field name="prevTrackTrain1" type="string"/>
              <field name="prevTrackTrain2" type="string"/>
              <field name="prevTrackTravelTime" type="double"/>
              <field name="route" type="string"/>
              <field name="stationLatitude" type="double"/>
              <field name="stationLongitude" type="double"/>
              <field name="trainArrival" type="string"/>
              <field name="trainDepartureFrom" type="string"/>
              <field name="trainDepartureTo" type="string"/>
              <field name="trainInStation" type="string"/>
              <field name="waitTime" type="double"/>
              <field name="waitTimeRollingAvg" type="double"/>
            </fields>
          </schema>
        </window-functional>
        <window-calculate pubsub="true" index="pi_EMPTY" produces-only-inserts="true" name="scoredRecords_station" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="expectedNextTrain1ID" type="string"/>
              <field name="expectedNextTrain1Time" type="string"/>
              <field name="expectedNextTrain2ID" type="string"/>
              <field name="expectedNextTrain2Time" type="string"/>
              <field name="lastDepartedTrain" type="string"/>
              <field name="lastDepartedTrainStatus" type="string"/>
              <field name="nextStationTrain1" type="string"/>
              <field name="nextStationTrain2" type="string"/>
              <field name="nextTrackTrain1" type="string"/>
              <field name="nextTrackTrain2" type="string"/>
              <field name="numTrainsAtNextStation" type="double"/>
              <field name="numTrainsAtPrevStation" type="double"/>
              <field name="numTrainsEnrouteFromThis" type="double"/>
              <field name="numTrainsEnrouteToThis" type="double"/>
              <field name="prevStationTrain1" type="string"/>
              <field name="prevStationTrain2" type="string"/>
              <field name="prevTrackTrain1" type="string"/>
              <field name="prevTrackTrain2" type="string"/>
              <field name="prevTrackTravelTime" type="double"/>
              <field name="route" type="string"/>
              <field name="stationLatitude" type="double"/>
              <field name="stationLongitude" type="double"/>
              <field name="trainArrival" type="string"/>
              <field name="trainDepartureFrom" type="string"/>
              <field name="trainDepartureTo" type="string"/>
              <field name="trainInStation" type="string"/>
              <field name="waitTime" type="double"/>
              <field name="waitTimeRollingAvg" type="double"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="station_scoredRecords" function="runScoredRecords" revision="0" source="scoredRecordsUnion_station"/>
          </mas-map>
        </window-calculate>
        <window-functional pubsub="true" index="pi_EMPTY" name="scoredRecordsUnion_track">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="enrouteToEnd" type="string"/>
              <field name="enrouteToStart" type="string"/>
              <field name="enrouteTrain1" type="string"/>
              <field name="enrouteTrain2" type="string"/>
              <field name="lastEnrouteTrain" type="string"/>
              <field name="lastEnrouteTrainEnd" type="double"/>
              <field name="lastEnrouteTrainStart" type="double"/>
              <field name="lastEnrouteTrainStatus" type="string"/>
              <field name="route" type="string"/>
              <field name="trackLatitude" type="double"/>
              <field name="trackLatitude1" type="double"/>
              <field name="trackLongitude" type="double"/>
              <field name="trackLongitude1" type="double"/>
              <field name="travelTime" type="double"/>
              <field name="travelTimeRollingAvg" type="double"/>
            </fields>
          </schema>
        </window-functional>
        <window-calculate pubsub="true" index="pi_EMPTY" produces-only-inserts="true" name="scoredRecords_track" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="enrouteToEnd" type="string"/>
              <field name="enrouteToStart" type="string"/>
              <field name="enrouteTrain1" type="string"/>
              <field name="enrouteTrain2" type="string"/>
              <field name="lastEnrouteTrain" type="string"/>
              <field name="lastEnrouteTrainEnd" type="double"/>
              <field name="lastEnrouteTrainStart" type="double"/>
              <field name="lastEnrouteTrainStatus" type="string"/>
              <field name="route" type="string"/>
              <field name="trackLatitude" type="double"/>
              <field name="trackLatitude1" type="double"/>
              <field name="trackLongitude" type="double"/>
              <field name="trackLongitude1" type="double"/>
              <field name="travelTime" type="double"/>
              <field name="travelTimeRollingAvg" type="double"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="track_scoredRecords" function="runScoredRecords" revision="0" source="scoredRecordsUnion_track"/>
          </mas-map>
        </window-calculate>
        <window-functional pubsub="true" index="pi_EMPTY" name="scoredRecordsUnion_train">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="currentLocation" type="string"/>
              <field name="currentStatus" type="string"/>
              <field name="currentStatusRaw" type="string"/>
              <field name="remainingStops" type="string"/>
              <field name="route" type="string"/>
              <field name="stationArrival" type="string"/>
              <field name="stationDepartureFrom" type="string"/>
              <field name="stationDepartureTo" type="string"/>
              <field name="stopIndex" type="double"/>
              <field name="trackEnrouteToEnd" type="string"/>
              <field name="trackEnrouteToStart" type="string"/>
              <field name="trainDepartureTimestamp" type="double"/>
              <field name="trainDestination" type="string"/>
              <field name="trainExpArrivalTimestamp" type="double"/>
              <field name="trainLatitude" type="double"/>
              <field name="trainLongitude" type="double"/>
            </fields>
          </schema>
        </window-functional>
        <window-calculate pubsub="true" index="pi_EMPTY" produces-only-inserts="true" name="scoredRecords_train" algorithm="MAS">
          <schema>
            <fields>
              <field name="key1" type="int64" key="true"/>
              <field name="key2" type="int64" key="true"/>
              <field name="assetType" type="string"/>
              <field name="assetID" type="string"/>
              <field name="msr_timestamp" type="stamp"/>
              <field name="currentLocation" type="string"/>
              <field name="currentStatus" type="string"/>
              <field name="currentStatusRaw" type="string"/>
              <field name="remainingStops" type="string"/>
              <field name="route" type="string"/>
              <field name="stationArrival" type="string"/>
              <field name="stationDepartureFrom" type="string"/>
              <field name="stationDepartureTo" type="string"/>
              <field name="stopIndex" type="double"/>
              <field name="trackEnrouteToEnd" type="string"/>
              <field name="trackEnrouteToStart" type="string"/>
              <field name="trainDepartureTimestamp" type="double"/>
              <field name="trainDestination" type="string"/>
              <field name="trainExpArrivalTimestamp" type="double"/>
              <field name="trainLatitude" type="double"/>
              <field name="trainLongitude" type="double"/>
            </fields>
          </schema>
          <mas-map>
            <window-map module="train_scoredRecords" function="runScoredRecords" revision="0" source="scoredRecordsUnion_train"/>
          </mas-map>
        </window-calculate>
<window-filter name="train_output_cas">
  <expression><![CDATA[true]]></expression>
  <connectors>
    <connector class='adapter' name='train_copy_to_cas'>
      <properties>
        <property name='command'><![CDATA[dfesp_cas_adapter -C type=sub,cashostport=@CASHOST@:@CASPORT@,castable=train,loglevel=info,caslib=public,restartonerror=true,periodicity=900,casoauthtokenfromserver=true]]></property>
        <property name='type'><![CDATA[sub]]></property>
      </properties>
    </connector>
  </connectors>
</window-filter>
 
<window-filter name="station_output_cas">
  <expression><![CDATA[true]]></expression>
  <connectors>
    <connector class='adapter' name='station_copy_to_cas'>
      <properties>
        <property name='command'><![CDATA[dfesp_cas_adapter -C type=sub,cashostport=@CASHOST@:@CASPORT@,castable=station,loglevel=info,caslib=public,restartonerror=true,periodicity=900,casoauthtokenfromserver=true]]></property>
        <property name='type'><![CDATA[sub]]></property>
      </properties>
    </connector>
  </connectors>
</window-filter>
 
<window-filter name="track_output_cas">
  <expression><![CDATA[true]]></expression>
  <connectors>
    <connector class='adapter' name='track_copy_to_cas'>
      <properties>
        <property name='command'><![CDATA[dfesp_cas_adapter -C type=sub,cashostport=@CASHOST@:@CASPORT@,castable=track,loglevel=info,caslib=public,restartonerror=true,periodicity=900,casoauthtokenfromserver=true]]></property>
        <property name='type'><![CDATA[sub]]></property>
      </properties>
    </connector>
  </connectors>
</window-filter>
 
      </windows>
      <edges>
        <edge source="readAssetTypeDefinitions" target="defineAssetTypes" role="data"/>
        <edge source="readAttributeDefinitions" target="defineAttributes" role="data"/>
        <edge source="readHierarchyDefinitions" target="defineHierarchies" role="data"/>
 
        <edge source="initialAssetUpdates"            target="initialAssetUpdatesForUnion"/>
        <edge source="initialAssetUpdatesForUnion"    target="unionAssetUpdates"/>
        <edge source="ongoingAssetUpdates"            target="ongoingAssetUpdatesForUnion"/>
        <edge source="ongoingAssetUpdatesForUnion"    target="unionAssetUpdates"/>
         <edge source="historicalAssetUpdates"         target="unionAssetUpdates"/>
        <edge source="unionAssetUpdates"              target="updateAssets" role="data"/>
 
        <edge source="initialHierarchyUpdates"         target="initialHierarchyUpdatesForUnion"/>
        <edge source="initialHierarchyUpdatesForUnion" target="unionHierarchyUpdates"/>
        <edge source="ongoingHierarchyUpdates"         target="ongoingHierarchyUpdatesForUnion"/>
        <edge source="ongoingHierarchyUpdatesForUnion" target="unionHierarchyUpdates"/>
         <edge source="historicalHierarchyUpdates"      target="unionHierarchyUpdates"/>
        <edge source="unionHierarchyUpdates"           target="updateHierarchies" role="data"/>
 
        <edge source="staticAttributesDataSource" target="unionDataSources"/>
        <edge source="historicalData"             target="unionDataSources"/>
 
        <edge source="historicalDataSource"         target="historicalDataSourceSplitter"/>
        <edge source="historicalDataSourceSplitter" target="historicalData"/>
         <edge source="historicalDataSourceSplitter" target="historicalAssetUpdates" slot="2"/>
         <edge source="historicalDataSourceSplitter" target="historicalHierarchyUpdates" slot="3"/>
 
        <edge source="realtimeTriggerRaw"   target="realtimeTrigger"/>
        <edge source="realtimeTrigger"      target="unionDataSources"/>
 
 
<edge source="gtfs_pulse" target="gtfs_read"/>
<edge source="gtfs_read" target="gtfs_split"/>
 
<edge slot="1" source="gtfs_split" target="gtfs_data"/>
<edge slot="2" source="gtfs_split" target="gtfs_updateAssets"/>
<edge slot="3" source="gtfs_split" target="gtfs_updateConnections"/>
 
<edge source="gtfs_data" target="unionDataSources"/>
<edge source="gtfs_updateAssets" target="unionAssetUpdates"/>
<edge source="gtfs_updateConnections" target="unionHierarchyUpdates"/>
 
 
        <edge source="unionDataSources"        target="unionDataFilter"/>
        <edge source="unionDataFilter"         target="updateCurrentValue" role="data"/>
        <edge source="updateCurrentValue"      target="updateHistory" role="data"/>
        <edge source="updateHistory"           target="consolidateCurrentValue" role="data"/>
        <edge source="consolidateCurrentValue" target="enrichDataModelStart" role="data"/>
        <edge source="consolidateCurrentValue" target="updateReadTimestampHistory" role="data"/>
 
<edge source="enrichDataModelStart" target="compute_station_trainInStation" role="data"/>
<edge source="enrichDataModelStart" target="compute_station_nextStation" role="data"/>
<edge source="enrichDataModelStart" target="compute_station_nextTrack" role="data"/>
<edge source="enrichDataModelStart" target="compute_track_enrouteTrain1" role="data"/>
<edge source="enrichDataModelStart" target="compute_track_enrouteTrain2" role="data"/>
<edge source="enrichDataModelStart" target="compute_station_prevStation" role="data"/>
<edge source="enrichDataModelStart" target="compute_station_prevTrack" role="data"/>
<edge source="enrichDataModelStart" target="compute_station_lastDepartedTrainTime" role="data"/>
<edge source="enrichDataModelStart" target="compute_track_lastEnrouteTrainEnd" role="data"/>
<edge source="enrichDataModelStart" target="compute_station_lastDepartedTrain" role="data"/>
<edge source="enrichDataModelStart" target="compute_track_lastEnrouteTrain" role="data"/>
<edge source="gateUnion_train_trainLatitude" target="gate_train_trainLatitude" role="data"/>
<edge source="gateUnion_train_trainLongitude" target="gate_train_trainLongitude" role="data"/>
<edge source="compute_station_nextStation" target="compute_station_nextStationTrain1" role="data"/>
<edge source="compute_station_nextStation" target="compute_station_nextStationTrain2" role="data"/>
<edge source="compute_station_nextTrack" target="compute_station_nextTrackTrain1" role="data"/>
<edge source="compute_station_nextTrack" target="compute_station_nextTrackTrain2" role="data"/>
<edge source="compute_station_nextStation" target="compute_station_numTrainsAtNextStation" role="data"/>
<edge source="compute_station_prevStation" target="compute_station_numTrainsAtPrevStation" role="data"/>
<edge source="compute_station_nextTrack" target="compute_station_numTrainsEnrouteFromThis" role="data"/>
<edge source="compute_station_prevTrack" target="compute_station_numTrainsEnrouteToThis" role="data"/>
<edge source="gate_train_trainLatitude" target="compute_train_trainLatitude" role="data"/>
<edge source="gate_train_trainLongitude" target="compute_train_trainLongitude" role="data"/>
<edge source="compute_station_prevStation" target="compute_station_prevStationTrain1" role="data"/>
<edge source="compute_station_prevTrack" target="compute_station_prevTrackTrain1" role="data"/>
<edge source="compute_station_prevStation" target="compute_station_prevStationTrain2" role="data"/>
<edge source="compute_station_prevTrack" target="compute_station_prevTrackTrain2" role="data"/>
<edge source="compute_station_lastDepartedTrain" target="compute_station_lastDepartedTrainArrivalTime" role="data"/>
<edge source="compute_station_lastDepartedTrain" target="compute_station_lastDepartedTrainStatus" role="data"/>
<edge source="compute_track_lastEnrouteTrain" target="compute_track_lastEnrouteTrainStart" role="data"/>
<edge source="compute_track_lastEnrouteTrain" target="compute_track_lastEnrouteTrainStatus" role="data"/>
<edge source="gateUnion_station_expectedNextTrain1ID" target="gate_station_expectedNextTrain1ID" role="data"/>
<edge source="gateUnion_station_expectedNextTrain2ID" target="gate_station_expectedNextTrain2ID" role="data"/>
<edge source="gateUnion_station_waitTime" target="gate_station_waitTime" role="data"/>
<edge source="gateUnion_track_travelTime" target="gate_track_travelTime" role="data"/>
<edge source="gate_station_expectedNextTrain1ID" target="compute_station_expectedNextTrain1ID" role="data"/>
<edge source="gate_station_expectedNextTrain2ID" target="compute_station_expectedNextTrain2ID" role="data"/>
<edge source="gate_station_waitTime" target="compute_station_waitTime" role="data"/>
<edge source="gate_track_travelTime" target="compute_track_travelTime" role="data"/>
<edge source="compute_station_waitTime" target="compute_station_waitTimeRollingAvg" role="data"/>
<edge source="compute_track_travelTime" target="compute_track_travelTimeRollingAvg" role="data"/>
<edge source="gateUnion_station_prevTrackTravelTime" target="gate_station_prevTrackTravelTime" role="data"/>
<edge source="gate_station_prevTrackTravelTime" target="compute_station_prevTrackTravelTime" role="data"/>
<edge source="gateUnion_station_expectedNextTrain1Time" target="gate_station_expectedNextTrain1Time" role="data"/>
<edge source="gate_station_expectedNextTrain1Time" target="compute_station_expectedNextTrain1Time" role="data"/>
<edge source="gateUnion_station_expectedNextTrain2Time" target="gate_station_expectedNextTrain2Time" role="data"/>
<edge source="gate_station_expectedNextTrain2Time" target="compute_station_expectedNextTrain2Time" role="data"/>
<edge source="gateUnion_endEnrichment" target="enrichDataModelEnd" role="data"/>
<edge source="compute_station_prevStationTrain1" target="gateUnion_station_expectedNextTrain1ID"/>
<edge source="compute_station_prevTrackTrain1" target="gateUnion_station_expectedNextTrain1ID"/>
<edge source="compute_station_prevStationTrain1" target="gateUnion_station_expectedNextTrain1Time"/>
<edge source="compute_station_prevTrackTrain1" target="gateUnion_station_expectedNextTrain1Time"/>
<edge source="compute_station_prevTrackTravelTime" target="gateUnion_station_expectedNextTrain1Time"/>
<edge source="compute_station_prevStationTrain1" target="gateUnion_station_expectedNextTrain2ID"/>
<edge source="compute_station_prevStationTrain2" target="gateUnion_station_expectedNextTrain2ID"/>
<edge source="compute_station_prevTrackTrain1" target="gateUnion_station_expectedNextTrain2ID"/>
<edge source="compute_station_prevTrackTrain2" target="gateUnion_station_expectedNextTrain2ID"/>
<edge source="compute_station_expectedNextTrain1Time" target="gateUnion_station_expectedNextTrain2Time"/>
<edge source="compute_station_prevStationTrain1" target="gateUnion_station_expectedNextTrain2Time"/>
<edge source="compute_station_prevStationTrain2" target="gateUnion_station_expectedNextTrain2Time"/>
<edge source="compute_station_prevTrackTrain1" target="gateUnion_station_expectedNextTrain2Time"/>
<edge source="compute_station_prevTrackTrain2" target="gateUnion_station_expectedNextTrain2Time"/>
<edge source="compute_station_prevTrackTravelTime" target="gateUnion_station_expectedNextTrain2Time"/>
<edge source="compute_station_prevTrack" target="gateUnion_station_prevTrackTravelTime"/>
<edge source="compute_track_travelTimeRollingAvg" target="gateUnion_station_prevTrackTravelTime"/>
<edge source="compute_station_lastDepartedTrainArrivalTime" target="gateUnion_station_waitTime"/>
<edge source="compute_station_lastDepartedTrainStatus" target="gateUnion_station_waitTime"/>
<edge source="compute_station_lastDepartedTrainTime" target="gateUnion_station_waitTime"/>
<edge source="compute_track_lastEnrouteTrainEnd" target="gateUnion_track_travelTime"/>
<edge source="compute_track_lastEnrouteTrainStart" target="gateUnion_track_travelTime"/>
<edge source="compute_track_lastEnrouteTrainStatus" target="gateUnion_track_travelTime"/>
<edge source="compute_track_enrouteTrain1" target="gateUnion_train_trainLatitude"/>
<edge source="compute_track_enrouteTrain2" target="gateUnion_train_trainLatitude"/>
<edge source="compute_track_enrouteTrain1" target="gateUnion_train_trainLongitude"/>
<edge source="compute_track_enrouteTrain2" target="gateUnion_train_trainLongitude"/>
<edge source="compute_station_expectedNextTrain1ID" target="gateUnion_endEnrichment"/>
<edge source="compute_station_expectedNextTrain2ID" target="gateUnion_endEnrichment"/>
<edge source="compute_station_expectedNextTrain2Time" target="gateUnion_endEnrichment"/>
<edge source="compute_station_nextStationTrain1" target="gateUnion_endEnrichment"/>
<edge source="compute_station_nextStationTrain2" target="gateUnion_endEnrichment"/>
<edge source="compute_station_nextTrackTrain1" target="gateUnion_endEnrichment"/>
<edge source="compute_station_nextTrackTrain2" target="gateUnion_endEnrichment"/>
<edge source="compute_station_numTrainsAtNextStation" target="gateUnion_endEnrichment"/>
<edge source="compute_station_numTrainsAtPrevStation" target="gateUnion_endEnrichment"/>
<edge source="compute_station_numTrainsEnrouteFromThis" target="gateUnion_endEnrichment"/>
<edge source="compute_station_numTrainsEnrouteToThis" target="gateUnion_endEnrichment"/>
<edge source="compute_station_trainInStation" target="gateUnion_endEnrichment"/>
<edge source="compute_station_waitTimeRollingAvg" target="gateUnion_endEnrichment"/>
<edge source="compute_train_trainLatitude" target="gateUnion_endEnrichment"/>
<edge source="compute_train_trainLongitude" target="gateUnion_endEnrichment"/>
 
        <edge source="enrichDataModelEnd" target="outputRecords_station" role="data"/>
        <edge source="outputRecords_station" target="outputRecords_station_gate" role="data"/>
        <edge source="outputRecords_station_gate" target="outputRecords_union"/>
 
        <edge source="enrichDataModelEnd" target="outputRecords_track" role="data"/>
        <edge source="outputRecords_track" target="outputRecords_track_gate" role="data"/>
        <edge source="outputRecords_track_gate" target="outputRecords_union"/>
 
        <edge source="enrichDataModelEnd" target="outputRecords_train" role="data"/>
        <edge source="outputRecords_train" target="outputRecords_train_gate" role="data"/>
        <edge source="outputRecords_train_gate" target="outputRecords_union"/>
 
 
        <edge source="enrichDataModelEnd" target="outputRecords_heartBeat"/>
        <edge source="outputRecords_heartBeat" target="outputRecords_union"/>
        <edge source="outputRecords_union" target="outputRecords_gate" role="data"/>
        <edge source="outputRecords_gate" target="outputCompletion" role="data"/>
        <edge source="outputCompletion" target="updateReadTimestamp"/>
 
        <edge source="outputRecords_station" target="scoredRecordsUnion_station"/>
        <edge source="scoredRecordsUnion_station" target="scoredRecords_station" role="data"/>
        <edge source="outputRecords_track" target="scoredRecordsUnion_track"/>
        <edge source="scoredRecordsUnion_track" target="scoredRecords_track" role="data"/>
        <edge source="outputRecords_train" target="scoredRecordsUnion_train"/>
        <edge source="scoredRecordsUnion_train" target="scoredRecords_train" role="data"/>
 
<edge source="scoredRecords_train" target="train_output_cas" role="data"/>
<edge source="scoredRecords_station" target="station_output_cas" role="data"/>
<edge source="scoredRecords_track" target="track_output_cas" role="data"/>
 
 
 
      </edges>
 
    </contquery>
  </contqueries>
 
  <project-connectors>
    <connector-groups>
      <connector-group name="initializeAssetTypes">
        <connector-entry connector="cq1/readAssetTypeDefinitions/assetTypeDefinitionsConnector" state="finished"/>
      </connector-group>
      <connector-group name="initializeAttributes">
        <connector-entry connector="cq1/readAttributeDefinitions/attributeDefinitionsConnector" state="finished"/>
      </connector-group>
      <connector-group name="initializeHierarchyList">
        <connector-entry connector="cq1/readHierarchyDefinitions/hierarchyDefinitionsConnector" state="finished"/>
      </connector-group>
      <connector-group name="initializeAssets">
        <connector-entry connector="cq1/initialAssetUpdates/initialAssetUpdatesConnector" state="finished"/>
      </connector-group>
      <connector-group name="initializeHierarchyMap">
        <connector-entry connector="cq1/initialHierarchyUpdates/initialHierarchyUpdatesConnector" state="finished"/>
      </connector-group>
      <connector-group name="realtimeTriggers">
        <connector-entry connector="cq1/realtimeTriggerRaw/realtimeTriggerConnector" state="running"/>
      </connector-group>
      <connector-group name="staticAttributes">
        <connector-entry connector="cq1/staticAttributesDataSource/staticAttributesConnector" state="finished"/>
      </connector-group>
      <connector-group name="output">
        <connector-entry connector="cq1/station_output_cas/station_copy_to_cas" state="running"/>
        <connector-entry connector="cq1/track_output_cas/track_copy_to_cas" state="running"/>
        <connector-entry connector="cq1/train_output_cas/train_copy_to_cas" state="running"/>
      </connector-group>
      <connector-group name="dataSource">
        <connector-entry connector="cq1/gtfs_pulse/gtfs_connector" state="running"/>
      </connector-group>
    </connector-groups>
    <edges>
      <edge source="initializeAssetTypes" target="initializeAttributes"/>
      <edge source="initializeAttributes" target="initializeHierarchyList"/>
      <edge source="initializeHierarchyList" target="initializeAssets"/>
      <edge source="initializeAssets" target="initializeHierarchyMap"/>
      <edge source="initializeHierarchyMap" target="realtimeTriggers"/>
      <edge source="realtimeTriggers" target="staticAttributes"/>
      <edge source="staticAttributes" target="output"/>
      <edge source="output" target="dataSource"/>
    </edges>
  </project-connectors>
 
</project>
